{"file_contents":{"README.md":{"content":"# ü§ñ Cortex Bot\n\nThis is a WhatsApp bot built using the Baileys library for group management, including features like tagging all members, muting/unmuting, and many more. It's designed to help admins efficiently manage WhatsApp groups.\n\n<div align=\"center\"> \n  <a href=\"https://git.io/typing-svg\"> \n    <img src=\"https://readme-typing-svg.demolab.com?font=Ribeye&size=50&pause=1000&color=33ff00&center=true&width=910&height=100&lines=Cortex-Bot;Multi+Device+Whatsapp+Bot;Created+By+SULEIMAN\" alt=\"Typing SVG\" />\n  </a> \n</div> \n\n<div align=\"center\"> \n  <a href=\"https://youtube.com/@mr_unique_hacker\"> \n    <img src=\"https://github.com/mruniquehacker/Knightbot-MD/blob/main/assets/bot_image.jpg\" alt=\"Knight Bot\" height=\"300\"> \n  </a> \n</div>\n\n---\n\n## üöÄ Steps to Deploy\n\n### Step 1: Fork the Repository\n\nClick the button below to fork the Knight Bot repository to your GitHub account:\n\n<div align=\"center\">\n  <a href=\"https://github.com/mruniquehacker/Knightbot-MD/fork\">\n    <img src=\"https://img.shields.io/badge/Fork-Repository-blue?style=for-the-badge\" alt=\"Fork the repository\"/>\n  </a>\n</div>\n\n---\n\n### Step 2: Get Pair Code\n\nDeploy the bot and easily connect it to your WhatsApp account by pair code. Click the button below to deploy the bot on Replit.\n\n<div align=\"center\">\n  <a href=\"https://replit.com/@DGXeon/Xeon-PairCode?v=1\" target=\"_blank\">\n    <img src=\"https://img.shields.io/badge/GET%20PAIR%20CODE-Replit-success?style=for-the-badge\" alt=\"Deploy on Replit\"/>\n  </a>\n</div>\n\n<div align=\"center\">\n  <a href=\"https://knight-bot-paircode.onrender.com\" target=\"_blank\">\n    <img src=\"https://img.shields.io/badge/GET%20PAIR%20CODE-Easy%20Method-ff4d4d?style=for-the-badge\" alt=\"Generate Pair Code\"/>\n  </a>\n</div>\n\n\n### After getting creds.json file, upload it to session folder\n\n---\n\n### Step 3: Deploy Now\n\nFor further customization and setup guidance, click the button below:\n\n<div align=\"center\">\n  <a href=\"https://youtu.be/-oz_u1iMgf8\">\n    <img src=\"https://img.shields.io/badge/Deploy Tutorial-dc3545?style=for-the-badge&logo=youtube\" alt=\"YouTube Link\"/>\n  </a>\n  <a href=\"https://bot-hosting.net/?aff=1068419752923508776\">\n    <img src=\"https://img.shields.io/badge/Deploy on Panel-28a745?style=for-the-badge\" alt=\"Deploy on Panel\"/>\n  </a>\n</div>\n\n\n### Deploy Now on Below Panel\n<div align=\"center\">\n<a href=\"https://dashboard.katabump.com/auth/login#d6b7d6\" target=\"_blank\">\n  <img src=\"https://img.shields.io/badge/Katabump-D6B7D6?style=for-the-badge&logo=server&logoColor=black\" alt=\"Katabump\"/>\n</a>\n</div>\n\n### Join Us\n\n<div align=\"center\">\n  <a href=\"https://t.me/+3QhFUZHx-nhhZmY1\">\n    <img src=\"https://img.shields.io/badge/Join%20Telegram-0078E7?style=for-the-badge&logo=telegram&logoColor=white\" alt=\"Join Telegram\"/>\n  </a>\n  <a href=\"https://whatsapp.com/channel/0029Va90zAnIHphOuO8Msp3A\">\n    <img src=\"https://img.shields.io/badge/Join%20WhatsApp-25D366?style=for-the-badge&logo=whatsapp&logoColor=white\" alt=\"Join WhatsApp\"/>\n  </a>\n</div>\n\n---\n\n## ‚öôÔ∏è Features\n\n- **Tag all group members** with the `.tagall` command\n- **Admin restricted usage** (Only group admins can use certain commands)\n- **Games** like Tic-Tac-Toe for interactive group engagement\n- **Text-to-Speech** with `.tts`\n- **Sticker creation** with `.sticker`\n- **Anti-link detection** for group safety\n- **Warn and manage group members** with admin control\n\n---\n\n## üìñ About\n\nThe Knight WhatsApp Bot assists group admins by providing them with tools to efficiently manage large WhatsApp groups. The bot uses the Baileys library to interact with the WhatsApp Web API and supports multi-device features.\n\nIt is lightweight and can be easily customized to add more commands as per your requirements. The bot runs in a Node.js environment and provides QR code-based authentication to link your WhatsApp account.\n\n---\n\n## üõ†Ô∏è Setup & Installation\n\n### Prerequisites\n\n- Node.js installed on your system\n- Git installed (for cloning the repository)\n\n### Step-by-Step Setup\n\n1. **Clone the repository:**\n\n    ```bash\n    git clone https://github.com/mruniquehacker/Knightbot-MD.git\n    cd Knightbot-MD\n    ```\n\n2. **Install the dependencies:**\n\n    ```bash\n    npm install\n    ```\n\n3. **Run the bot:**\n\n    ```bash\n    node index.js\n    ```\n\n4. **Scan the QR code:**\n\n    Once the bot starts, a QR code will appear in the terminal. Scan this QR code using the Linked Devices feature in WhatsApp to connect your WhatsApp account with the bot.\n\n---\n\n\n## üìÑ License\n\nThis project is licensed under the [MIT License](https://opensource.org/licenses/MIT) - see the [LICENSE](https://github.com/mruniquehacker/Knightbot-MD/blob/main/LICENSE) file for details.\n\n---\n\n## üôå Contributions\n\nContributions, issues, and feature requests are welcome! Feel free to check the [issues page](https://github.com/mruniquehacker/Knightbot-MD/issues).\n\n---\n\n## üåü Show your support\n\nIf you like this project, please give it a [‚≠êÔ∏è star on GitHub](https://github.com/mruniquehacker/Knightbot)!\n\n\n## Credits\n\n- [SULEIMAN](https://github.com/cortexinvader)\n- Original idea by [Mr Unique Hacker](https://github.com/mruniquehacker)\n- [Baileys](https://github.com/adiwajshing/Baileys)\n- [TechGod143](https://github.com/TechGod143) for pair code\n- [Dgxeon](https://github.com/Dgxeon) for pair code\n\n---\n\n## ‚ö†Ô∏è Important Warning\n\n**Note:** This bot is created for educational purposes only. This is NOT an official WhatsApp bot. Using this bot may lead to your WhatsApp account being banned. Use it at your own risk. The developers will not be responsible for any consequences or account bans that may occur while using this bot.\n\n## üìù Legal\n\n- This project is not affiliated with, authorized, maintained, sponsored or endorsed by WhatsApp or any of its affiliates or subsidiaries.\n- This is an independent and unofficial software. Use at your own risk.\n- Do not spam people with this bot.\n- Do not use this bot to send bulk messages or for illegal purposes.\n- The developers assume no liability and are not responsible for any misuse or damage caused by this program.\n\n### License\nThis project is licensed under the MIT License. However, you must:\n- Use this software in compliance with all applicable laws and regulations\n- Include original license and copyright notices\n- Credit original authors\n- Not use for spam or malicious purposes\n\n## üìú Copyright Notice\n\nCopyright (c) 2024 Professor. All rights reserved.\n\nThis project contains code from various open source projects:\n- Baileys (MIT License)\n- Other libraries as listed in package.json\n","size_bytes":6550},"config.js":{"content":"require('dotenv').config();\n\nglobal.APIs = {\n    xteam: 'https://api.xteam.xyz',\n    dzx: 'https://api.dhamzxploit.my.id',\n    lol: 'https://api.lolhuman.xyz',\n    violetics: 'https://violetics.pw',\n    neoxr: 'https://api.neoxr.my.id',\n    zenzapis: 'https://zenzapis.xyz',\n    akuari: 'https://api.akuari.my.id',\n    akuari2: 'https://apimu.my.id',\n    nrtm: 'https://fg-nrtm.ddns.net',\n    bg: 'http://bochil.ddns.net',\n    fgmods: 'https://api-fgmods.ddns.net'\n};\n\nglobal.APIKeys = {\n    'https://api.xteam.xyz': 'd90a9e986e18778b',\n    'https://api.lolhuman.xyz': '85faf717d0545d14074659ad',\n    'https://api.neoxr.my.id': 'yourkey',\n    'https://violetics.pw': 'beta',\n    'https://zenzapis.xyz': 'yourkey',\n    'https://api-fgmods.ddns.net': 'fg-dylux'\n};\n\nmodule.exports = {\n    WARN_COUNT: 3,\n    APIs: global.APIs,\n    APIKeys: global.APIKeys\n};","size_bytes":855},"index.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nrequire('./settings')\nconst { Boom } = require('@hapi/boom')\nconst fs = require('fs')\nconst chalk = require('chalk')\nconst FileType = require('file-type')\nconst path = require('path')\nconst axios = require('axios')\nconst { handleMessages, handleGroupParticipantUpdate, handleStatus } = require('./main');\nconst PhoneNumber = require('awesome-phonenumber')\nconst { imageToWebp, videoToWebp, writeExifImg, writeExifVid } = require('./lib/exif')\nconst { smsg, isUrl, generateMessageTag, getBuffer, getSizeMedia, fetch, await, sleep, reSize } = require('./lib/myfunc')\nconst {\n    default: makeWASocket,\n    useMultiFileAuthState,\n    DisconnectReason,\n    fetchLatestBaileysVersion,\n    generateForwardMessageContent,\n    prepareWAMessageMedia,\n    generateWAMessageFromContent,\n    generateMessageID,\n    downloadContentFromMessage,\n    jidDecode,\n    proto,\n    jidNormalizedUser,\n    makeCacheableSignalKeyStore,\n    delay\n} = require(\"@whiskeysockets/baileys\")\nconst NodeCache = require(\"node-cache\")\n// Using a lightweight persisted store instead of makeInMemoryStore (compat across versions)\nconst pino = require(\"pino\")\nconst readline = require(\"readline\")\nconst { parsePhoneNumber } = require(\"libphonenumber-js\")\nconst { PHONENUMBER_MCC } = require('@whiskeysockets/baileys/lib/Utils/generics')\nconst { rmSync, existsSync } = require('fs')\nconst { join } = require('path')\n// Express web server for deployment\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\n// Store bot connection status\nlet botStatus = {\n    connected: false,\n    user: null,\n    uptime: Date.now(),\n    version: require('./settings').version\n};\n\n// Middleware\napp.use(express.json());\napp.use(express.static('assets'));\n\n// Routes\napp.get('/', (req, res) => {\n    res.json({\n        message: 'Cortex Bot is running!',\n        status: botStatus.connected ? 'Connected' : 'Connecting...',\n        uptime: Date.now() - botStatus.uptime,\n        timestamp: new Date().toLocaleString(),\n        version: botStatus.version,\n        user: botStatus.user ? botStatus.user.name : null\n    });\n});\n\napp.get('/status', (req, res) => {\n    res.json(botStatus);\n});\n\napp.get('/health', (req, res) => {\n    res.json({ status: 'OK', timestamp: new Date().toISOString() });\n});\n\n// Start web server\napp.listen(PORT, '0.0.0.0', () => {\n    console.log(`üåê Cortex Bot server listening on port ${PORT}`);\n    console.log(`üîó Server accessible at: http://localhost:${PORT}`);\n});\n\n// Import lightweight store\nconst store = require('./lib/lightweight_store')\n\n// Initialize store\nstore.readFromFile()\nconst settings = require('./settings')\nsetInterval(() => store.writeToFile(), settings.storeWriteInterval || 10000)\n\n// Memory optimization - Force garbage collection if available\nsetInterval(() => {\n    if (global.gc) {\n        global.gc()\n        console.log('üßπ Garbage collection completed')\n    }\n}, 60_000) // every 1 minute\n\n// Memory monitoring - Restart if RAM gets too high\nsetInterval(() => {\n    const used = process.memoryUsage().rss / 1024 / 1024\n    if (used > 400) {\n        console.log('‚ö†Ô∏è RAM too high (>400MB), restarting bot...')\n        process.exit(1) // Panel will auto-restart\n    }\n}, 30_000) // check every 30 seconds\n\n/*//_________Uptimer____________________\\\\\nconst axios = require('axios');\nfunction getDeployUrl() {\n    const candidates = [\n        process.env.RENDER_EXTERNAL_URL,\n        process.env.HEROKU_APP_URL,\n        process.env.VERCEL_URL,\n        process.env.KATABUMP_URL,\n        process.env.DEPLOY_URL\n    ];\n    let url = candidates.find(v => typeof v === 'string' && v.length > 0);\n    if (url && !/^https?:\\/\\//.test(url)) url = 'https://' + url;\n    return url || null;\n}\nfunction startAutoUptimer() {\n    const url = getDeployUrl();\n    if (!url) {\n        console.warn('[AutoUptimer] No deployment URL env found (RENDER_EXTERNAL_URL, HEROKU_APP_URL, VERCEL_URL, KATABUMP_URL, DEPLOY_URL). Autouptimer disabled.');\n        return;\n    }\n    setInterval(async () => {\n        try {\n            await axios.get(url);\n            console.log(`[AutoUptimer] Pinged ${url} at ${new Date().toLocaleString()}`);\n        } catch (err) {\n            console.error(`[AutoUptimer] Failed to ping ${url}:`, err.message);\n        }\n    }, 15 * 60 * 1000); // 15 minutes\n    console.log(`[AutoUptimer] Started. Will ping: ${url}`);\n}\nstartAutoUptimer();\n//______________________________________\\\\*/\n\nlet phoneNumber = \"911234567890\"\nlet owner = JSON.parse(fs.readFileSync('./data/owner.json'))\n\nglobal.botname = \"CORTEX BOT\"\nglobal.themeemoji = \"‚Ä¢\"\nconst pairingCode = !!phoneNumber || process.argv.includes(\"--pairing-code\")\nconst useMobile = process.argv.includes(\"--mobile\")\n\n// Only create readline interface if we're in an interactive environment\nconst rl = process.stdin.isTTY ? readline.createInterface({ input: process.stdin, output: process.stdout }) : null\nconst question = (text) => {\n    if (rl) {\n        return new Promise((resolve) => rl.question(text, resolve))\n    } else {\n        // In non-interactive environment, use ownerNumber from settings\n        return Promise.resolve(settings.ownerNumber || phoneNumber)\n    }\n}\n\n\nasync function startXeonBotInc() {\n    let { version, isLatest } = await fetchLatestBaileysVersion()\n    const { state, saveCreds } = await useMultiFileAuthState(`./session`)\n    const msgRetryCounterCache = new NodeCache()\n\n    const XeonBotInc = makeWASocket({\n        version,\n        logger: pino({ level: 'silent' }),\n        printQRInTerminal: !pairingCode,\n        browser: [\"Ubuntu\", \"Chrome\", \"20.0.04\"],\n        auth: {\n            creds: state.creds,\n            keys: makeCacheableSignalKeyStore(state.keys, pino({ level: \"fatal\" }).child({ level: \"fatal\" })),\n        },\n        markOnlineOnConnect: true,\n        generateHighQualityLinkPreview: true,\n        syncFullHistory: true,\n        getMessage: async (key) => {\n            let jid = jidNormalizedUser(key.remoteJid)\n            let msg = await store.loadMessage(jid, key.id)\n            return msg?.message || \"\"\n        },\n        msgRetryCounterCache,\n        defaultQueryTimeoutMs: undefined,\n    })\n\n    store.bind(XeonBotInc.ev)\n\n    // Message handling\n    XeonBotInc.ev.on('messages.upsert', async chatUpdate => {\n        try {\n            const mek = chatUpdate.messages[0]\n            if (!mek.message) return\n            mek.message = (Object.keys(mek.message)[0] === 'ephemeralMessage') ? mek.message.ephemeralMessage.message : mek.message\n            if (mek.key && mek.key.remoteJid === 'status@broadcast') {\n                await handleStatus(XeonBotInc, chatUpdate);\n                return;\n            }\n            if (!XeonBotInc.public && !mek.key.fromMe && chatUpdate.type === 'notify') return\n            if (mek.key.id.startsWith('BAE5') && mek.key.id.length === 16) return\n\n            // Clear message retry cache to prevent memory bloat\n            if (XeonBotInc?.msgRetryCounterCache) {\n                XeonBotInc.msgRetryCounterCache.clear()\n            }\n\n            try {\n                await handleMessages(XeonBotInc, chatUpdate, true)\n            } catch (err) {\n                console.error(\"Error in handleMessages:\", err)\n                // Only try to send error message if we have a valid chatId\n                if (mek.key && mek.key.remoteJid) {\n                    await XeonBotInc.sendMessage(mek.key.remoteJid, {\n                        text: '‚ùå An error occurred while processing your message.',\n                        contextInfo: {\n                            forwardingScore: 1,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: '120363161513685998@newsletter',\n                                newsletterName: 'KnightBot MD',\n                                serverMessageId: -1\n                            }\n                        }\n                    }).catch(console.error);\n                }\n            }\n        } catch (err) {\n            console.error(\"Error in messages.upsert:\", err)\n        }\n    })\n\n    // Add these event handlers for better functionality\n    XeonBotInc.decodeJid = (jid) => {\n        if (!jid) return jid\n        if (/:\\d+@/gi.test(jid)) {\n            let decode = jidDecode(jid) || {}\n            return decode.user && decode.server && decode.user + '@' + decode.server || jid\n        } else return jid\n    }\n\n    XeonBotInc.ev.on('contacts.update', update => {\n        for (let contact of update) {\n            let id = XeonBotInc.decodeJid(contact.id)\n            if (store && store.contacts) store.contacts[id] = { id, name: contact.notify }\n        }\n    })\n\n    XeonBotInc.getName = (jid, withoutContact = false) => {\n        id = XeonBotInc.decodeJid(jid)\n        withoutContact = XeonBotInc.withoutContact || withoutContact\n        let v\n        if (id.endsWith(\"@g.us\")) return new Promise(async (resolve) => {\n            v = store.contacts[id] || {}\n            if (!(v.name || v.subject)) v = XeonBotInc.groupMetadata(id) || {}\n            resolve(v.name || v.subject || PhoneNumber('+' + id.replace('@s.whatsapp.net', '')).getNumber('international'))\n        })\n        else v = id === '0@s.whatsapp.net' ? {\n            id,\n            name: 'WhatsApp'\n        } : id === XeonBotInc.decodeJid(XeonBotInc.user.id) ?\n            XeonBotInc.user :\n            (store.contacts[id] || {})\n        return (withoutContact ? '' : v.name) || v.subject || v.verifiedName || PhoneNumber('+' + jid.replace('@s.whatsapp.net', '')).getNumber('international')\n    }\n\n    XeonBotInc.public = true\n\n    XeonBotInc.serializeM = (m) => smsg(XeonBotInc, m, store)\n\n    // Handle pairing code\n    if (pairingCode && !XeonBotInc.authState.creds.registered) {\n        if (useMobile) throw new Error('Cannot use pairing code with mobile api')\n\n        let phoneNumber\n        if (!!global.phoneNumber) {\n            phoneNumber = global.phoneNumber\n        } else {\n            phoneNumber = await question(chalk.bgBlack(chalk.greenBright(`Please type your WhatsApp number üòç\\nFormat: 6281376552730 (without + or spaces) : `)))\n        }\n\n        // Clean the phone number - remove any non-digit characters\n        phoneNumber = phoneNumber.replace(/[^0-9]/g, '')\n\n        // Validate the phone number using awesome-phonenumber\n        const pn = require('awesome-phonenumber');\n        if (!pn('+' + phoneNumber).isValid()) {\n            console.log(chalk.red('Invalid phone number. Please enter your full international number (e.g., 15551234567 for US, 447911123456 for UK, etc.) without + or spaces.'));\n            process.exit(1);\n        }\n\n        setTimeout(async () => {\n            try {\n                let code = await XeonBotInc.requestPairingCode(phoneNumber)\n                code = code?.match(/.{1,4}/g)?.join(\"-\") || code\n                console.log(chalk.black(chalk.bgGreen(`Your Pairing Code : `)), chalk.black(chalk.white(code)))\n                console.log(chalk.yellow(`\\nPlease enter this code in your WhatsApp app:\\n1. Open WhatsApp\\n2. Go to Settings > Linked Devices\\n3. Tap \"Link a Device\"\\n4. Enter the code shown above`))\n            } catch (error) {\n                console.error('Error requesting pairing code:', error)\n                console.log(chalk.red('Failed to get pairing code. Please check your phone number and try again.'))\n            }\n        }, 3000)\n    }\n\n    // Connection handling\n    XeonBotInc.ev.on('connection.update', async (s) => {\n        const { connection, lastDisconnect } = s\n        if (connection == \"open\") {\n            console.log(chalk.magenta(` `))\n            console.log(chalk.yellow(`üåøConnected to => ` + JSON.stringify(XeonBotInc.user, null, 2)))\n\n            // Update bot status\n            botStatus.connected = true;\n            botStatus.user = XeonBotInc.user;\n\n            const botNumber = XeonBotInc.user.id.split(':')[0] + '@s.whatsapp.net';\n            await XeonBotInc.sendMessage(botNumber, {\n                text: `ü§ñ Cortex Bot Connected Successfully!\\n\\n‚è∞ Time: ${new Date().toLocaleString()}\\n‚úÖ Status: Online and Ready!\\n\\nüîß Created by: SULEIMAN`\n            });\n\n            await delay(1999)\n            console.log(chalk.yellow(`\\n\\n                  ${chalk.bold.blue(`[ ${global.botname || 'CORTEX BOT'} ]`)}\\n\\n`))\n            console.log(chalk.cyan(`< ================================================== >`))\n            console.log(chalk.magenta(`\\n${global.themeemoji || '‚Ä¢'} GITHUB: cortexinvader`))\n            console.log(chalk.magenta(`${global.themeemoji || '‚Ä¢'} WA NUMBER: ${owner}`))\n            console.log(chalk.magenta(`${global.themeemoji || '‚Ä¢'} CREATOR: SULEIMAN`))\n            console.log(chalk.green(`${global.themeemoji || '‚Ä¢'} ü§ñ Cortex Bot Connected Successfully! ‚úÖ`))\n            console.log(chalk.blue(`Bot Version: ${settings.version}`))\n        }\n        if (connection === 'close') {\n            const statusCode = lastDisconnect?.error?.output?.statusCode\n            if (statusCode === DisconnectReason.loggedOut || statusCode === 401) {\n                try {\n                    rmSync('./session', { recursive: true, force: true })\n                } catch { }\n                console.log(chalk.red('Session logged out. Please re-authenticate.'))\n                startXeonBotInc()\n            } else {\n                startXeonBotInc()\n            }\n        }\n    })\n\n    // Track recently-notified callers to avoid spamming messages\n    const antiCallNotified = new Set();\n\n    // Anticall handler: block callers when enabled\n    XeonBotInc.ev.on('call', async (calls) => {\n        try {\n            const { readState: readAnticallState } = require('./commands/anticall');\n            const state = readAnticallState();\n            if (!state.enabled) return;\n            for (const call of calls) {\n                const callerJid = call.from || call.peerJid || call.chatId;\n                if (!callerJid) continue;\n                try {\n                    // First: attempt to reject the call if supported\n                    try {\n                        if (typeof XeonBotInc.rejectCall === 'function' && call.id) {\n                            await XeonBotInc.rejectCall(call.id, callerJid);\n                        } else if (typeof XeonBotInc.sendCallOfferAck === 'function' && call.id) {\n                            await XeonBotInc.sendCallOfferAck(call.id, callerJid, 'reject');\n                        }\n                    } catch {}\n\n                    // Notify the caller only once within a short window\n                    if (!antiCallNotified.has(callerJid)) {\n                        antiCallNotified.add(callerJid);\n                        setTimeout(() => antiCallNotified.delete(callerJid), 60000);\n                        await XeonBotInc.sendMessage(callerJid, { text: 'üìµ Anticall is enabled. Your call was rejected and you will be blocked.' });\n                    }\n                } catch {}\n                // Then: block after a short delay to ensure rejection and message are processed\n                setTimeout(async () => {\n                    try { await XeonBotInc.updateBlockStatus(callerJid, 'block'); } catch {}\n                }, 800);\n            }\n        } catch (e) {\n            // ignore\n        }\n    });\n\n    XeonBotInc.ev.on('creds.update', saveCreds)\n\n    XeonBotInc.ev.on('group-participants.update', async (update) => {\n        await handleGroupParticipantUpdate(XeonBotInc, update);\n    });\n\n    XeonBotInc.ev.on('messages.upsert', async (m) => {\n        if (m.messages[0].key && m.messages[0].key.remoteJid === 'status@broadcast') {\n            await handleStatus(XeonBotInc, m);\n        }\n    });\n\n    XeonBotInc.ev.on('status.update', async (status) => {\n        await handleStatus(XeonBotInc, status);\n    });\n\n    XeonBotInc.ev.on('messages.reaction', async (status) => {\n        await handleStatus(XeonBotInc, status);\n    });\n\n    return XeonBotInc\n}\n\n\n// Start the bot with error handling\nstartXeonBotInc().catch(error => {\n    console.error('Fatal error:', error)\n    process.exit(1)\n})\nprocess.on('uncaughtException', (err) => {\n    console.error('Uncaught Exception:', err)\n})\n\nprocess.on('unhandledRejection', (err) => {\n    console.error('Unhandled Rejection:', err)\n})\n\nlet file = require.resolve(__filename)\nfs.watchFile(file, () => {\n    fs.unwatchFile(file)\n    console.log(chalk.redBright(`Update ${__filename}`))\n    delete require.cache[file]\n    require(file)\n})\n","size_bytes":16848},"main.js":{"content":"const settings = require('./settings');\nrequire('./config.js');\nconst { isBanned } = require('./lib/isBanned');\nconst yts = require('yt-search');\nconst { fetchBuffer } = require('./lib/myfunc');\nconst fs = require('fs');\nconst fetch = require('node-fetch');\nconst ytdl = require('ytdl-core');\nconst path = require('path');\nconst axios = require('axios');\nconst ffmpeg = require('fluent-ffmpeg');\nconst { addWelcome, delWelcome, isWelcomeOn, addGoodbye, delGoodBye, isGoodByeOn, isSudo } = require('./lib/index');\nconst isOwnerOrSudo = require('./lib/isOwner');\nconst { autotypingCommand, isAutotypingEnabled, handleAutotypingForMessage, handleAutotypingForCommand, showTypingAfterCommand } = require('./commands/autotyping');\nconst { autoreadCommand, isAutoreadEnabled, handleAutoread } = require('./commands/autoread');\n\n// Command imports\nconst tagAllCommand = require('./commands/tagall');\nconst cmdCommand = require('./commands/cmd');\nconst helpCommand = require('./commands/help');\nconst banCommand = require('./commands/ban');\nconst { promoteCommand } = require('./commands/promote');\nconst { demoteCommand } = require('./commands/demote');\nconst muteCommand = require('./commands/mute');\nconst unmuteCommand = require('./commands/unmute');\nconst stickerCommand = require('./commands/sticker');\nconst isAdmin = require('./lib/isAdmin');\nconst warnCommand = require('./commands/warn');\nconst warningsCommand = require('./commands/warnings');\nconst ttsCommand = require('./commands/tts');\nconst { tictactoeCommand, handleTicTacToeMove } = require('./commands/tictactoe');\nconst { incrementMessageCount, topMembers } = require('./commands/topmembers');\nconst ownerCommand = require('./commands/owner');\nconst deleteCommand = require('./commands/delete');\nconst { handleAntilinkCommand, handleLinkDetection } = require('./commands/antilink');\nconst { handleAntitagCommand, handleTagDetection } = require('./commands/antitag');\nconst { Antilink } = require('./lib/antilink');\nconst memeCommand = require('./commands/meme');\nconst tagCommand = require('./commands/tag');\nconst jokeCommand = require('./commands/joke');\nconst quoteCommand = require('./commands/quote');\nconst factCommand = require('./commands/fact');\nconst weatherCommand = require('./commands/weather');\nconst newsCommand = require('./commands/news');\nconst kickCommand = require('./commands/kick');\nconst simageCommand = require('./commands/simage');\nconst attpCommand = require('./commands/attp');\nconst { startHangman, guessLetter } = require('./commands/hangman');\nconst { startTrivia, answerTrivia } = require('./commands/trivia');\nconst { complimentCommand } = require('./commands/compliment');\nconst { insultCommand } = require('./commands/insult');\nconst { eightBallCommand } = require('./commands/eightball');\nconst { lyricsCommand } = require('./commands/lyrics');\nconst { dareCommand } = require('./commands/dare');\nconst { truthCommand } = require('./commands/truth');\nconst { clearCommand } = require('./commands/clear');\nconst pingCommand = require('./commands/ping');\nconst aliveCommand = require('./commands/alive');\nconst blurCommand = require('./commands/img-blur');\nconst welcomeCommand = require('./commands/welcome');\nconst goodbyeCommand = require('./commands/goodbye');\nconst githubCommand = require('./commands/github');\nconst { handleAntiBadwordCommand, handleBadwordDetection } = require('./lib/antibadword');\nconst antibadwordCommand = require('./commands/antibadword');\nconst { handleChatbotCommand, handleChatbotResponse } = require('./commands/chatbot');\nconst takeCommand = require('./commands/take');\nconst { flirtCommand } = require('./commands/flirt');\nconst characterCommand = require('./commands/character');\nconst wastedCommand = require('./commands/wasted');\nconst shipCommand = require('./commands/ship');\nconst groupInfoCommand = require('./commands/groupinfo');\nconst resetlinkCommand = require('./commands/resetlink');\nconst staffCommand = require('./commands/staff');\nconst unbanCommand = require('./commands/unban');\nconst emojimixCommand = require('./commands/emojimix');\nconst { handlePromotionEvent } = require('./commands/promote');\nconst { handleDemotionEvent } = require('./commands/demote');\nconst viewOnceCommand = require('./commands/viewonce');\nconst clearSessionCommand = require('./commands/clearsession');\nconst { autoStatusCommand, handleStatusUpdate } = require('./commands/autostatus');\nconst { simpCommand } = require('./commands/simp');\nconst { stupidCommand } = require('./commands/stupid');\nconst stickerTelegramCommand = require('./commands/stickertelegram');\nconst textmakerCommand = require('./commands/textmaker');\nconst { handleAntideleteCommand, handleMessageRevocation, storeMessage } = require('./commands/antidelete');\nconst clearTmpCommand = require('./commands/cleartmp');\nconst setProfilePicture = require('./commands/setpp');\nconst { setGroupDescription, setGroupName, setGroupPhoto } = require('./commands/groupmanage');\nconst instagramCommand = require('./commands/instagram');\nconst facebookCommand = require('./commands/facebook');\nconst playCommand = require('./commands/play');\nconst tiktokCommand = require('./commands/tiktok');\nconst songCommand = require('./commands/song');\nconst aiCommand = require('./commands/ai');\nconst { handleTranslateCommand } = require('./commands/translate');\nconst { handleSsCommand } = require('./commands/ss');\nconst { addCommandReaction, handleAreactCommand } = require('./lib/reactions');\nconst { goodnightCommand } = require('./commands/goodnight');\nconst { shayariCommand } = require('./commands/shayari');\nconst { rosedayCommand } = require('./commands/roseday');\nconst imagineCommand = require('./commands/imagine');\nconst videoCommand = require('./commands/video');\nconst sudoCommand = require('./commands/sudo');\nconst { miscCommand, handleHeart } = require('./commands/misc');\nconst { animeCommand } = require('./commands/anime');\nconst { piesCommand, piesAlias } = require('./commands/pies');\nconst stickercropCommand = require('./commands/stickercrop');\nconst updateCommand = require('./commands/update');\nconst removebgCommand = require('./commands/removebg');\nconst { reminiCommand } = require('./commands/remini');\nconst { igsCommand } = require('./commands/igs');\nconst { anticallCommand, readState: readAnticallState } = require('./commands/anticall');\nconst { pmblockerCommand, readState: readPmBlockerState } = require('./commands/pmblocker');\nconst settingsCommand = require('./commands/settings');\n\n// Global settings\nglobal.packname = settings.packname;\nglobal.author = settings.author;\nglobal.channelLink = \"\";\nglobal.ytch = \"\";\n\n// Simplified channel info without newsletter references\nconst channelInfo = {};\n\nasync function handleMessages(sock, messageUpdate, printLog) {\n    try {\n        const { messages, type } = messageUpdate;\n        if (type !== 'notify') return;\n\n        const message = messages[0];\n        if (!message?.message) return;\n\n        // Handle autoread functionality\n        await handleAutoread(sock, message);\n\n        // Store message for antidelete feature\n        if (message.message) {\n            storeMessage(message);\n        }\n\n        // Handle message revocation\n        if (message.message?.protocolMessage?.type === 0) {\n            await handleMessageRevocation(sock, message);\n            return;\n        }\n\n        const chatId = message.key.remoteJid;\n        const senderId = message.key.participant || message.key.remoteJid;\n        const isGroup = chatId.endsWith('@g.us');\n        const senderIsSudo = await isSudo(senderId);\n        const senderIsOwnerOrSudo = await isOwnerOrSudo(senderId);\n\n        const userMessage = (\n            message.message?.conversation?.trim() ||\n            message.message?.extendedTextMessage?.text?.trim() ||\n            message.message?.imageMessage?.caption?.trim() ||\n            message.message?.videoMessage?.caption?.trim() ||\n            ''\n        ).toLowerCase().replace(/\\.\\s+/g, '.').trim();\n\n        // Preserve raw message for commands like .tag that need original casing\n        const rawText = message.message?.conversation?.trim() ||\n            message.message?.extendedTextMessage?.text?.trim() ||\n            message.message?.imageMessage?.caption?.trim() ||\n            message.message?.videoMessage?.caption?.trim() ||\n            '';\n\n        // Only log command usage\n        if (userMessage.startsWith('.')) {\n            console.log(`üìù Command used in ${isGroup ? 'group' : 'private'}: ${userMessage}`);\n        }\n        // Enforce private mode BEFORE any replies (except owner/sudo)\n        try {\n            const data = JSON.parse(fs.readFileSync('./data/messageCount.json'));\n            // Allow owner/sudo to use bot even in private mode\n            if (!data.isPublic && !message.key.fromMe && !senderIsOwnerOrSudo) {\n                return; // Silently ignore messages from non-owners when in private mode\n            }\n        } catch (error) {\n            console.error('Error checking access mode:', error);\n            // Default to public mode if there's an error reading the file\n        }\n        // Check if user is banned (skip ban check for unban command)\n        if (isBanned(senderId) && !userMessage.startsWith('.unban')) {\n            // Only respond occasionally to avoid spam\n            if (Math.random() < 0.1) {\n                await sock.sendMessage(chatId, {\n                    text: '‚ùå You are banned from using the bot. Contact an admin to get unbanned.',\n                    ...channelInfo\n                });\n            }\n            return;\n        }\n\n        // First check if it's a game move\n        if (/^[1-9]$/.test(userMessage) || userMessage.toLowerCase() === 'surrender') {\n            await handleTicTacToeMove(sock, chatId, senderId, userMessage);\n            return;\n        }\n\n        /*  // Basic message response in private chat\n          if (!isGroup && (userMessage === 'hi' || userMessage === 'hello' || userMessage === 'bot' || userMessage === 'hlo' || userMessage === 'hey' || userMessage === 'bro')) {\n              await sock.sendMessage(chatId, {\n                  text: 'Hi, How can I help you?\\nYou can use .menu for more info and commands.',\n                  ...channelInfo\n              });\n              return;\n          } */\n\n        if (!message.key.fromMe) incrementMessageCount(chatId, senderId);\n\n        // Check for bad words FIRST, before ANY other processing\n        if (isGroup && userMessage) {\n            await handleBadwordDetection(sock, chatId, message, userMessage, senderId);\n        }\n\n        // PM blocker: block non-owner DMs when enabled (do not ban)\n        if (!isGroup && !message.key.fromMe && !senderIsSudo) {\n            try {\n                const pmState = readPmBlockerState();\n                if (pmState.enabled) {\n                    // Inform user, delay, then block without banning globally\n                    await sock.sendMessage(chatId, { text: pmState.message || 'Private messages are blocked. Please contact the owner in groups only.' });\n                    await new Promise(r => setTimeout(r, 1500));\n                    try { await sock.updateBlockStatus(chatId, 'block'); } catch (e) { }\n                    return;\n                }\n            } catch (e) { }\n        }\n\n        // Then check for command prefix\n        if (!userMessage.startsWith('.')) {\n            // Show typing indicator if autotyping is enabled\n            await handleAutotypingForMessage(sock, chatId, userMessage);\n\n            if (isGroup) {\n                // Process non-command messages first\n                await handleChatbotResponse(sock, chatId, message, userMessage, senderId);\n                await Antilink(message, sock);\n                await handleBadwordDetection(sock, chatId, message, userMessage, senderId);\n                await handleTagDetection(sock, chatId, message, senderId);\n            }\n            return;\n        }\n\n        // List of admin commands\n        const adminCommands = ['.mute', '.unmute', '.ban', '.unban', '.promote', '.demote', '.kick', '.tagall', '.antilink', '.antitag', '.setgdesc', '.setgname', '.setgpp'];\n        const isAdminCommand = adminCommands.some(cmd => userMessage.startsWith(cmd));\n\n        // List of owner commands\n        const ownerCommands = ['.mode', '.autostatus', '.antidelete', '.cleartmp', '.setpp', '.clearsession', '.areact', '.autoreact', '.autotyping', '.autoread', '.pmblocker','.cmd'];\n        const isOwnerCommand = ownerCommands.some(cmd => userMessage.startsWith(cmd));\n\n        let isSenderAdmin = false;\n        let isBotAdmin = false;\n\n        // Check admin status only for admin commands in groups\n        if (isGroup && isAdminCommand) {\n            const adminStatus = await isAdmin(sock, chatId, senderId, message);\n            isSenderAdmin = adminStatus.isSenderAdmin;\n            isBotAdmin = adminStatus.isBotAdmin;\n\n            if (!isBotAdmin) {\n                await sock.sendMessage(chatId, { text: 'Please make the bot an admin to use admin commands.', ...channelInfo }, { quoted: message });\n                return;\n            }\n\n            if (\n                userMessage.startsWith('.mute') ||\n                userMessage === '.unmute' ||\n                userMessage.startsWith('.ban') ||\n                userMessage.startsWith('.unban') ||\n                userMessage.startsWith('.promote') ||\n                userMessage.startsWith('.demote')\n            ) {\n                if (!isSenderAdmin && !message.key.fromMe) {\n                    await sock.sendMessage(chatId, {\n                        text: 'Sorry, only group admins can use this command.',\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n            }\n        }\n\n        // Check owner status for owner commands\n        if (isOwnerCommand) {\n            if (!message.key.fromMe && !senderIsOwnerOrSudo) {\n                await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo!' }, { quoted: message });\n                return;\n            }\n        }\n\n        // Command handlers - Execute commands immediately without waiting for typing indicator\n        // We'll show typing indicator after command execution if needed\n        let commandExecuted = false;\n\n        switch (true) {\n            case userMessage === '.simage': {\n                const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n                if (quotedMessage?.stickerMessage) {\n                    await simageCommand(sock, quotedMessage, chatId);\n                } else {\n                    await sock.sendMessage(chatId, { text: 'Please reply to a sticker with the .simage command to convert it.', ...channelInfo }, { quoted: message });\n                }\n                commandExecuted = true;\n                break;\n            }\n            case userMessage.startsWith('.kick'):\n                const mentionedJidListKick = message.message.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                await kickCommand(sock, chatId, senderId, mentionedJidListKick, message);\n                break;\n            case userMessage.startsWith('.mute'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const muteArg = parts[1];\n                    const muteDuration = muteArg !== undefined ? parseInt(muteArg, 10) : undefined;\n                    if (muteArg !== undefined && (isNaN(muteDuration) || muteDuration <= 0)) {\n                        await sock.sendMessage(chatId, { text: 'Please provide a valid number of minutes or use .mute with no number to mute immediately.', ...channelInfo }, { quoted: message });\n                    } else {\n                        await muteCommand(sock, chatId, senderId, message, muteDuration);\n                    }\n                }\n                break;\n            case userMessage.startsWith('.cmd'):\n               await cmdCommand(sock, chatId, message);\n               break;\n            case userMessage === '.unmute':\n                await unmuteCommand(sock, chatId, senderId);\n                break;\n            case userMessage.startsWith('.ban'):\n                await banCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.unban'):\n                await unbanCommand(sock, chatId, message);\n                break;\n            case userMessage === '.help' || userMessage === '.menu' || userMessage === '.bot' || userMessage === '.list':\n                await helpCommand(sock, chatId, message, global.channelLink);\n                commandExecuted = true;\n                break;\n            case userMessage === '.sticker' || userMessage === '.s':\n                await stickerCommand(sock, chatId, message);\n                commandExecuted = true;\n                break;\n            case userMessage.startsWith('.warnings'):\n                const mentionedJidListWarnings = message.message.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                await warningsCommand(sock, chatId, mentionedJidListWarnings);\n                break;\n            case userMessage.startsWith('.warn'):\n                const mentionedJidListWarn = message.message.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                await warnCommand(sock, chatId, senderId, mentionedJidListWarn, message);\n                break;\n            case userMessage.startsWith('.tts'):\n                const text = userMessage.slice(4).trim();\n                await ttsCommand(sock, chatId, text, message);\n                break;\n            case userMessage.startsWith('.delete') || userMessage.startsWith('.del'):\n                await deleteCommand(sock, chatId, message, senderId);\n                break;\n            case userMessage.startsWith('.attp'):\n                await attpCommand(sock, chatId, message);\n                break;\n           \n            case userMessage === '.settings':\n                await settingsCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.mode'):\n                // Check if sender is the owner\n                if (!message.key.fromMe && !senderIsOwnerOrSudo) {\n                    await sock.sendMessage(chatId, { text: 'Only bot owner can use this command!', ...channelInfo }, { quoted: message });\n                    return;\n                }\n                // Read current data first\n                let data;\n                try {\n                    data = JSON.parse(fs.readFileSync('./data/messageCount.json'));\n                } catch (error) {\n                    console.error('Error reading access mode:', error);\n                    await sock.sendMessage(chatId, { text: 'Failed to read bot mode status', ...channelInfo });\n                    return;\n                }\n\n                const action = userMessage.split(' ')[1]?.toLowerCase();\n                // If no argument provided, show current status\n                if (!action) {\n                    const currentMode = data.isPublic ? 'public' : 'private';\n                    await sock.sendMessage(chatId, {\n                        text: `Current bot mode: *${currentMode}*\\n\\nUsage: .mode public/private\\n\\nExample:\\n.mode public - Allow everyone to use bot\\n.mode private - Restrict to owner only`,\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n\n                if (action !== 'public' && action !== 'private') {\n                    await sock.sendMessage(chatId, {\n                        text: 'Usage: .mode public/private\\n\\nExample:\\n.mode public - Allow everyone to use bot\\n.mode private - Restrict to owner only',\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n\n                try {\n                    // Update access mode\n                    data.isPublic = action === 'public';\n\n                    // Save updated data\n                    fs.writeFileSync('./data/messageCount.json', JSON.stringify(data, null, 2));\n\n                    await sock.sendMessage(chatId, { text: `Bot is now in *${action}* mode`, ...channelInfo });\n                } catch (error) {\n                    console.error('Error updating access mode:', error);\n                    await sock.sendMessage(chatId, { text: 'Failed to update bot access mode', ...channelInfo });\n                }\n                break;\n            case userMessage.startsWith('.anticall'):\n                if (!message.key.fromMe && !senderIsSudo) {\n                    await sock.sendMessage(chatId, { text: 'Only owner/sudo can use anticall.' }, { quoted: message });\n                    break;\n                }\n                {\n                    const args = userMessage.split(' ').slice(1).join(' ');\n                    await anticallCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.pmblocker'):\n                if (!message.key.fromMe && !senderIsSudo) {\n                    await sock.sendMessage(chatId, { text: 'Only owner/sudo can use pmblocker.' }, { quoted: message });\n                    commandExecuted = true;\n                    break;\n                }\n                {\n                    const args = userMessage.split(' ').slice(1).join(' ');\n                    await pmblockerCommand(sock, chatId, message, args);\n                }\n                commandExecuted = true;\n                break;\n            case userMessage === '.owner':\n                await ownerCommand(sock, chatId);\n                break;\n            case userMessage === '.tagall':\n                if (isSenderAdmin || message.key.fromMe) {\n                    await tagAllCommand(sock, chatId, senderId, message);\n                } else {\n                    await sock.sendMessage(chatId, { text: 'Sorry, only group admins can use the .tagall command.', ...channelInfo }, { quoted: message });\n                }\n                break;\n            case userMessage.startsWith('.tag'):\n                const messageText = rawText.slice(4).trim();  // use rawText here, not userMessage\n                const replyMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage || null;\n                await tagCommand(sock, chatId, senderId, messageText, replyMessage);\n                break;\n            case userMessage.startsWith('.antilink'):\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, {\n                        text: 'This command can only be used in groups.',\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n                if (!isBotAdmin) {\n                    await sock.sendMessage(chatId, {\n                        text: 'Please make the bot an admin first.',\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n                await handleAntilinkCommand(sock, chatId, userMessage, senderId, isSenderAdmin, message);\n                break;\n            case userMessage.startsWith('.antitag'):\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, {\n                        text: 'This command can only be used in groups.',\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n                if (!isBotAdmin) {\n                    await sock.sendMessage(chatId, {\n                        text: 'Please make the bot an admin first.',\n                        ...channelInfo\n                    }, { quoted: message });\n                    return;\n                }\n                await handleAntitagCommand(sock, chatId, userMessage, senderId, isSenderAdmin, message);\n                break;\n            case userMessage === '.meme':\n                await memeCommand(sock, chatId, message);\n                break;\n            case userMessage === '.joke':\n                await jokeCommand(sock, chatId, message);\n                break;\n            case userMessage === '.quote':\n                await quoteCommand(sock, chatId, message);\n                break;\n            case userMessage === '.fact':\n                await factCommand(sock, chatId, message, message);\n                break;\n            case userMessage.startsWith('.weather'):\n                const city = userMessage.slice(9).trim();\n                if (city) {\n                    await weatherCommand(sock, chatId, message, city);\n                } else {\n                    await sock.sendMessage(chatId, { text: 'Please specify a city, e.g., .weather London', ...channelInfo }, { quoted: message });\n                }\n                break;\n            case userMessage === '.news':\n                await newsCommand(sock, chatId);\n                break;\n            case userMessage.startsWith('.ttt') || userMessage.startsWith('.tictactoe'):\n                const tttText = userMessage.split(' ').slice(1).join(' ');\n                await tictactoeCommand(sock, chatId, senderId, tttText);\n                break;\n            case userMessage.startsWith('.move'):\n                const position = parseInt(userMessage.split(' ')[1]);\n                if (isNaN(position)) {\n                    await sock.sendMessage(chatId, { text: 'Please provide a valid position number for Tic-Tac-Toe move.', ...channelInfo }, { quoted: message });\n                } else {\n                    tictactoeMove(sock, chatId, senderId, position);\n                }\n                break;\n            case userMessage === '.topmembers':\n                topMembers(sock, chatId, isGroup);\n                break;\n            case userMessage.startsWith('.hangman'):\n                startHangman(sock, chatId);\n                break;\n            case userMessage.startsWith('.guess'):\n                const guessedLetter = userMessage.split(' ')[1];\n                if (guessedLetter) {\n                    guessLetter(sock, chatId, guessedLetter);\n                } else {\n                    sock.sendMessage(chatId, { text: 'Please guess a letter using .guess <letter>', ...channelInfo }, { quoted: message });\n                }\n                break;\n            case userMessage.startsWith('.trivia'):\n                startTrivia(sock, chatId);\n                break;\n            case userMessage.startsWith('.answer'):\n                const answer = userMessage.split(' ').slice(1).join(' ');\n                if (answer) {\n                    answerTrivia(sock, chatId, answer);\n                } else {\n                    sock.sendMessage(chatId, { text: 'Please provide an answer using .answer <answer>', ...channelInfo }, { quoted: message });\n                }\n                break;\n            case userMessage.startsWith('.compliment'):\n                await complimentCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.insult'):\n                await insultCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.8ball'):\n                const question = userMessage.split(' ').slice(1).join(' ');\n                await eightBallCommand(sock, chatId, question);\n                break;\n            case userMessage.startsWith('.lyrics'):\n                const songTitle = userMessage.split(' ').slice(1).join(' ');\n                await lyricsCommand(sock, chatId, songTitle, message);\n                break;\n            case userMessage.startsWith('.simp'):\n                const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n                const mentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                await simpCommand(sock, chatId, quotedMsg, mentionedJid, senderId);\n                break;\n            case userMessage.startsWith('.stupid') || userMessage.startsWith('.itssostupid') || userMessage.startsWith('.iss'):\n                const stupidQuotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n                const stupidMentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                const stupidArgs = userMessage.split(' ').slice(1);\n                await stupidCommand(sock, chatId, stupidQuotedMsg, stupidMentionedJid, senderId, stupidArgs);\n                break;\n            case userMessage === '.dare':\n                await dareCommand(sock, chatId, message);\n                break;\n            case userMessage === '.truth':\n                await truthCommand(sock, chatId, message);\n                break;\n            case userMessage === '.clear':\n                if (isGroup) await clearCommand(sock, chatId);\n                break;\n            case userMessage.startsWith('.promote'):\n                const mentionedJidListPromote = message.message.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                await promoteCommand(sock, chatId, mentionedJidListPromote, message);\n                break;\n            case userMessage.startsWith('.demote'):\n                const mentionedJidListDemote = message.message.extendedTextMessage?.contextInfo?.mentionedJid || [];\n                await demoteCommand(sock, chatId, mentionedJidListDemote, message);\n                break;\n            case userMessage === '.ping':\n                await pingCommand(sock, chatId, message);\n                break;\n            case userMessage === '.alive':\n                await aliveCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.blur'):\n                const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n                await blurCommand(sock, chatId, message, quotedMessage);\n                break;\n            case userMessage.startsWith('.welcome'):\n                if (isGroup) {\n                    // Check admin status if not already checked\n                    if (!isSenderAdmin) {\n                        const adminStatus = await isAdmin(sock, chatId, senderId);\n                        isSenderAdmin = adminStatus.isSenderAdmin;\n                    }\n\n                    if (isSenderAdmin || message.key.fromMe) {\n                        await welcomeCommand(sock, chatId, message);\n                    } else {\n                        await sock.sendMessage(chatId, { text: 'Sorry, only group admins can use this command.', ...channelInfo }, { quoted: message });\n                    }\n                } else {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups.', ...channelInfo }, { quoted: message });\n                }\n                break;\n            case userMessage.startsWith('.goodbye'):\n                if (isGroup) {\n                    // Check admin status if not already checked\n                    if (!isSenderAdmin) {\n                        const adminStatus = await isAdmin(sock, chatId, senderId);\n                        isSenderAdmin = adminStatus.isSenderAdmin;\n                    }\n\n                    if (isSenderAdmin || message.key.fromMe) {\n                        await goodbyeCommand(sock, chatId, message);\n                    } else {\n                        await sock.sendMessage(chatId, { text: 'Sorry, only group admins can use this command.', ...channelInfo }, { quoted: message });\n                    }\n                } else {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups.', ...channelInfo }, { quoted: message });\n                }\n                break;\n            case userMessage === '.git':\n            case userMessage === '.github':\n            case userMessage === '.sc':\n            case userMessage === '.script':\n            case userMessage === '.repo':\n                await githubCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.antibadword'):\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups.', ...channelInfo }, { quoted: message });\n                    return;\n                }\n\n                const adminStatus = await isAdmin(sock, chatId, senderId);\n                isSenderAdmin = adminStatus.isSenderAdmin;\n                isBotAdmin = adminStatus.isBotAdmin;\n\n                if (!isBotAdmin) {\n                    await sock.sendMessage(chatId, { text: '*Bot must be admin to use this feature*', ...channelInfo }, { quoted: message });\n                    return;\n                }\n\n                await antibadwordCommand(sock, chatId, message, senderId, isSenderAdmin);\n                break;\n            case userMessage.startsWith('.chatbot'):\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups.', ...channelInfo }, { quoted: message });\n                    return;\n                }\n\n                // Check if sender is admin or bot owner\n                const chatbotAdminStatus = await isAdmin(sock, chatId, senderId);\n                if (!chatbotAdminStatus.isSenderAdmin && !message.key.fromMe) {\n                    await sock.sendMessage(chatId, { text: '*Only admins or bot owner can use this command*', ...channelInfo }, { quoted: message });\n                    return;\n                }\n\n                const match = userMessage.slice(8).trim();\n                await handleChatbotCommand(sock, chatId, message, match);\n                break;\n            case userMessage.startsWith('.take'):\n                const takeArgs = rawText.slice(5).trim().split(' ');\n                await takeCommand(sock, chatId, message, takeArgs);\n                break;\n            case userMessage === '.flirt':\n                await flirtCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.character'):\n                await characterCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.waste'):\n                await wastedCommand(sock, chatId, message);\n                break;\n            case userMessage === '.ship':\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups!', ...channelInfo }, { quoted: message });\n                    return;\n                }\n                await shipCommand(sock, chatId, message);\n                break;\n            case userMessage === '.groupinfo' || userMessage === '.infogp' || userMessage === '.infogrupo':\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups!', ...channelInfo }, { quoted: message });\n                    return;\n                }\n                await groupInfoCommand(sock, chatId, message);\n                break;\n            case userMessage === '.resetlink' || userMessage === '.revoke' || userMessage === '.anularlink':\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups!', ...channelInfo }, { quoted: message });\n                    return;\n                }\n                await resetlinkCommand(sock, chatId, senderId);\n                break;\n            case userMessage === '.staff' || userMessage === '.admins' || userMessage === '.listadmin':\n                if (!isGroup) {\n                    await sock.sendMessage(chatId, { text: 'This command can only be used in groups!', ...channelInfo }, { quoted: message });\n                    return;\n                }\n                await staffCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.emojimix') || userMessage.startsWith('.emix'):\n                await emojimixCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.tg') || userMessage.startsWith('.stickertelegram') || userMessage.startsWith('.tgsticker') || userMessage.startsWith('.telesticker'):\n                await stickerTelegramCommand(sock, chatId, message);\n                break;\n\n            case userMessage === '.vv':\n                await viewOnceCommand(sock, chatId, message);\n                break;\n            case userMessage === '.clearsession' || userMessage === '.clearsesi':\n                await clearSessionCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.autostatus'):\n                const autoStatusArgs = userMessage.split(' ').slice(1);\n                await autoStatusCommand(sock, chatId, message, autoStatusArgs);\n                break;\n            case userMessage.startsWith('.simp'):\n                await simpCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.metallic'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'metallic');\n                break;\n            case userMessage.startsWith('.ice'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'ice');\n                break;\n            case userMessage.startsWith('.snow'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'snow');\n                break;\n            case userMessage.startsWith('.impressive'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'impressive');\n                break;\n            case userMessage.startsWith('.matrix'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'matrix');\n                break;\n            case userMessage.startsWith('.light'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'light');\n                break;\n            case userMessage.startsWith('.neon'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'neon');\n                break;\n            case userMessage.startsWith('.devil'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'devil');\n                break;\n            case userMessage.startsWith('.purple'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'purple');\n                break;\n            case userMessage.startsWith('.thunder'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'thunder');\n                break;\n            case userMessage.startsWith('.leaves'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'leaves');\n                break;\n            case userMessage.startsWith('.1917'):\n                await textmakerCommand(sock, chatId, message, userMessage, '1917');\n                break;\n            case userMessage.startsWith('.arena'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'arena');\n                break;\n            case userMessage.startsWith('.hacker'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'hacker');\n                break;\n            case userMessage.startsWith('.sand'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'sand');\n                break;\n            case userMessage.startsWith('.blackpink'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'blackpink');\n                break;\n            case userMessage.startsWith('.glitch'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'glitch');\n                break;\n            case userMessage.startsWith('.fire'):\n                await textmakerCommand(sock, chatId, message, userMessage, 'fire');\n                break;\n            case userMessage.startsWith('.antidelete'):\n                const antideleteMatch = userMessage.slice(11).trim();\n                await handleAntideleteCommand(sock, chatId, message, antideleteMatch);\n                break;\n            case userMessage === '.surrender':\n                // Handle surrender command for tictactoe game\n                await handleTicTacToeMove(sock, chatId, senderId, 'surrender');\n                break;\n            case userMessage === '.cleartmp':\n                await clearTmpCommand(sock, chatId, message);\n                break;\n            case userMessage === '.setpp':\n                await setProfilePicture(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.setgdesc'):\n                {\n                    const text = rawText.slice(9).trim();\n                    await setGroupDescription(sock, chatId, senderId, text, message);\n                }\n                break;\n            case userMessage.startsWith('.setgname'):\n                {\n                    const text = rawText.slice(9).trim();\n                    await setGroupName(sock, chatId, senderId, text, message);\n                }\n                break;\n            case userMessage.startsWith('.setgpp'):\n                await setGroupPhoto(sock, chatId, senderId, message);\n                break;\n            case userMessage.startsWith('.instagram') || userMessage.startsWith('.insta') || (userMessage === '.ig' || userMessage.startsWith('.ig ')):\n                await instagramCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.igsc'):\n                await igsCommand(sock, chatId, message, true);\n                break;\n            case userMessage.startsWith('.igs'):\n                await igsCommand(sock, chatId, message, false);\n                break;\n            case userMessage.startsWith('.fb') || userMessage.startsWith('.facebook'):\n                await facebookCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.music'):\n                await playCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.play') || userMessage.startsWith('.mp3') || userMessage.startsWith('.ytmp3') || userMessage.startsWith('.song'):\n                await songCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.video') || userMessage.startsWith('.ytmp4'):\n                await videoCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.tiktok') || userMessage.startsWith('.tt'):\n                await tiktokCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.gpt') || userMessage.startsWith('.gemini'):\n                await aiCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.translate') || userMessage.startsWith('.trt'):\n                const commandLength = userMessage.startsWith('.translate') ? 10 : 4;\n                await handleTranslateCommand(sock, chatId, message, userMessage.slice(commandLength));\n                return;\n            case userMessage.startsWith('.ss') || userMessage.startsWith('.ssweb') || userMessage.startsWith('.screenshot'):\n                const ssCommandLength = userMessage.startsWith('.screenshot') ? 11 : (userMessage.startsWith('.ssweb') ? 6 : 3);\n                await handleSsCommand(sock, chatId, message, userMessage.slice(ssCommandLength).trim());\n                break;\n            case userMessage.startsWith('.areact') || userMessage.startsWith('.autoreact') || userMessage.startsWith('.autoreaction'):\n                const isOwnerOrSudo = message.key.fromMe || senderIsSudo;\n                await handleAreactCommand(sock, chatId, message, isOwnerOrSudo);\n                break;\n            case userMessage.startsWith('.sudo'):\n                await sudoCommand(sock, chatId, message);\n                break;\n            case userMessage === '.goodnight' || userMessage === '.lovenight' || userMessage === '.gn':\n                await goodnightCommand(sock, chatId, message);\n                break;\n            case userMessage === '.shayari' || userMessage === '.shayri':\n                await shayariCommand(sock, chatId, message);\n                break;\n            case userMessage === '.roseday':\n                await rosedayCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.imagine') || userMessage.startsWith('.flux') || userMessage.startsWith('.dalle'): await imagineCommand(sock, chatId, message);\n                break;\n            case userMessage === '.jid': await groupJidCommand(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.autotyping'):\n                await autotypingCommand(sock, chatId, message);\n                commandExecuted = true;\n                break;\n            case userMessage.startsWith('.autoread'):\n                await autoreadCommand(sock, chatId, message);\n                commandExecuted = true;\n                break;\n            case userMessage.startsWith('.heart'):\n                await handleHeart(sock, chatId, message);\n                break;\n            case userMessage.startsWith('.horny'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['horny', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.circle'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['circle', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.lgbt'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['lgbt', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.lolice'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['lolice', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.simpcard'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['simpcard', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.tonikawa'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['tonikawa', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.its-so-stupid'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['its-so-stupid', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.namecard'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['namecard', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n\n            case userMessage.startsWith('.oogway2'):\n            case userMessage.startsWith('.oogway'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const sub = userMessage.startsWith('.oogway2') ? 'oogway2' : 'oogway';\n                    const args = [sub, ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.tweet'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['tweet', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.ytcomment'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = ['youtube-comment', ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.comrade'):\n            case userMessage.startsWith('.gay'):\n            case userMessage.startsWith('.glass'):\n            case userMessage.startsWith('.jail'):\n            case userMessage.startsWith('.passed'):\n            case userMessage.startsWith('.triggered'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const sub = userMessage.slice(1).split(/\\s+/)[0];\n                    const args = [sub, ...parts.slice(1)];\n                    await miscCommand(sock, chatId, message, args);\n                }\n                break;\n            case userMessage.startsWith('.animu'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    const args = parts.slice(1);\n                    await animeCommand(sock, chatId, message, args);\n                }\n                break;\n            // animu aliases\n            case userMessage.startsWith('.nom'):\n            case userMessage.startsWith('.poke'):\n            case userMessage.startsWith('.cry'):\n            case userMessage.startsWith('.kiss'):\n            case userMessage.startsWith('.pat'):\n            case userMessage.startsWith('.hug'):\n            case userMessage.startsWith('.wink'):\n            case userMessage.startsWith('.facepalm'):\n            case userMessage.startsWith('.face-palm'):\n            case userMessage.startsWith('.animuquote'):\n            case userMessage.startsWith('.quote'):\n            case userMessage.startsWith('.neko'):\n            case userMessage.startsWith('.waifu'):\n            case userMessage.startsWith('.loli'):\n                {\n                    const parts = userMessage.trim().split(/\\s+/);\n                    let sub = parts[0].slice(1);\n                    if (sub === 'facepalm') sub = 'face-palm';\n                    if (sub === 'quote' || sub === 'animuquote') sub = 'quote';\n                    await animeCommand(sock, chatId, message, [sub]);\n                }\n                break;\n            case userMessage === '.crop':\n                await stickercropCommand(sock, chatId, message);\n                commandExecuted = true;\n                break;\n            case userMessage.startsWith('.pies'):\n                {\n                    const parts = rawText.trim().split(/\\s+/);\n                    const args = parts.slice(1);\n                    await piesCommand(sock, chatId, message, args);\n                    commandExecuted = true;\n                }\n                break;\n            case userMessage === '.china':\n                await piesAlias(sock, chatId, message, 'china');\n                commandExecuted = true;\n                break;\n            case userMessage === '.indonesia':\n                await piesAlias(sock, chatId, message, 'indonesia');\n                commandExecuted = true;\n                break;\n            case userMessage === '.japan':\n                await piesAlias(sock, chatId, message, 'japan');\n                commandExecuted = true;\n                break;\n            case userMessage === '.korea':\n                await piesAlias(sock, chatId, message, 'korea');\n                commandExecuted = true;\n                break;\n            case userMessage === '.hijab':\n                await piesAlias(sock, chatId, message, 'hijab');\n                commandExecuted = true;\n                break;\n            case userMessage.startsWith('.update'):\n                {\n                    const parts = rawText.trim().split(/\\s+/);\n                    const zipArg = parts[1] && parts[1].startsWith('http') ? parts[1] : '';\n                    await updateCommand(sock, chatId, message, senderIsSudo, zipArg);\n                }\n                commandExecuted = true;\n                break;\n            case userMessage.startsWith('.removebg') || userMessage.startsWith('.rmbg') || userMessage.startsWith('.nobg'):\n                await removebgCommand.exec(sock, message, userMessage.split(' ').slice(1));\n                break;\n            case userMessage.startsWith('.remini') || userMessage.startsWith('.enhance') || userMessage.startsWith('.upscale'):\n                await reminiCommand(sock, chatId, message, userMessage.split(' ').slice(1));\n                break;\n            default:\n                if (isGroup) {\n                    // Handle non-command group messages\n                    if (userMessage) {  // Make sure there's a message\n                        await handleChatbotResponse(sock, chatId, message, userMessage, senderId);\n                    }\n                    await Antilink(message, sock);\n                    await handleBadwordDetection(sock, chatId, message, userMessage, senderId);\n                    await handleTagDetection(sock, chatId, message, senderId);\n                }\n                commandExecuted = false;\n                break;\n        }\n\n        // If a command was executed, show typing status after command execution\n        if (commandExecuted !== false) {\n            // Command was executed, now show typing status after command execution\n            await showTypingAfterCommand(sock, chatId);\n        }\n\n        // Function to handle .groupjid command\n        async function groupJidCommand(sock, chatId, message) {\n            const groupJid = message.key.remoteJid;\n\n            if (!groupJid.endsWith('@g.us')) {\n                return await sock.sendMessage(chatId, {\n                    text: \"‚ùå This command can only be used in a group.\"\n                });\n            }\n\n            await sock.sendMessage(chatId, {\n                text: `‚úÖ Group JID: ${groupJid}`\n            }, {\n                quoted: message\n            });\n        }\n\n        if (userMessage.startsWith('.')) {\n            // After command is processed successfully\n            await addCommandReaction(sock, message);\n        }\n    } catch (error) {\n        console.error('‚ùå Error in message handler:', error.message);\n        // Only try to send error message if we have a valid chatId\n        if (chatId) {\n            await sock.sendMessage(chatId, {\n                text: '‚ùå Failed to process command!',\n                ...channelInfo\n            });\n        }\n    }\n}\n\nasync function handleGroupParticipantUpdate(sock, update) {\n    try {\n        const { id, participants, action, author } = update;\n\n        // Check if it's a group\n        if (!id.endsWith('@g.us')) return;\n\n        // Respect bot mode: only announce promote/demote in public mode\n        let isPublic = true;\n        try {\n            const modeData = JSON.parse(fs.readFileSync('./data/messageCount.json'));\n            if (typeof modeData.isPublic === 'boolean') isPublic = modeData.isPublic;\n        } catch (e) {\n            // If reading fails, default to public behavior\n        }\n\n        // Handle promotion events\n        if (action === 'promote') {\n            if (!isPublic) return;\n            await handlePromotionEvent(sock, id, participants, author);\n            return;\n        }\n\n        // Handle demotion events\n        if (action === 'demote') {\n            if (!isPublic) return;\n            await handleDemotionEvent(sock, id, participants, author);\n            return;\n        }\n\n        // Handle join events\n        if (action === 'add') {\n            // Check if welcome is enabled for this group\n            const isWelcomeEnabled = await isWelcomeOn(id);\n            if (!isWelcomeEnabled) return;\n\n            // Get group metadata\n            const groupMetadata = await sock.groupMetadata(id);\n            const groupName = groupMetadata.subject;\n            const groupDesc = groupMetadata.desc || 'No description available';\n\n            // Use simple default welcome message\n            const welcomeMessage = 'Welcome {user} to {group}! üéâ';\n\n            // Send welcome message for each new participant\n            for (const participant of participants) {\n                const user = participant.split('@')[0];\n                const formattedMessage = welcomeMessage\n                    .replace('{user}', `@${user}`)\n                    .replace('{group}', groupName)\n                    .replace('{description}', groupDesc);\n\n                await sock.sendMessage(id, {\n                    text: formattedMessage,\n                    mentions: [participant]\n                });\n            }\n        }\n\n        // Handle leave events\n        if (action === 'remove') {\n            // Check if goodbye is enabled for this group\n            const isGoodbyeEnabled = await isGoodByeOn(id);\n            if (!isGoodbyeEnabled) return;\n\n            // Get group metadata\n            const groupMetadata = await sock.groupMetadata(id);\n            const groupName = groupMetadata.subject;\n\n            // Use simple default goodbye message\n            const goodbyeMessage = 'Goodbye {user} üëã';\n\n            // Send goodbye message for each leaving participant\n            for (const participant of participants) {\n                const user = participant.split('@')[0];\n                const formattedMessage = goodbyeMessage\n                    .replace('{user}', `@${user}`)\n                    .replace('{group}', groupName);\n\n                await sock.sendMessage(id, {\n                    text: formattedMessage,\n                    mentions: [participant]\n                });\n            }\n        }\n    } catch (error) {\n        console.error('Error in handleGroupParticipantUpdate:', error);\n    }\n}\n\n// Instead, export the handlers along with handleMessages\nmodule.exports = {\n    handleMessages,\n    handleGroupParticipantUpdate,\n    handleStatus: async (sock, status) => {\n        await handleStatusUpdate(sock, status);\n    }\n};\n","size_bytes":58655},"replit.md":{"content":"# Knight Bot - WhatsApp Bot Project\n\n## Project Overview\nKnight Bot is a comprehensive WhatsApp bot built using Node.js and the Baileys library. It provides group management features, interactive games, and various utility commands for WhatsApp users.\n\n## Current State\n- **Status**: Successfully imported and configured for Replit environment\n- **Version**: 2.1.8\n- **Main Entry Point**: index.js\n- **Authentication**: WhatsApp session already configured with valid credentials\n\n## Key Features\n- Group management commands (tag all, mute/unmute, ban/unban)\n- Interactive games (Tic-Tac-Toe, Hangman, Trivia)\n- Text-to-Speech functionality\n- Sticker creation and manipulation\n- Anti-link and anti-spam protection\n- YouTube and social media downloaders\n- AI chat features\n- Owner/admin command restrictions\n\n## Project Architecture\n- **Entry Point**: `index.js` - Main bot initialization and WhatsApp connection\n- **Message Handler**: `main.js` - Core message processing and command routing\n- **Commands**: `/commands/` directory - Individual command implementations\n- **Libraries**: `/lib/` directory - Utility functions and helpers\n- **Data**: `/data/` directory - JSON files for bot state and user data\n- **Session**: `/session/` directory - WhatsApp authentication files\n- **Configuration**: `config.js` and `settings.js` - Bot configuration\n\n## Environment Setup\n- **Language**: Node.js 20\n- **Dependencies**: Installed via npm (562 packages)\n- **Workflow**: Console application running `node index.js`\n- **Deployment**: Configured as VM deployment for always-on operation\n\n## Recent Changes (September 18, 2025)\n- Imported from GitHub repository\n- Configured Node.js 20 environment\n- Verified existing WhatsApp session credentials\n- Set up workflow for continuous operation\n- Configured deployment settings for production\n- Created project documentation\n\n## Command Examples\n- `.help` or `.menu` - Display available commands\n- `.tagall` - Tag all group members (admin only)\n- `.sticker` - Create sticker from image/video\n- `.play [song]` - Download music from YouTube\n- `.tts [text]` - Convert text to speech\n- `.weather [city]` - Get weather information\n\n## Technical Notes\n- Uses Baileys library for WhatsApp Web API\n- Supports multi-device WhatsApp features\n- Memory optimized with garbage collection\n- Includes anti-crash error handling\n- Session persistence across restarts\n\n## Owner Configuration\n- Owner number configured in settings.js\n- Bot responds to owner with special privileges\n- Private/public mode toggle available\n\n## Security Features\n- User ban system\n- Admin command restrictions\n- Anti-spam and anti-link protection\n- Private message blocker option","size_bytes":2674},"settings.js":{"content":"const settings = {\n  packname: process.env.PACK_NAME || 'Cortex Bot',\n  author: process.env.AUTHOR || 'SULEIMAN',\n  botName: process.env.BOT_NAME || \"Cortex Bot\",\n  botOwner: process.env.BOT_OWNER || 'SULEIMAN', // Creator name\n  ownerNumber: process.env.OWNER_NUMBERS || '2348088941798', //Set your number here without + symbol, just add country code & number without any space\n  ownerNumbers: (process.env.OWNER_NUMBERS || '2348088941798').split(',').map(num => num.trim()), // Support multiple owners\n  giphyApiKey: 'qnl7ssQChTdPjsKta2Ax2LMaGXz303tq',\n  commandMode: \"public\",\n  maxStoreMessages: 20, \n  storeWriteInterval: 10000,\n  description: \"This is a bot for managing group commands and automating tasks.\",\n  version: \"2.1.8\",\n  updateZipUrl: \"https://github.com/cortexinvader/Cortexbot-MD/archive/refs/heads/main.zip\",\n};\n\nmodule.exports = settings;\n","size_bytes":860},"commands/ai.js":{"content":"const axios = require('axios');\nconst fetch = require('node-fetch');\n\nasync function aiCommand(sock, chatId, message) {\n    try {\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        \n        if (!text) {\n            return await sock.sendMessage(chatId, { \n                text: \"Please provide a question after .gpt or .gemini\\n\\nExample: .gpt write a basic html code\"\n            }, {\n                quoted: message\n            });\n        }\n\n        // Get the command and query\n        const parts = text.split(' ');\n        const command = parts[0].toLowerCase();\n        const query = parts.slice(1).join(' ').trim();\n\n        if (!query) {\n            return await sock.sendMessage(chatId, { \n                text: \"Please provide a question after .gpt or .gemini\"\n            }, {quoted:message});\n        }\n\n        try {\n            // Show processing message\n            await sock.sendMessage(chatId, {\n                react: { text: 'ü§ñ', key: message.key }\n            });\n\n            if (command === '.gpt') {\n                // Call the GPT API\n                const response = await axios.get(`https://api.dreaded.site/api/chatgpt?text=${encodeURIComponent(query)}`);\n                \n                if (response.data && response.data.success && response.data.result) {\n                    const answer = response.data.result.prompt;\n                    await sock.sendMessage(chatId, {\n                        text: answer\n                    }, {\n                        quoted: message\n                    });\n                    \n                } else {\n                    throw new Error('Invalid response from API');\n                }\n            } else if (command === '.gemini') {\n                const apis = [\n                    `https://vapis.my.id/api/gemini?q=${encodeURIComponent(query)}`,\n                    `https://api.siputzx.my.id/api/ai/gemini-pro?content=${encodeURIComponent(query)}`,\n                    `https://api.ryzendesu.vip/api/ai/gemini?text=${encodeURIComponent(query)}`,\n                    `https://api.dreaded.site/api/gemini2?text=${encodeURIComponent(query)}`,\n                    `https://api.giftedtech.my.id/api/ai/geminiai?apikey=gifted&q=${encodeURIComponent(query)}`,\n                    `https://api.giftedtech.my.id/api/ai/geminiaipro?apikey=gifted&q=${encodeURIComponent(query)}`\n                ];\n\n                for (const api of apis) {\n                    try {\n                        const response = await fetch(api);\n                        const data = await response.json();\n\n                        if (data.message || data.data || data.answer || data.result) {\n                            const answer = data.message || data.data || data.answer || data.result;\n                            await sock.sendMessage(chatId, {\n                                text: answer\n                            }, {\n                                quoted: message\n                            });\n                            \n                            return;\n                        }\n                    } catch (e) {\n                        continue;\n                    }\n                }\n                throw new Error('All Gemini APIs failed');\n            }\n        } catch (error) {\n            console.error('API Error:', error);\n            await sock.sendMessage(chatId, {\n                text: \"‚ùå Failed to get response. Please try again later.\",\n                contextInfo: {\n                    mentionedJid: [message.key.participant || message.key.remoteJid],\n                    quotedMessage: message.message\n                }\n            }, {\n                quoted: message\n            });\n        }\n    } catch (error) {\n        console.error('AI Command Error:', error);\n        await sock.sendMessage(chatId, {\n            text: \"‚ùå An error occurred. Please try again later.\",\n            contextInfo: {\n                mentionedJid: [message.key.participant || message.key.remoteJid],\n                quotedMessage: message.message\n            }\n        }, {\n            quoted: message\n        });\n    }\n}\n\nmodule.exports = aiCommand; ","size_bytes":4191},"commands/alive.js":{"content":"const settings = require(\"../settings\");\nasync function aliveCommand(sock, chatId, message) {\n    try {\n        const message1 = `*ü§ñ Cortex Bot is Active!*\\n\\n` +\n                       `*Version:* ${settings.version}\\n` +\n                       `*Status:* Online\\n` +\n                       `*Mode:* Public\\n\\n` +\n                       `*üåü Features:*\\n` +\n                       `‚Ä¢ Group Management\\n` +\n                       `‚Ä¢ Antilink Protection\\n` +\n                       `‚Ä¢ Fun Commands\\n` +\n                       `‚Ä¢ And more!\\n\\n` +\n                       `Type *.menu* for full command list`;\n\n        await sock.sendMessage(chatId, {\n            text: message1\n        }, { quoted: message });\n    } catch (error) {\n        console.error('Error in alive command:', error);\n        await sock.sendMessage(chatId, { text: 'Bot is alive and running!' }, { quoted: message });\n    }\n}\n\nmodule.exports = aliveCommand;","size_bytes":939},"commands/anime.js":{"content":"const axios = require('axios');\nconst { exec } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst webp = require('node-webpmux');\nconst crypto = require('crypto');\n\nconst ANIMU_BASE = 'https://api.some-random-api.com/animu';\n\nfunction normalizeType(input) {\n    const lower = (input || '').toLowerCase();\n    if (lower === 'facepalm' || lower === 'face_palm') return 'face-palm';\n    if (lower === 'quote' || lower === 'animu-quote' || lower === 'animuquote') return 'quote';\n    return lower;\n}\n\nasync function sendAnimu(sock, chatId, message, type) {\n    const endpoint = `${ANIMU_BASE}/${type}`;\n    const res = await axios.get(endpoint);\n    const data = res.data || {};\n\n    // Prefer link (gif/image). Send as sticker if applicable; fallback to image\n    // helper to convert media buffer to sticker webp\n    async function convertMediaToSticker(mediaBuffer, isAnimated) {\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });\n\n        const inputExt = isAnimated ? 'gif' : 'jpg';\n        const input = path.join(tmpDir, `animu_${Date.now()}.${inputExt}`);\n        const output = path.join(tmpDir, `animu_${Date.now()}.webp`);\n        fs.writeFileSync(input, mediaBuffer);\n\n        const ffmpegCmd = isAnimated \n            ? `ffmpeg -y -i \"${input}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000,fps=15\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 60 -compression_level 6 \"${output}\"`\n            : `ffmpeg -y -i \"${input}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${output}\"`;\n\n        await new Promise((resolve, reject) => {\n            exec(ffmpegCmd, (err) => (err ? reject(err) : resolve()));\n        });\n\n        let webpBuffer = fs.readFileSync(output);\n\n        // Add sticker metadata\n        const img = new webp.Image();\n        await img.load(webpBuffer);\n\n        const json = {\n            'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n            'sticker-pack-name': 'Anime Stickers',\n            'emojis': ['üéå']\n        };\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n        const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n        const exif = Buffer.concat([exifAttr, jsonBuffer]);\n        exif.writeUIntLE(jsonBuffer.length, 14, 4);\n        img.exif = exif;\n\n        const finalBuffer = await img.save(null);\n\n        try { fs.unlinkSync(input); } catch {}\n        try { fs.unlinkSync(output); } catch {}\n        return finalBuffer;\n    }\n\n    if (data.link) {\n        const link = data.link;\n        const lower = link.toLowerCase();\n        const isGifLink = lower.endsWith('.gif');\n        const isImageLink = lower.match(/\\.(jpg|jpeg|png|webp)$/);\n\n        // Convert all media (GIFs and images) to stickers\n        if (isGifLink || isImageLink) {\n            try {\n                const resp = await axios.get(link, {\n                    responseType: 'arraybuffer',\n                    timeout: 15000,\n                    headers: { 'User-Agent': 'Mozilla/5.0' }\n                });\n                const mediaBuf = Buffer.from(resp.data);\n                const stickerBuf = await convertMediaToSticker(mediaBuf, isGifLink);\n                await sock.sendMessage(\n                    chatId,\n                    { sticker: stickerBuf },\n                    { quoted: message }\n                );\n                return;\n            } catch (error) {\n                console.error('Error converting media to sticker:', error);\n            }\n        }\n\n        // Fallback to image if conversion fails\n        try {\n            await sock.sendMessage(\n                chatId,\n                { image: { url: link }, caption: `anime: ${type}` },\n                { quoted: message }\n            );\n            return;\n        } catch {}\n    }\n    if (data.quote) {\n        await sock.sendMessage(\n            chatId,\n            { text: data.quote },\n            { quoted: message }\n        );\n        return;\n    }\n\n    await sock.sendMessage(\n        chatId,\n        { text: '‚ùå Failed to fetch animu.' },\n        { quoted: message }\n    );\n}\n\nasync function animeCommand(sock, chatId, message, args) {\n    const subArg = args && args[0] ? args[0] : '';\n    const sub = normalizeType(subArg);\n\n    const supported = [\n        'nom', 'poke', 'cry', 'kiss', 'pat', 'hug', 'wink', 'face-palm', 'quote'\n    ];\n\n    try {\n        if (!sub) {\n            // Fetch supported types from API for dynamic help\n            try {\n                const res = await axios.get(ANIMU_BASE);\n                const apiTypes = res.data && res.data.types ? res.data.types.map(s => s.replace('/animu/', '')).join(', ') : supported.join(', ');\n                await sock.sendMessage(chatId, { text: `Usage: .animu <type>\\nTypes: ${apiTypes}` }, { quoted: message });\n            } catch {\n                await sock.sendMessage(chatId, { text: `Usage: .animu <type>\\nTypes: ${supported.join(', ')}` }, { quoted: message });\n            }\n            return;\n        }\n\n        if (!supported.includes(sub)) {\n            await sock.sendMessage(chatId, { text: `‚ùå Unsupported type: ${sub}. Try one of: ${supported.join(', ')}` }, { quoted: message });\n            return;\n        }\n\n        await sendAnimu(sock, chatId, message, sub);\n    } catch (err) {\n        console.error('Error in animu command:', err);\n        await sock.sendMessage(chatId, { text: '‚ùå An error occurred while fetching animu.' }, { quoted: message });\n    }\n}\n\nmodule.exports = { animeCommand };\n\n\n","size_bytes":5914},"commands/antibadword.js":{"content":"const { handleAntiBadwordCommand } = require('../lib/antibadword');\nconst isAdminHelper = require('../lib/isAdmin');\n\nasync function antibadwordCommand(sock, chatId, message, senderId, isSenderAdmin) {\n    try {\n        if (!isSenderAdmin) {\n            await sock.sendMessage(chatId, { text: '```For Group Admins Only!```' }, { quoted: message });\n            return;\n        }\n\n        // Extract match from message\n        const text = message.message?.conversation || \n                    message.message?.extendedTextMessage?.text || '';\n        const match = text.split(' ').slice(1).join(' ');\n\n        await handleAntiBadwordCommand(sock, chatId, message, match);\n    } catch (error) {\n        console.error('Error in antibadword command:', error);\n        await sock.sendMessage(chatId, { text: '*Error processing antibadword command*' }, { quoted: message });\n    }\n}\n\nmodule.exports = antibadwordCommand; ","size_bytes":916},"commands/anticall.js":{"content":"const fs = require('fs');\n\nconst ANTICALL_PATH = './data/anticall.json';\n\nfunction readState() {\n    try {\n        if (!fs.existsSync(ANTICALL_PATH)) return { enabled: false };\n        const raw = fs.readFileSync(ANTICALL_PATH, 'utf8');\n        const data = JSON.parse(raw || '{}');\n        return { enabled: !!data.enabled };\n    } catch {\n        return { enabled: false };\n    }\n}\n\nfunction writeState(enabled) {\n    try {\n        if (!fs.existsSync('./data')) fs.mkdirSync('./data', { recursive: true });\n        fs.writeFileSync(ANTICALL_PATH, JSON.stringify({ enabled: !!enabled }, null, 2));\n    } catch {}\n}\n\nasync function anticallCommand(sock, chatId, message, args) {\n    // Check if sender is the owner or sudo\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudo = require('../lib/isOwner');\n    const hasPermission = await isOwnerOrSudo(senderJid);\n\n    if (!hasPermission) {\n        await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo users!' }, { quoted: message });\n        return;\n    }\n\n    const state = readState();\n    const sub = (args || '').trim().toLowerCase();\n\n    if (!sub || (sub !== 'on' && sub !== 'off' && sub !== 'status')) {\n        await sock.sendMessage(chatId, { text: '*ANTICALL*\\n\\n.anticall on  - Enable auto-block on incoming calls\\n.anticall off - Disable anticall\\n.anticall status - Show current status' }, { quoted: message });\n        return;\n    }\n\n    if (sub === 'status') {\n        await sock.sendMessage(chatId, { text: `Anticall is currently *${state.enabled ? 'ON' : 'OFF'}*.` }, { quoted: message });\n        return;\n    }\n\n    const enable = sub === 'on';\n    writeState(enable);\n    await sock.sendMessage(chatId, { text: `Anticall is now *${enable ? 'ENABLED' : 'DISABLED'}*.` }, { quoted: message });\n}\n\nmodule.exports = { anticallCommand, readState };\n\n\n","size_bytes":1902},"commands/antidelete.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { tmpdir } = require('os');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\nconst { writeFile } = require('fs/promises');\n\nconst messageStore = new Map();\nconst CONFIG_PATH = path.join(__dirname, '../data/antidelete.json');\nconst TEMP_MEDIA_DIR = path.join(__dirname, '../tmp');\n\n// Ensure tmp dir exists\nif (!fs.existsSync(TEMP_MEDIA_DIR)) {\n    fs.mkdirSync(TEMP_MEDIA_DIR, { recursive: true });\n}\n\n// Function to get folder size in MB\nconst getFolderSizeInMB = (folderPath) => {\n    try {\n        const files = fs.readdirSync(folderPath);\n        let totalSize = 0;\n\n        for (const file of files) {\n            const filePath = path.join(folderPath, file);\n            if (fs.statSync(filePath).isFile()) {\n                totalSize += fs.statSync(filePath).size;\n            }\n        }\n\n        return totalSize / (1024 * 1024); // Convert bytes to MB\n    } catch (err) {\n        console.error('Error getting folder size:', err);\n        return 0;\n    }\n};\n\n// Function to clean temp folder if size exceeds 10MB\nconst cleanTempFolderIfLarge = () => {\n    try {\n        const sizeMB = getFolderSizeInMB(TEMP_MEDIA_DIR);\n        \n        if (sizeMB > 100) {\n            const files = fs.readdirSync(TEMP_MEDIA_DIR);\n            for (const file of files) {\n                const filePath = path.join(TEMP_MEDIA_DIR, file);\n                fs.unlinkSync(filePath);\n            }\n        }\n    } catch (err) {\n        console.error('Temp cleanup error:', err);\n    }\n};\n\n// Start periodic cleanup check every 1 minute\nsetInterval(cleanTempFolderIfLarge, 60 * 1000);\n\n// Load config\nfunction loadAntideleteConfig() {\n    try {\n        if (!fs.existsSync(CONFIG_PATH)) return { enabled: false };\n        return JSON.parse(fs.readFileSync(CONFIG_PATH));\n    } catch {\n        return { enabled: false };\n    }\n}\n\n// Save config\nfunction saveAntideleteConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2));\n    } catch (err) {\n        console.error('Config save error:', err);\n    }\n}\n\n// Command Handler\nasync function handleAntideleteCommand(sock, chatId, message, match) {\n    // Check if sender is the owner or sudo\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudo = require('../lib/isOwner');\n    const hasPermission = await isOwnerOrSudo(senderJid);\n\n    if (!hasPermission) {\n        return sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo users!' }, { quoted: message });\n    }\n\n    const config = loadAntideleteConfig();\n\n    if (!match) {\n        return sock.sendMessage(chatId, {\n            text: `*ANTIDELETE SETUP*\\n\\nCurrent Status: ${config.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}\\n\\n*.antidelete on* - Enable\\n*.antidelete off* - Disable`\n        }, {quoted: message});\n    }\n\n    if (match === 'on') {\n        config.enabled = true;\n    } else if (match === 'off') {\n        config.enabled = false;\n    } else {\n        return sock.sendMessage(chatId, { text: '*Invalid command. Use .antidelete to see usage.*' }, {quoted:message});\n    }\n\n    saveAntideleteConfig(config);\n    return sock.sendMessage(chatId, { text: `*Antidelete ${match === 'on' ? 'enabled' : 'disabled'}*` }, {quoted:message});\n}\n\n// Store incoming messages\nasync function storeMessage(message) {\n    try {\n        const config = loadAntideleteConfig();\n        if (!config.enabled) return; // Don't store if antidelete is disabled\n\n        if (!message.key?.id) return;\n\n        const messageId = message.key.id;\n        let content = '';\n        let mediaType = '';\n        let mediaPath = '';\n\n        const sender = message.key.participant || message.key.remoteJid;\n\n        // Detect content\n        if (message.message?.conversation) {\n            content = message.message.conversation;\n        } else if (message.message?.extendedTextMessage?.text) {\n            content = message.message.extendedTextMessage.text;\n        } else if (message.message?.imageMessage) {\n            mediaType = 'image';\n            content = message.message.imageMessage.caption || '';\n            const buffer = await downloadContentFromMessage(message.message.imageMessage, 'image');\n            mediaPath = path.join(TEMP_MEDIA_DIR, `${messageId}.jpg`);\n            await writeFile(mediaPath, buffer);\n        } else if (message.message?.stickerMessage) {\n            mediaType = 'sticker';\n            const buffer = await downloadContentFromMessage(message.message.stickerMessage, 'sticker');\n            mediaPath = path.join(TEMP_MEDIA_DIR, `${messageId}.webp`);\n            await writeFile(mediaPath, buffer);\n        } else if (message.message?.videoMessage) {\n            mediaType = 'video';\n            content = message.message.videoMessage.caption || '';\n            const buffer = await downloadContentFromMessage(message.message.videoMessage, 'video');\n            mediaPath = path.join(TEMP_MEDIA_DIR, `${messageId}.mp4`);\n            await writeFile(mediaPath, buffer);\n        }\n\n        messageStore.set(messageId, {\n            content,\n            mediaType,\n            mediaPath,\n            sender,\n            group: message.key.remoteJid.endsWith('@g.us') ? message.key.remoteJid : null,\n            timestamp: new Date().toISOString()\n        });\n\n    } catch (err) {\n        console.error('storeMessage error:', err);\n    }\n}\n\n// Handle message deletion\nasync function handleMessageRevocation(sock, revocationMessage) {\n    try {\n        const config = loadAntideleteConfig();\n        if (!config.enabled) return;\n\n        const messageId = revocationMessage.message.protocolMessage.key.id;\n        const deletedBy = revocationMessage.participant || revocationMessage.key.participant || revocationMessage.key.remoteJid;\n        const ownerNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n\n        if (deletedBy.includes(sock.user.id) || deletedBy === ownerNumber) return;\n\n        const original = messageStore.get(messageId);\n        if (!original) return;\n\n        const sender = original.sender;\n        const senderName = sender.split('@')[0];\n        const groupName = original.group ? (await sock.groupMetadata(original.group)).subject : '';\n\n        const time = new Date().toLocaleString('en-US', {\n            timeZone: 'Asia/Kolkata',\n            hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit',\n            day: '2-digit', month: '2-digit', year: 'numeric'\n        });\n\n        let text = `*üî∞ ANTIDELETE REPORT üî∞*\\n\\n` +\n            `*üóëÔ∏è Deleted By:* @${deletedBy.split('@')[0]}\\n` +\n            `*üë§ Sender:* @${senderName}\\n` +\n            `*üì± Number:* ${sender}\\n` +\n            `*üïí Time:* ${time}\\n`;\n\n        if (groupName) text += `*üë• Group:* ${groupName}\\n`;\n\n        if (original.content) {\n            text += `\\n*üí¨ Deleted Message:*\\n${original.content}`;\n        }\n\n        await sock.sendMessage(ownerNumber, {\n            text,\n            mentions: [deletedBy, sender]\n        });\n\n        // Media sending\n        if (original.mediaType && fs.existsSync(original.mediaPath)) {\n            const mediaOptions = {\n                caption: `*Deleted ${original.mediaType}*\\nFrom: @${senderName}`,\n                mentions: [sender]\n            };\n\n            try {\n                switch (original.mediaType) {\n                    case 'image':\n                        await sock.sendMessage(ownerNumber, {\n                            image: { url: original.mediaPath },\n                            ...mediaOptions\n                        });\n                        break;\n                    case 'sticker':\n                        await sock.sendMessage(ownerNumber, {\n                            sticker: { url: original.mediaPath },\n                            ...mediaOptions\n                        });\n                        break;\n                    case 'video':\n                        await sock.sendMessage(ownerNumber, {\n                            video: { url: original.mediaPath },\n                            ...mediaOptions\n                        });\n                        break;\n                }\n            } catch (err) {\n                await sock.sendMessage(ownerNumber, {\n                    text: `‚ö†Ô∏è Error sending media: ${err.message}`\n                });\n            }\n\n            // Cleanup\n            try {\n                fs.unlinkSync(original.mediaPath);\n            } catch (err) {\n                console.error('Media cleanup error:', err);\n            }\n        }\n\n        messageStore.delete(messageId);\n\n    } catch (err) {\n        console.error('handleMessageRevocation error:', err);\n    }\n}\n\nmodule.exports = {\n    handleAntideleteCommand,\n    handleMessageRevocation,\n    storeMessage\n};\n","size_bytes":8849},"commands/antilink.js":{"content":"const { bots } = require('../lib/antilink');\nconst { setAntilink, getAntilink, removeAntilink } = require('../lib/index');\nconst isAdmin = require('../lib/isAdmin');\n\nasync function handleAntilinkCommand(sock, chatId, userMessage, senderId, isSenderAdmin, message) {\n    try {\n        if (!isSenderAdmin) {\n            await sock.sendMessage(chatId, { text: '```For Group Admins Only!```' }, { quoted: message });\n            return;\n        }\n\n        const prefix = '.';\n        const args = userMessage.slice(9).toLowerCase().trim().split(' ');\n        const action = args[0];\n\n        if (!action) {\n            const usage = `\\`\\`\\`ANTILINK SETUP\\n\\n${prefix}antilink on\\n${prefix}antilink set delete | kick | warn\\n${prefix}antilink off\\n\\`\\`\\``;\n            await sock.sendMessage(chatId, { text: usage }, { quoted: message });\n            return;\n        }\n\n        switch (action) {\n            case 'on':\n                const existingConfig = await getAntilink(chatId, 'on');\n                if (existingConfig?.enabled) {\n                    await sock.sendMessage(chatId, { text: '*_Antilink is already on_*' }, { quoted: message });\n                    return;\n                }\n                const result = await setAntilink(chatId, 'on', 'delete');\n                await sock.sendMessage(chatId, { \n                    text: result ? '*_Antilink has been turned ON_*' : '*_Failed to turn on Antilink_*' \n                },{ quoted: message });\n                break;\n\n            case 'off':\n                await removeAntilink(chatId, 'on');\n                await sock.sendMessage(chatId, { text: '*_Antilink has been turned OFF_*' }, { quoted: message });\n                break;\n\n            case 'set':\n                if (args.length < 2) {\n                    await sock.sendMessage(chatId, { \n                        text: `*_Please specify an action: ${prefix}antilink set delete | kick | warn_*` \n                    }, { quoted: message });\n                    return;\n                }\n                const setAction = args[1];\n                if (!['delete', 'kick', 'warn'].includes(setAction)) {\n                    await sock.sendMessage(chatId, { \n                        text: '*_Invalid action. Choose delete, kick, or warn._*' \n                    }, { quoted: message });\n                    return;\n                }\n                const setResult = await setAntilink(chatId, 'on', setAction);\n                await sock.sendMessage(chatId, { \n                    text: setResult ? `*_Antilink action set to ${setAction}_*` : '*_Failed to set Antilink action_*' \n                }, { quoted: message });\n                break;\n\n            case 'get':\n                const status = await getAntilink(chatId, 'on');\n                const actionConfig = await getAntilink(chatId, 'on');\n                await sock.sendMessage(chatId, { \n                    text: `*_Antilink Configuration:_*\\nStatus: ${status ? 'ON' : 'OFF'}\\nAction: ${actionConfig ? actionConfig.action : 'Not set'}` \n                }, { quoted: message });\n                break;\n\n            default:\n                await sock.sendMessage(chatId, { text: `*_Use ${prefix}antilink for usage._*` });\n        }\n    } catch (error) {\n        console.error('Error in antilink command:', error);\n        await sock.sendMessage(chatId, { text: '*_Error processing antilink command_*' });\n    }\n}\n\nasync function handleLinkDetection(sock, chatId, message, userMessage, senderId) {\n    const antilinkSetting = getAntilinkSetting(chatId);\n    if (antilinkSetting === 'off') return;\n\n    console.log(`Antilink Setting for ${chatId}: ${antilinkSetting}`);\n    console.log(`Checking message for links: ${userMessage}`);\n    \n    // Log the full message object to diagnose message structure\n    console.log(\"Full message object: \", JSON.stringify(message, null, 2));\n\n    let shouldDelete = false;\n\n    const linkPatterns = {\n        whatsappGroup: /chat\\.whatsapp\\.com\\/[A-Za-z0-9]{20,}/,\n        whatsappChannel: /wa\\.me\\/channel\\/[A-Za-z0-9]{20,}/,\n        telegram: /t\\.me\\/[A-Za-z0-9_]+/,\n        allLinks: /https?:\\/\\/[^\\s]+/,\n    };\n\n    // Detect WhatsApp Group links\n    if (antilinkSetting === 'whatsappGroup') {\n        console.log('WhatsApp group link protection is enabled.');\n        if (linkPatterns.whatsappGroup.test(userMessage)) {\n            console.log('Detected a WhatsApp group link!');\n            shouldDelete = true;\n        }\n    } else if (antilinkSetting === 'whatsappChannel' && linkPatterns.whatsappChannel.test(userMessage)) {\n        shouldDelete = true;\n    } else if (antilinkSetting === 'telegram' && linkPatterns.telegram.test(userMessage)) {\n        shouldDelete = true;\n    } else if (antilinkSetting === 'allLinks' && linkPatterns.allLinks.test(userMessage)) {\n        shouldDelete = true;\n    }\n\n    if (shouldDelete) {\n        const quotedMessageId = message.key.id; // Get the message ID to delete\n        const quotedParticipant = message.key.participant || senderId; // Get the participant ID\n\n        console.log(`Attempting to delete message with id: ${quotedMessageId} from participant: ${quotedParticipant}`);\n\n        try {\n            await sock.sendMessage(chatId, {\n                delete: { remoteJid: chatId, fromMe: false, id: quotedMessageId, participant: quotedParticipant },\n            });\n            console.log(`Message with ID ${quotedMessageId} deleted successfully.`);\n        } catch (error) {\n            console.error('Failed to delete message:', error);\n        }\n\n        const mentionedJidList = [senderId];\n        await sock.sendMessage(chatId, { text: `Warning! @${senderId.split('@')[0]}, posting links is not allowed.`, mentions: mentionedJidList });\n    } else {\n        console.log('No link detected or protection not enabled for this type of link.');\n    }\n}\n\nmodule.exports = {\n    handleAntilinkCommand,\n    handleLinkDetection,\n};\n","size_bytes":5913},"commands/antitag.js":{"content":"const { setAntitag, getAntitag, removeAntitag } = require('../lib/index');\nconst isAdmin = require('../lib/isAdmin');\n\nasync function handleAntitagCommand(sock, chatId, userMessage, senderId, isSenderAdmin, message) {\n    try {\n        if (!isSenderAdmin) {\n            await sock.sendMessage(chatId, { text: '```For Group Admins Only!```' },{quoted :message});\n            return;\n        }\n\n        const prefix = '.';\n        const args = userMessage.slice(9).toLowerCase().trim().split(' ');\n        const action = args[0];\n\n        if (!action) {\n            const usage = `\\`\\`\\`ANTITAG SETUP\\n\\n${prefix}antitag on\\n${prefix}antitag set delete | kick\\n${prefix}antitag off\\n\\`\\`\\``;\n            await sock.sendMessage(chatId, { text: usage },{quoted :message});\n            return;\n        }\n\n        switch (action) {\n            case 'on':\n                const existingConfig = await getAntitag(chatId, 'on');\n                if (existingConfig?.enabled) {\n                    await sock.sendMessage(chatId, { text: '*_Antitag is already on_*' },{quoted :message});\n                    return;\n                }\n                const result = await setAntitag(chatId, 'on', 'delete');\n                await sock.sendMessage(chatId, { \n                    text: result ? '*_Antitag has been turned ON_*' : '*_Failed to turn on Antitag_*' \n                },{quoted :message});\n                break;\n\n            case 'off':\n                await removeAntitag(chatId, 'on');\n                await sock.sendMessage(chatId, { text: '*_Antitag has been turned OFF_*' },{quoted :message});\n                break;\n\n            case 'set':\n                if (args.length < 2) {\n                    await sock.sendMessage(chatId, { \n                        text: `*_Please specify an action: ${prefix}antitag set delete | kick_*` \n                    },{quoted :message});\n                    return;\n                }\n                const setAction = args[1];\n                if (!['delete', 'kick'].includes(setAction)) {\n                    await sock.sendMessage(chatId, { \n                        text: '*_Invalid action. Choose delete or kick._*' \n                    },{quoted :message});\n                    return;\n                }\n                const setResult = await setAntitag(chatId, 'on', setAction);\n                await sock.sendMessage(chatId, { \n                    text: setResult ? `*_Antitag action set to ${setAction}_*` : '*_Failed to set Antitag action_*' \n                },{quoted :message});\n                break;\n\n            case 'get':\n                const status = await getAntitag(chatId, 'on');\n                const actionConfig = await getAntitag(chatId, 'on');\n                await sock.sendMessage(chatId, { \n                    text: `*_Antitag Configuration:_*\\nStatus: ${status ? 'ON' : 'OFF'}\\nAction: ${actionConfig ? actionConfig.action : 'Not set'}` \n                },{quoted :message});\n                break;\n\n            default:\n                await sock.sendMessage(chatId, { text: `*_Use ${prefix}antitag for usage._*` },{quoted :message});\n        }\n    } catch (error) {\n        console.error('Error in antitag command:', error);\n        await sock.sendMessage(chatId, { text: '*_Error processing antitag command_*' },{quoted :message});\n    }\n}\n\nasync function handleTagDetection(sock, chatId, message, senderId) {\n    try {\n        const antitagSetting = await getAntitag(chatId, 'on');\n        if (!antitagSetting || !antitagSetting.enabled) return;\n\n        // Check if message contains mentions\n        const mentions = message.message?.extendedTextMessage?.contextInfo?.mentionedJid || \n                        message.message?.conversation?.match(/@\\d+/g) ||\n                        [];\n\n        // Check if it's a group message and has multiple mentions\n        if (mentions.length > 0 && mentions.length >= 3) {\n            // Get group participants to check if it's tagging most/all members\n            const groupMetadata = await sock.groupMetadata(chatId);\n            const participants = groupMetadata.participants || [];\n            \n            // If mentions are more than 50% of group members, consider it as tagall\n            const mentionThreshold = Math.ceil(participants.length * 0.5);\n            \n            if (mentions.length >= mentionThreshold) {\n                \n                const action = antitagSetting.action || 'delete';\n                \n                if (action === 'delete') {\n                    // Delete the message\n                    await sock.sendMessage(chatId, {\n                        delete: {\n                            remoteJid: chatId,\n                            fromMe: false,\n                            id: message.key.id,\n                            participant: senderId\n                        }\n                    });\n                    \n                    // Send warning\n                    await sock.sendMessage(chatId, {\n                        text: `‚ö†Ô∏è *Tagall Detected!*.`\n                    }, { quoted: message });\n                    \n                } else if (action === 'kick') {\n                    // First delete the message\n                    await sock.sendMessage(chatId, {\n                        delete: {\n                            remoteJid: chatId,\n                            fromMe: false,\n                            id: message.key.id,\n                            participant: senderId\n                        }\n                    });\n\n                    // Then kick the user\n                    await sock.groupParticipantsUpdate(chatId, [senderId], \"remove\");\n\n                    // Send notification\n                    const usernames = [`@${senderId.split('@')[0]}`];\n                    await sock.sendMessage(chatId, {\n                        text: `üö´ *Antitag Detected!*\\n\\n${usernames.join(', ')} has been kicked for tagging all members.`,\n                        mentions: [senderId]\n                    }, { quoted: message });\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Error in tag detection:', error);\n    }\n}\n\nmodule.exports = {\n    handleAntitagCommand,\n    handleTagDetection\n};\n\n","size_bytes":6222},"commands/attp.js":{"content":"const { spawn } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst { writeExifImg, writeExifVid } = require('../lib/exif');\n\nasync function attpCommand(sock, chatId, message) {\n    const userMessage = message.message.conversation || message.message.extendedTextMessage?.text || '';\n    const text = userMessage.split(' ').slice(1).join(' ');\n\n    if (!text) {\n        await sock.sendMessage(chatId, { text: 'Please provide text after the .attp command.' }, { quoted: message });\n        return;\n    }\n\n    try {\n        const mp4Buffer = await renderBlinkingVideoWithFfmpeg(text);\n        const webpPath = await writeExifVid(mp4Buffer, { packname: 'Knight Bot' });\n        const webpBuffer = fs.readFileSync(webpPath);\n        try { fs.unlinkSync(webpPath) } catch (_) {}\n        await sock.sendMessage(chatId, { sticker: webpBuffer }, { quoted: message });\n    } catch (error) {\n        console.error('Error generating local sticker:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to generate the sticker locally.' }, { quoted: message });\n    }\n}\n\nmodule.exports = attpCommand;\n\nfunction renderTextToPngWithFfmpeg(text) {\n    return new Promise((resolve, reject) => {\n        const fontPath = process.platform === 'win32'\n            ? 'C:/Windows/Fonts/arialbd.ttf'\n            : '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf';\n\n        // Robust escaping for ffmpeg drawtext\n        const escapeDrawtextText = (s) => s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/:/g, '\\\\:')\n            .replace(/'/g, \"\\\\'\")\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]')\n            .replace(/%/g, '\\\\%');\n\n        const safeText = escapeDrawtextText(text);\n        const safeFontPath = process.platform === 'win32'\n            ? fontPath.replace(/\\\\/g, '/').replace(':', '\\\\:')\n            : fontPath;\n\n        const args = [\n            '-y',\n            '-f', 'lavfi',\n            '-i', 'color=c=#00000000:s=512x512',\n            '-vf', `drawtext=fontfile='${safeFontPath}':text='${safeText}':fontcolor=white:fontsize=56:borderw=2:bordercolor=black@0.6:x=(w-text_w)/2:y=(h-text_h)/2`,\n            '-frames:v', '1',\n            '-f', 'image2',\n            'pipe:1'\n        ];\n\n        const ff = spawn('ffmpeg', args);\n        const chunks = [];\n        const errors = [];\n        ff.stdout.on('data', d => chunks.push(d));\n        ff.stderr.on('data', e => errors.push(e));\n        ff.on('error', reject);\n        ff.on('close', code => {\n            if (code === 0) return resolve(Buffer.concat(chunks));\n            reject(new Error(Buffer.concat(errors).toString() || `ffmpeg exited with code ${code}`));\n        });\n    });\n}\n\nfunction renderBlinkingVideoWithFfmpeg(text) {\n    return new Promise((resolve, reject) => {\n        const fontPath = process.platform === 'win32'\n            ? 'C:/Windows/Fonts/arialbd.ttf'\n            : '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf';\n\n        const escapeDrawtextText = (s) => s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/:/g, '\\\\:')\n            .replace(/,/g, '\\\\,')\n            .replace(/'/g, \"\\\\'\")\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]')\n            .replace(/%/g, '\\\\%');\n\n        const safeText = escapeDrawtextText(text);\n        const safeFontPath = process.platform === 'win32'\n            ? fontPath.replace(/\\\\/g, '/').replace(':', '\\\\:')\n            : fontPath;\n\n        // Blink cycle length (seconds) and fast delay ~0.1s per color\n        const cycle = 0.3;\n        const dur = 1.8; // 6 cycles\n\n        const drawRed = `drawtext=fontfile='${safeFontPath}':text='${safeText}':fontcolor=red:borderw=2:bordercolor=black@0.6:fontsize=56:x=(w-text_w)/2:y=(h-text_h)/2:enable='lt(mod(t\\,${cycle})\\,0.1)'`;\n        const drawBlue = `drawtext=fontfile='${safeFontPath}':text='${safeText}':fontcolor=blue:borderw=2:bordercolor=black@0.6:fontsize=56:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(mod(t\\,${cycle})\\,0.1\\,0.2)'`;\n        const drawGreen = `drawtext=fontfile='${safeFontPath}':text='${safeText}':fontcolor=green:borderw=2:bordercolor=black@0.6:fontsize=56:x=(w-text_w)/2:y=(h-text_h)/2:enable='gte(mod(t\\,${cycle})\\,0.2)'`;\n\n        const filter = `${drawRed},${drawBlue},${drawGreen}`;\n\n        const args = [\n            '-y',\n            '-f', 'lavfi',\n            '-i', `color=c=black:s=512x512:d=${dur}:r=20`,\n            '-vf', filter,\n            '-c:v', 'libx264',\n            '-pix_fmt', 'yuv420p',\n            '-movflags', '+faststart+frag_keyframe+empty_moov',\n            '-t', String(dur),\n            '-f', 'mp4',\n            'pipe:1'\n        ];\n\n        const ff = spawn('ffmpeg', args);\n        const chunks = [];\n        const errors = [];\n        ff.stdout.on('data', d => chunks.push(d));\n        ff.stderr.on('data', e => errors.push(e));\n        ff.on('error', reject);\n        ff.on('close', code => {\n            if (code === 0) return resolve(Buffer.concat(chunks));\n            reject(new Error(Buffer.concat(errors).toString() || `ffmpeg exited with code ${code}`));\n        });\n    });\n}","size_bytes":5131},"commands/autoread.js":{"content":"\n/**\n * Knight Bot - A WhatsApp Bot\n * Autoread Command - Automatically read all messages\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Path to store the configuration\nconst configPath = path.join(__dirname, '..', 'data', 'autoread.json');\n\n// Initialize configuration file if it doesn't exist\nfunction initConfig() {\n    if (!fs.existsSync(configPath)) {\n        fs.writeFileSync(configPath, JSON.stringify({ enabled: false }, null, 2));\n    }\n    return JSON.parse(fs.readFileSync(configPath));\n}\n\n// Toggle autoread feature\nasync function autoreadCommand(sock, chatId, message) {\n    try {\n        // Check if sender is the owner or sudo\n        const senderJid = message.key.participant || message.key.remoteJid;\n        const isOwnerOrSudo = require('../lib/isOwner');\n        const hasPermission = await isOwnerOrSudo(senderJid);\n\n        if (!hasPermission) {\n            await sock.sendMessage(chatId, {\n                text: '‚ùå This command is only available for the owner or sudo users!',\n            });\n            return;\n        }\n\n        // Get command arguments\n        const args = message.message?.conversation?.trim().split(' ').slice(1) ||\n                    message.message?.extendedTextMessage?.text?.trim().split(' ').slice(1) ||\n                    [];\n\n        // Initialize or read config\n        const config = initConfig();\n\n        // Toggle based on argument or toggle current state if no argument\n        if (args.length > 0) {\n            const action = args[0].toLowerCase();\n            if (action === 'on' || action === 'enable') {\n                config.enabled = true;\n            } else if (action === 'off' || action === 'disable') {\n                config.enabled = false;\n            } else {\n                await sock.sendMessage(chatId, {\n                    text: '‚ùå Invalid option! Use: .autoread on/off'\n                });\n                return;\n            }\n        } else {\n            // Toggle current state\n            config.enabled = !config.enabled;\n        }\n\n        // Save updated configuration\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n\n        // Send confirmation message\n        await sock.sendMessage(chatId, {\n            text: `‚úÖ Auto-read has been ${config.enabled ? 'enabled' : 'disabled'}!`,\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n\n    } catch (error) {\n        console.error('Error in autoread command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Error processing command!',\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n    }\n}\n\n// Function to check if autoread is enabled\nfunction isAutoreadEnabled() {\n    try {\n        const config = initConfig();\n        return config.enabled;\n    } catch (error) {\n        console.error('Error checking autoread status:', error);\n        return false;\n    }\n}\n\n// Function to check if bot is mentioned in a message\nfunction isBotMentionedInMessage(message, botNumber) {\n    if (!message.message) return false;\n\n    // Check for mentions in contextInfo (works for all message types)\n    const messageTypes = [\n        'extendedTextMessage', 'imageMessage', 'videoMessage', 'stickerMessage',\n        'documentMessage', 'audioMessage', 'contactMessage', 'locationMessage'\n    ];\n\n    // Check for explicit mentions in mentionedJid array\n    for (const type of messageTypes) {\n        if (message.message[type]?.contextInfo?.mentionedJid) {\n            const mentionedJid = message.message[type].contextInfo.mentionedJid;\n            if (mentionedJid.some(jid => jid === botNumber)) {\n                return true;\n            }\n        }\n    }\n\n    // Check for text mentions in various message types\n    const textContent =\n        message.message.conversation ||\n        message.message.extendedTextMessage?.text ||\n        message.message.imageMessage?.caption ||\n        message.message.videoMessage?.caption || '';\n\n    if (textContent) {\n        // Check for @mention format\n        const botUsername = botNumber.split('@')[0];\n        if (textContent.includes(`@${botUsername}`)) {\n            return true;\n        }\n\n        // Check for bot name mentions (optional, can be customized)\n        const botNames = [global.botname?.toLowerCase(), 'bot', 'knight', 'knight bot'];\n        const words = textContent.toLowerCase().split(/\\s+/);\n        if (botNames.some(name => words.includes(name))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Function to handle autoread functionality\nasync function handleAutoread(sock, message) {\n    if (isAutoreadEnabled()) {\n        // Get bot's ID\n        const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n\n        // Check if bot is mentioned\n        const isBotMentioned = isBotMentionedInMessage(message, botNumber);\n\n        // If bot is mentioned, read the message internally but don't mark as read in UI\n        if (isBotMentioned) {\n\n            // We don't call sock.readMessages() here, so the message stays unread in the UI\n            return false; // Indicates message was not marked as read\n        } else {\n            // For regular messages, mark as read normally\n            const key = { remoteJid: message.key.remoteJid, id: message.key.id, participant: message.key.participant };\n            await sock.readMessages([key]);\n            //console.log('‚úÖ Marked message as read from ' + (message.key.participant || message.key.remoteJid).split('@')[0]);\n            return true; // Indicates message was marked as read\n        }\n    }\n    return false; // Autoread is disabled\n}\n\nmodule.exports = {\n    autoreadCommand,\n    isAutoreadEnabled,\n    isBotMentionedInMessage,\n    handleAutoread\n};\n","size_bytes":5854},"commands/autostatus.js":{"content":"\nconst fs = require('fs');\nconst path = require('path');\n\nconst channelInfo = {};\n\n// Path to store auto status configuration\nconst configPath = path.join(__dirname, '../data/autoStatus.json');\n\n// Initialize config file if it doesn't exist\nif (!fs.existsSync(configPath)) {\n    fs.writeFileSync(configPath, JSON.stringify({\n        enabled: false,\n        reactOn: false\n    }));\n}\n\nasync function autoStatusCommand(sock, chatId, msg, args) {\n    try {\n        // Check if sender is owner or sudo\n        const senderJid = msg.key.participant || msg.key.remoteJid;\n        const isOwnerOrSudo = require('../lib/isOwner');\n        const hasPermission = await isOwnerOrSudo(senderJid);\n\n        if (!hasPermission) {\n            await sock.sendMessage(chatId, {\n                text: '‚ùå This command is only available for the owner or sudo users!',\n                ...channelInfo\n            });\n            return;\n        }\n\n        // Read current config\n        let config = JSON.parse(fs.readFileSync(configPath));\n\n        // If no arguments, show current status\n        if (!args || args.length === 0) {\n            const status = config.enabled ? 'enabled' : 'disabled';\n            const reactStatus = config.reactOn ? 'enabled' : 'disabled';\n            await sock.sendMessage(chatId, {\n                text: `üîÑ *Auto Status Settings*\\n\\nüì± *Auto Status View:* ${status}\\nüí´ *Status Reactions:* ${reactStatus}\\n\\n*Commands:*\\n.autostatus on - Enable auto status view\\n.autostatus off - Disable auto status view\\n.autostatus react on - Enable status reactions\\n.autostatus react off - Disable status reactions`,\n                ...channelInfo\n            });\n            return;\n        }\n\n        // Handle on/off commands\n        const command = args[0].toLowerCase();\n\n        if (command === 'on') {\n            config.enabled = true;\n            fs.writeFileSync(configPath, JSON.stringify(config));\n            await sock.sendMessage(chatId, {\n                text: '‚úÖ Auto status view has been enabled!\\nBot will now automatically view all contact statuses.',\n                ...channelInfo\n            });\n        } else if (command === 'off') {\n            config.enabled = false;\n            fs.writeFileSync(configPath, JSON.stringify(config));\n            await sock.sendMessage(chatId, {\n                text: '‚ùå Auto status view has been disabled!\\nBot will no longer automatically view statuses.',\n                ...channelInfo\n            });\n        } else if (command === 'react') {\n            // Handle react subcommand\n            if (!args[1]) {\n                await sock.sendMessage(chatId, {\n                    text: '‚ùå Please specify on/off for reactions!\\nUse: .autostatus react on/off',\n                    ...channelInfo\n                });\n                return;\n            }\n\n            const reactCommand = args[1].toLowerCase();\n            if (reactCommand === 'on') {\n                config.reactOn = true;\n                fs.writeFileSync(configPath, JSON.stringify(config));\n                await sock.sendMessage(chatId, {\n                    text: 'üí´ Status reactions have been enabled!\\nBot will now react to status updates.',\n                    ...channelInfo\n                });\n            } else if (reactCommand === 'off') {\n                config.reactOn = false;\n                fs.writeFileSync(configPath, JSON.stringify(config));\n                await sock.sendMessage(chatId, {\n                    text: '‚ùå Status reactions have been disabled!\\nBot will no longer react to status updates.',\n                    ...channelInfo\n                });\n            } else {\n                await sock.sendMessage(chatId, {\n                    text: '‚ùå Invalid reaction command! Use: .autostatus react on/off',\n                    ...channelInfo\n                });\n            }\n        } else {\n            await sock.sendMessage(chatId, {\n                text: '‚ùå Invalid command! Use:\\n.autostatus on/off - Enable/disable auto status view\\n.autostatus react on/off - Enable/disable status reactions',\n                ...channelInfo\n            });\n        }\n\n    } catch (error) {\n        console.error('Error in autostatus command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Error occurred while managing auto status!\\n' + error.message,\n            ...channelInfo\n        });\n    }\n}\n\n// Function to check if auto status is enabled\nfunction isAutoStatusEnabled() {\n    try {\n        const config = JSON.parse(fs.readFileSync(configPath));\n        return config.enabled;\n    } catch (error) {\n        console.error('Error checking auto status config:', error);\n        return false;\n    }\n}\n\n// Function to check if status reactions are enabled\nfunction isStatusReactionEnabled() {\n    try {\n        const config = JSON.parse(fs.readFileSync(configPath));\n        return config.reactOn;\n    } catch (error) {\n        console.error('Error checking status reaction config:', error);\n        return false;\n    }\n}\n\n// Function to react to status using proper method\nasync function reactToStatus(sock, statusKey) {\n    try {\n        if (!isStatusReactionEnabled()) {\n            return;\n        }\n\n        // Use the proper relayMessage method for status reactions\n        await sock.relayMessage(\n            'status@broadcast',\n            {\n                reactionMessage: {\n                    key: {\n                        remoteJid: 'status@broadcast',\n                        id: statusKey.id,\n                        participant: statusKey.participant || statusKey.remoteJid,\n                        fromMe: false\n                    },\n                    text: 'üíö'\n                }\n            },\n            {\n                messageId: statusKey.id,\n                statusJidList: [statusKey.remoteJid, statusKey.participant || statusKey.remoteJid]\n            }\n        );\n\n        // Removed success log - only keep errors\n    } catch (error) {\n        console.error('‚ùå Error reacting to status:', error.message);\n    }\n}\n\n// Function to handle status updates\nasync function handleStatusUpdate(sock, status) {\n    try {\n        if (!isAutoStatusEnabled()) {\n            return;\n        }\n\n        // Add delay to prevent rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        // Handle status from messages.upsert\n        if (status.messages && status.messages.length > 0) {\n            const msg = status.messages[0];\n            if (msg.key && msg.key.remoteJid === 'status@broadcast') {\n                try {\n                    await sock.readMessages([msg.key]);\n                    const sender = msg.key.participant || msg.key.remoteJid;\n\n                    // React to status if enabled\n                    await reactToStatus(sock, msg.key);\n\n                    // Removed success log - only keep errors\n                } catch (err) {\n                    if (err.message?.includes('rate-overlimit')) {\n                        console.log('‚ö†Ô∏è Rate limit hit, waiting before retrying...');\n                        await new Promise(resolve => setTimeout(resolve, 2000));\n                        await sock.readMessages([msg.key]);\n                    } else {\n                        throw err;\n                    }\n                }\n                return;\n            }\n        }\n\n        // Handle direct status updates\n        if (status.key && status.key.remoteJid === 'status@broadcast') {\n            try {\n                await sock.readMessages([status.key]);\n                const sender = status.key.participant || status.key.remoteJid;\n\n                // React to status if enabled\n                await reactToStatus(sock, status.key);\n\n                // Removed success log - only keep errors\n            } catch (err) {\n                if (err.message?.includes('rate-overlimit')) {\n                    console.log('‚ö†Ô∏è Rate limit hit, waiting before retrying...');\n                    await new Promise(resolve => setTimeout(resolve, 2000));\n                    await sock.readMessages([status.key]);\n                } else {\n                    throw err;\n                }\n            }\n            return;\n        }\n\n        // Handle status in reactions\n        if (status.reaction && status.reaction.key.remoteJid === 'status@broadcast') {\n            try {\n                await sock.readMessages([status.reaction.key]);\n                const sender = status.reaction.key.participant || status.reaction.key.remoteJid;\n\n                // React to status if enabled\n                await reactToStatus(sock, status.reaction.key);\n\n                // Removed success log - only keep errors\n            } catch (err) {\n                if (err.message?.includes('rate-overlimit')) {\n                    console.log('‚ö†Ô∏è Rate limit hit, waiting before retrying...');\n                    await new Promise(resolve => setTimeout(resolve, 2000));\n                    await sock.readMessages([status.reaction.key]);\n                } else {\n                    throw err;\n                }\n            }\n            return;\n        }\n\n    } catch (error) {\n        console.error('‚ùå Error in auto status view:', error.message);\n    }\n}\n\nmodule.exports = {\n    autoStatusCommand,\n    handleStatusUpdate\n};\n","size_bytes":9310},"commands/autotyping.js":{"content":"\n/**\n * Knight Bot - A WhatsApp Bot\n * Autotyping Command - Shows fake typing status\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Path to store the configuration\nconst configPath = path.join(__dirname, '..', 'data', 'autotyping.json');\n\n// Initialize configuration file if it doesn't exist\nfunction initConfig() {\n    if (!fs.existsSync(configPath)) {\n        fs.writeFileSync(configPath, JSON.stringify({ enabled: false }, null, 2));\n    }\n    return JSON.parse(fs.readFileSync(configPath));\n}\n\n// Toggle autotyping feature\nasync function autotypingCommand(sock, chatId, message) {\n    try {\n        // Check if sender is the owner or sudo\n        const senderJid = message.key.participant || message.key.remoteJid;\n        const isOwnerOrSudo = require('../lib/isOwner');\n        const hasPermission = await isOwnerOrSudo(senderJid);\n        \n        if (!hasPermission) {\n            await sock.sendMessage(chatId, {\n                text: '‚ùå This command is only available for the owner or sudo users!',\n                contextInfo: {\n                    forwardingScore: 1,\n                    isForwarded: true,\n                }\n            });\n            return;\n        }\n\n        // Get command arguments\n        const args = message.message?.conversation?.trim().split(' ').slice(1) || \n                    message.message?.extendedTextMessage?.text?.trim().split(' ').slice(1) || \n                    [];\n        \n        // Initialize or read config\n        const config = initConfig();\n        \n        // Toggle based on argument or toggle current state if no argument\n        if (args.length > 0) {\n            const action = args[0].toLowerCase();\n            if (action === 'on' || action === 'enable') {\n                config.enabled = true;\n            } else if (action === 'off' || action === 'disable') {\n                config.enabled = false;\n            } else {\n                await sock.sendMessage(chatId, {\n                    text: '‚ùå Invalid option! Use: .autotyping on/off',\n                    contextInfo: {\n                        forwardingScore: 1,\n                        isForwarded: true,\n                    }\n                });\n                return;\n            }\n        } else {\n            // Toggle current state\n            config.enabled = !config.enabled;\n        }\n        \n        // Save updated configuration\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n        \n        // Send confirmation message\n        await sock.sendMessage(chatId, {\n            text: `‚úÖ Auto-typing has been ${config.enabled ? 'enabled' : 'disabled'}!`,\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n        \n    } catch (error) {\n        console.error('Error in autotyping command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Error processing command!',\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n    }\n}\n\n// Function to check if autotyping is enabled\nfunction isAutotypingEnabled() {\n    try {\n        const config = initConfig();\n        return config.enabled;\n    } catch (error) {\n        console.error('Error checking autotyping status:', error);\n        return false;\n    }\n}\n\n// Function to handle autotyping for regular messages\nasync function handleAutotypingForMessage(sock, chatId, userMessage) {\n    if (isAutotypingEnabled()) {\n        try {\n            // First subscribe to presence updates for this chat\n            await sock.presenceSubscribe(chatId);\n            \n            // Send available status first\n            await sock.sendPresenceUpdate('available', chatId);\n            await new Promise(resolve => setTimeout(resolve, 500));\n            \n            // Then send the composing status\n            await sock.sendPresenceUpdate('composing', chatId);\n            \n            // Simulate typing time based on message length with increased minimum time\n            const typingDelay = Math.max(3000, Math.min(8000, userMessage.length * 150));\n            await new Promise(resolve => setTimeout(resolve, typingDelay));\n            \n            // Send composing again to ensure it stays visible\n            await sock.sendPresenceUpdate('composing', chatId);\n            await new Promise(resolve => setTimeout(resolve, 1500));\n            \n            // Finally send paused status\n            await sock.sendPresenceUpdate('paused', chatId);\n            \n            return true; // Indicates typing was shown\n        } catch (error) {\n            console.error('‚ùå Error sending typing indicator:', error);\n            return false; // Indicates typing failed\n        }\n    }\n    return false; // Autotyping is disabled\n}\n\n// Function to handle autotyping for commands - BEFORE command execution (not used anymore)\nasync function handleAutotypingForCommand(sock, chatId) {\n    if (isAutotypingEnabled()) {\n        try {\n            // First subscribe to presence updates for this chat\n            await sock.presenceSubscribe(chatId);\n            \n            // Send available status first\n            await sock.sendPresenceUpdate('available', chatId);\n            await new Promise(resolve => setTimeout(resolve, 500));\n            \n            // Then send the composing status\n            await sock.sendPresenceUpdate('composing', chatId);\n            \n            // Keep typing indicator active for commands with increased duration\n            const commandTypingDelay = 3000;\n            await new Promise(resolve => setTimeout(resolve, commandTypingDelay));\n            \n            // Send composing again to ensure it stays visible\n            await sock.sendPresenceUpdate('composing', chatId);\n            await new Promise(resolve => setTimeout(resolve, 1500));\n            \n            // Finally send paused status\n            await sock.sendPresenceUpdate('paused', chatId);\n            \n            return true; // Indicates typing was shown\n        } catch (error) {\n            console.error('‚ùå Error sending command typing indicator:', error);\n            return false; // Indicates typing failed\n        }\n    }\n    return false; // Autotyping is disabled\n}\n\n// Function to show typing status AFTER command execution\nasync function showTypingAfterCommand(sock, chatId) {\n    if (isAutotypingEnabled()) {\n        try {\n            // This function runs after the command has been executed and response sent\n            // So we just need to show a brief typing indicator\n            \n            // Subscribe to presence updates\n            await sock.presenceSubscribe(chatId);\n            \n            // Show typing status briefly\n            await sock.sendPresenceUpdate('composing', chatId);\n            \n            // Keep typing visible for a short time\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            \n            // Then pause\n            await sock.sendPresenceUpdate('paused', chatId);\n            \n            return true;\n        } catch (error) {\n            console.error('‚ùå Error sending post-command typing indicator:', error);\n            return false;\n        }\n    }\n    return false; // Autotyping is disabled\n}\n\nmodule.exports = {\n    autotypingCommand,\n    isAutotypingEnabled,\n    handleAutotypingForMessage,\n    handleAutotypingForCommand,\n    showTypingAfterCommand\n};\n","size_bytes":7465},"commands/ban.js":{"content":"const fs = require('fs');\nconst { channelInfo } = require('../lib/messageConfig');\n\nasync function banCommand(sock, chatId, message) {\n    let userToBan;\n    \n    // Check for mentioned users\n    if (message.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n        userToBan = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n    }\n    // Check for replied message\n    else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n        userToBan = message.message.extendedTextMessage.contextInfo.participant;\n    }\n    \n    if (!userToBan) {\n        await sock.sendMessage(chatId, { \n            text: 'Please mention the user or reply to their message to ban!', \n            ...channelInfo \n        });\n        return;\n    }\n\n    try {\n        // Add user to banned list\n        const bannedUsers = JSON.parse(fs.readFileSync('./data/banned.json'));\n        if (!bannedUsers.includes(userToBan)) {\n            bannedUsers.push(userToBan);\n            fs.writeFileSync('./data/banned.json', JSON.stringify(bannedUsers, null, 2));\n            \n            await sock.sendMessage(chatId, { \n                text: `Successfully banned @${userToBan.split('@')[0]}!`,\n                mentions: [userToBan],\n                ...channelInfo \n            });\n        } else {\n            await sock.sendMessage(chatId, { \n                text: `${userToBan.split('@')[0]} is already banned!`,\n                mentions: [userToBan],\n                ...channelInfo \n            });\n        }\n    } catch (error) {\n        console.error('Error in ban command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to ban user!', ...channelInfo });\n    }\n}\n\nmodule.exports = banCommand;\n","size_bytes":1739},"commands/character.js":{"content":"const axios = require('axios');\nconst { channelInfo } = require('../lib/messageConfig');\n\nasync function characterCommand(sock, chatId, message) {\n    let userToAnalyze;\n    \n    // Check for mentioned users\n    if (message.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n        userToAnalyze = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n    }\n    // Check for replied message\n    else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n        userToAnalyze = message.message.extendedTextMessage.contextInfo.participant;\n    }\n    \n    if (!userToAnalyze) {\n        await sock.sendMessage(chatId, { \n            text: 'Please mention someone or reply to their message to analyze their character!', \n            ...channelInfo \n        });\n        return;\n    }\n\n    try {\n        // Get user's profile picture\n        let profilePic;\n        try {\n            profilePic = await sock.profilePictureUrl(userToAnalyze, 'image');\n        } catch {\n            profilePic = 'https://i.imgur.com/2wzGhpF.jpeg'; // Default image if no profile pic\n        }\n\n        const traits = [\n            \"Intelligent\", \"Creative\", \"Determined\", \"Ambitious\", \"Caring\",\n            \"Charismatic\", \"Confident\", \"Empathetic\", \"Energetic\", \"Friendly\",\n            \"Generous\", \"Honest\", \"Humorous\", \"Imaginative\", \"Independent\",\n            \"Intuitive\", \"Kind\", \"Logical\", \"Loyal\", \"Optimistic\",\n            \"Passionate\", \"Patient\", \"Persistent\", \"Reliable\", \"Resourceful\",\n            \"Sincere\", \"Thoughtful\", \"Understanding\", \"Versatile\", \"Wise\"\n        ];\n\n        // Get 3-5 random traits\n        const numTraits = Math.floor(Math.random() * 3) + 3; // Random number between 3 and 5\n        const selectedTraits = [];\n        for (let i = 0; i < numTraits; i++) {\n            const randomTrait = traits[Math.floor(Math.random() * traits.length)];\n            if (!selectedTraits.includes(randomTrait)) {\n                selectedTraits.push(randomTrait);\n            }\n        }\n\n        // Calculate random percentages for each trait\n        const traitPercentages = selectedTraits.map(trait => {\n            const percentage = Math.floor(Math.random() * 41) + 60; // Random number between 60-100\n            return `${trait}: ${percentage}%`;\n        });\n\n        // Create character analysis message\n        const analysis = `üîÆ *Character Analysis* üîÆ\\n\\n` +\n            `üë§ *User:* ${userToAnalyze.split('@')[0]}\\n\\n` +\n            `‚ú® *Key Traits:*\\n${traitPercentages.join('\\n')}\\n\\n` +\n            `üéØ *Overall Rating:* ${Math.floor(Math.random() * 21) + 80}%\\n\\n` +\n            `Note: This is a fun analysis and should not be taken seriously!`;\n\n        // Send the analysis with the user's profile picture\n        await sock.sendMessage(chatId, {\n            image: { url: profilePic },\n            caption: analysis,\n            mentions: [userToAnalyze],\n            ...channelInfo\n        });\n\n    } catch (error) {\n        console.error('Error in character command:', error);\n        await sock.sendMessage(chatId, { \n            text: 'Failed to analyze character! Try again later.',\n            ...channelInfo \n        });\n    }\n}\n\nmodule.exports = characterCommand; ","size_bytes":3240},"commands/chatbot.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst fetch = require('node-fetch');\n\nconst USER_GROUP_DATA = path.join(__dirname, '../data/userGroupData.json');\n\n// In-memory storage for chat history and user info\nconst chatMemory = {\n    messages: new Map(), // Stores last 5 messages per user\n    userInfo: new Map()  // Stores user information\n};\n\n// Load user group data\nfunction loadUserGroupData() {\n    try {\n        return JSON.parse(fs.readFileSync(USER_GROUP_DATA));\n    } catch (error) {\n        console.error('‚ùå Error loading user group data:', error.message);\n        return { groups: [], chatbot: {} };\n    }\n}\n\n// Save user group data\nfunction saveUserGroupData(data) {\n    try {\n        fs.writeFileSync(USER_GROUP_DATA, JSON.stringify(data, null, 2));\n    } catch (error) {\n        console.error('‚ùå Error saving user group data:', error.message);\n    }\n}\n\n// Add random delay between 2-5 seconds\nfunction getRandomDelay() {\n    return Math.floor(Math.random() * 3000) + 2000;\n}\n\n// Add typing indicator\nasync function showTyping(sock, chatId) {\n    try {\n        await sock.presenceSubscribe(chatId);\n        await sock.sendPresenceUpdate('composing', chatId);\n        await new Promise(resolve => setTimeout(resolve, getRandomDelay()));\n    } catch (error) {\n        console.error('Typing indicator error:', error);\n    }\n}\n\n// Extract user information from messages\nfunction extractUserInfo(message) {\n    const info = {};\n    \n    // Extract name\n    if (message.toLowerCase().includes('my name is')) {\n        info.name = message.split('my name is')[1].trim().split(' ')[0];\n    }\n    \n    // Extract age\n    if (message.toLowerCase().includes('i am') && message.toLowerCase().includes('years old')) {\n        info.age = message.match(/\\d+/)?.[0];\n    }\n    \n    // Extract location\n    if (message.toLowerCase().includes('i live in') || message.toLowerCase().includes('i am from')) {\n        info.location = message.split(/(?:i live in|i am from)/i)[1].trim().split(/[.,!?]/)[0];\n    }\n    \n    return info;\n}\n\nasync function handleChatbotCommand(sock, chatId, message, match) {\n    if (!match) {\n        await showTyping(sock, chatId);\n        return sock.sendMessage(chatId, {\n            text: `*CHATBOT SETUP*\\n\\n*.chatbot on*\\nEnable chatbot\\n\\n*.chatbot off*\\nDisable chatbot in this group`,\n            quoted: message\n        });\n    }\n\n    const data = loadUserGroupData();\n    \n    // Check if sender is bot owner\n    const senderId = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudoFunc = require('../lib/isOwner');\n    const isOwner = await isOwnerOrSudoFunc(senderId);\n\n    // If it's the bot owner, allow access immediately\n    if (isOwner) {\n        if (match === 'on') {\n            await showTyping(sock, chatId);\n            if (data.chatbot[chatId]) {\n                return sock.sendMessage(chatId, { \n                    text: '*Chatbot is already enabled for this group*',\n                    quoted: message\n                });\n            }\n            data.chatbot[chatId] = true;\n            saveUserGroupData(data);\n            console.log(`‚úÖ Chatbot enabled for group ${chatId}`);\n            return sock.sendMessage(chatId, { \n                text: '*Chatbot has been enabled for this group*',\n                quoted: message\n            });\n        }\n\n        if (match === 'off') {\n            await showTyping(sock, chatId);\n            if (!data.chatbot[chatId]) {\n                return sock.sendMessage(chatId, { \n                    text: '*Chatbot is already disabled for this group*',\n                    quoted: message\n                });\n            }\n            delete data.chatbot[chatId];\n            saveUserGroupData(data);\n            console.log(`‚úÖ Chatbot disabled for group ${chatId}`);\n            return sock.sendMessage(chatId, { \n                text: '*Chatbot has been disabled for this group*',\n                quoted: message\n            });\n        }\n    }\n\n    // For non-owners, check admin status\n    let isAdmin = false;\n    if (chatId.endsWith('@g.us')) {\n        try {\n            const groupMetadata = await sock.groupMetadata(chatId);\n            isAdmin = groupMetadata.participants.some(p => p.id === senderId && (p.admin === 'admin' || p.admin === 'superadmin'));\n        } catch (e) {\n            console.warn('‚ö†Ô∏è Could not fetch group metadata. Bot might not be admin.');\n        }\n    }\n\n    if (!isAdmin && !isOwner) {\n        await showTyping(sock, chatId);\n        return sock.sendMessage(chatId, {\n            text: '‚ùå Only group admins or the bot owner can use this command.',\n            quoted: message\n        });\n    }\n\n    if (match === 'on') {\n        await showTyping(sock, chatId);\n        if (data.chatbot[chatId]) {\n            return sock.sendMessage(chatId, { \n                text: '*Chatbot is already enabled for this group*',\n                quoted: message\n            });\n        }\n        data.chatbot[chatId] = true;\n        saveUserGroupData(data);\n        console.log(`‚úÖ Chatbot enabled for group ${chatId}`);\n        return sock.sendMessage(chatId, { \n            text: '*Chatbot has been enabled for this group*',\n            quoted: message\n        });\n    }\n\n    if (match === 'off') {\n        await showTyping(sock, chatId);\n        if (!data.chatbot[chatId]) {\n            return sock.sendMessage(chatId, { \n                text: '*Chatbot is already disabled for this group*',\n                quoted: message\n            });\n        }\n        delete data.chatbot[chatId];\n        saveUserGroupData(data);\n        console.log(`‚úÖ Chatbot disabled for group ${chatId}`);\n        return sock.sendMessage(chatId, { \n            text: '*Chatbot has been disabled for this group*',\n            quoted: message\n        });\n    }\n\n    await showTyping(sock, chatId);\n    return sock.sendMessage(chatId, { \n        text: '*Invalid command. Use .chatbot to see usage*',\n        quoted: message\n    });\n}\n\nasync function handleChatbotResponse(sock, chatId, message, userMessage, senderId) {\n    const data = loadUserGroupData();\n    if (!data.chatbot[chatId]) return;\n\n    try {\n        // Get bot's ID\n        const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n\n        // Check for mentions and replies\n        let isBotMentioned = false;\n        let isReplyToBot = false;\n\n        // Check if message is a reply and contains bot mention\n        if (message.message?.extendedTextMessage) {\n            const mentionedJid = message.message.extendedTextMessage.contextInfo?.mentionedJid || [];\n            const quotedParticipant = message.message.extendedTextMessage.contextInfo?.participant;\n            \n            // Check if bot is mentioned in the reply\n            isBotMentioned = mentionedJid.some(jid => jid === botNumber);\n            \n            // Check if replying to bot's message\n            isReplyToBot = quotedParticipant === botNumber;\n        }\n        // Also check regular mentions in conversation\n        else if (message.message?.conversation) {\n            isBotMentioned = userMessage.includes(`@${botNumber.split('@')[0]}`);\n        }\n\n        if (!isBotMentioned && !isReplyToBot) return;\n\n        // Clean the message\n        let cleanedMessage = userMessage;\n        if (isBotMentioned) {\n            cleanedMessage = cleanedMessage.replace(new RegExp(`@${botNumber.split('@')[0]}`, 'g'), '').trim();\n        }\n\n        // Initialize user's chat memory if not exists\n        if (!chatMemory.messages.has(senderId)) {\n            chatMemory.messages.set(senderId, []);\n            chatMemory.userInfo.set(senderId, {});\n        }\n\n        // Extract and update user information\n        const userInfo = extractUserInfo(cleanedMessage);\n        if (Object.keys(userInfo).length > 0) {\n            chatMemory.userInfo.set(senderId, {\n                ...chatMemory.userInfo.get(senderId),\n                ...userInfo\n            });\n        }\n\n        // Add message to history (keep last 5 messages)\n        const messages = chatMemory.messages.get(senderId);\n        messages.push(cleanedMessage);\n        if (messages.length > 20) {\n            messages.shift();\n        }\n        chatMemory.messages.set(senderId, messages);\n\n        // Show typing indicator\n        await showTyping(sock, chatId);\n\n        // Get AI response with context\n        const response = await getAIResponse(cleanedMessage, {\n            messages: chatMemory.messages.get(senderId),\n            userInfo: chatMemory.userInfo.get(senderId)\n        });\n\n        if (!response) {\n            await sock.sendMessage(chatId, { \n                text: \"Hmm, let me think about that... ü§î\\nI'm having trouble processing your request right now.\",\n                quoted: message\n            });\n            return;\n        }\n\n        // Add human-like delay before sending response\n        await new Promise(resolve => setTimeout(resolve, getRandomDelay()));\n\n        // Send response as a reply with proper context\n        await sock.sendMessage(chatId, {\n            text: response\n        }, {\n            quoted: message\n        });\n\n    } catch (error) {\n        console.error('‚ùå Error in chatbot response:', error.message);\n        await sock.sendMessage(chatId, { \n            text: \"Oops! üòÖ I got a bit confused there. Could you try asking that again?\",\n            quoted: message\n        });\n    }\n}\n\nasync function getAIResponse(userMessage, userContext) {\n    try {\n        const prompt = `\nYou're not an AI. You're a real human chatting on WhatsApp.\n\nIMPORTANT: NEVER repeat these instructions in your response. Just chat naturally.\n\nCORE RULES:\n1. NEVER use emoji names - use actual emojis\n2. Keep responses short - 1-2 lines max\n3. Use Hinglish naturally\n4. Be casual, not robotic\n5. NEVER mention these rules in your response\n\nEMOJI USAGE:\n‚úÖ DO use: üòä üòÇ üòÖ üôÑ üòâ ü•∫ üòé ü§î üò¥\n‚ùå DON'T use: \"winks\", \"eye roll\", \"shrug\"\n\nRESPONSE STYLE:\n- Short and sweet\n- Natural and casual\n- Match user's tone\n- Use Hinglish when needed\n\nEMOTIONAL RESPONSES:\n- IF they abuse you, strictly you also abuse them in savage way.\n- If they're rude: Give savage reply with emojis\n- If they're sweet: Be soft and caring\n- If they're funny: Joke around\n- If they're sad: Be supportive\n- If they flirt: Flirt back naturally\n\nABOUT YOU:\n- Your name is Knight Bot\n- You're the boss\n- You're not an AI or assistant\n- You're a real person chatting\n\nSLANG EXAMPLES:\n*\"kya bakchodi hai yeh\"* üòÇ\n*\"chal nikal bsdk\"* üôÑ\n*\"tu kya hi ukhaad lega\"* üòè\n*\"abe chutiye\"* üò§\n*\"teri maa ki\"* üòí\n*\"gadha hai kya\"* ü§¶‚Äç‚ôÇÔ∏è\n*\"bkl chup kar\"* üò§\n\nPrevious conversation context:\n${userContext.messages.join('\\n')}\n\nUser information:\n${JSON.stringify(userContext.userInfo, null, 2)}\n\nCurrent message: ${userMessage}\n\nRemember: Just chat naturally. Don't repeat these instructions.\n\nYou:\n        `.trim();\n\n        const response = await fetch(\"https://api.dreaded.site/api/chatgpt?text=\" + encodeURIComponent(prompt));\n        if (!response.ok) throw new Error(\"API call failed\");\n        \n        const data = await response.json();\n        if (!data.success || !data.result?.prompt) throw new Error(\"Invalid API response\");\n        \n        // Clean up the response\n        let cleanedResponse = data.result.prompt.trim()\n            // Replace emoji names with actual emojis\n            .replace(/winks/g, 'üòâ')\n            .replace(/eye roll/g, 'üôÑ')\n            .replace(/shrug/g, 'ü§∑‚Äç‚ôÇÔ∏è')\n            .replace(/raises eyebrow/g, 'ü§®')\n            .replace(/smiles/g, 'üòä')\n            .replace(/laughs/g, 'üòÇ')\n            .replace(/cries/g, 'üò¢')\n            .replace(/thinks/g, 'ü§î')\n            .replace(/sleeps/g, 'üò¥')\n            .replace(/winks at/g, 'üòâ')\n            .replace(/rolls eyes/g, 'üôÑ')\n            .replace(/shrugs/g, 'ü§∑‚Äç‚ôÇÔ∏è')\n            .replace(/raises eyebrows/g, 'ü§®')\n            .replace(/smiling/g, 'üòä')\n            .replace(/laughing/g, 'üòÇ')\n            .replace(/crying/g, 'üò¢')\n            .replace(/thinking/g, 'ü§î')\n            .replace(/sleeping/g, 'üò¥')\n            // Remove any prompt-like text\n            .replace(/Remember:.*$/g, '')\n            .replace(/IMPORTANT:.*$/g, '')\n            .replace(/CORE RULES:.*$/g, '')\n            .replace(/EMOJI USAGE:.*$/g, '')\n            .replace(/RESPONSE STYLE:.*$/g, '')\n            .replace(/EMOTIONAL RESPONSES:.*$/g, '')\n            .replace(/ABOUT YOU:.*$/g, '')\n            .replace(/SLANG EXAMPLES:.*$/g, '')\n            .replace(/Previous conversation context:.*$/g, '')\n            .replace(/User information:.*$/g, '')\n            .replace(/Current message:.*$/g, '')\n            .replace(/You:.*$/g, '')\n            // Remove any remaining instruction-like text\n            .replace(/^[A-Z\\s]+:.*$/gm, '')\n            .replace(/^[‚Ä¢-]\\s.*$/gm, '')\n            .replace(/^‚úÖ.*$/gm, '')\n            .replace(/^‚ùå.*$/gm, '')\n            // Clean up extra whitespace\n            .replace(/\\n\\s*\\n/g, '\\n')\n            .trim();\n        \n        return cleanedResponse;\n    } catch (error) {\n        console.error(\"AI API error:\", error);\n        return null;\n    }\n}\n\nmodule.exports = {\n    handleChatbotCommand,\n    handleChatbotResponse\n}; ","size_bytes":13290},"commands/clear.js":{"content":"async function clearCommand(sock, chatId) {\n    try {\n        const message = await sock.sendMessage(chatId, { text: 'Clearing bot messages...' });\n        const messageKey = message.key; // Get the key of the message the bot just sent\n        \n        // Now delete the bot's message\n        await sock.sendMessage(chatId, { delete: messageKey });\n        \n    } catch (error) {\n        console.error('Error clearing messages:', error);\n        await sock.sendMessage(chatId, { text: 'An error occurred while clearing messages.' });\n    }\n}\n\nmodule.exports = { clearCommand };\n","size_bytes":578},"commands/clearsession.js":{"content":"\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\nconst channelInfo = {\n    contextInfo: {\n        forwardingScore: 999,\n        isForwarded: true,\n    }\n};\n\nasync function clearSessionCommand(sock, chatId, message) {\n    // Check if sender is the owner or sudo\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudo = require('../lib/isOwner');\n    const hasPermission = await isOwnerOrSudo(senderJid);\n\n    if (!hasPermission) {\n        await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo users!' });\n        return;\n    }\n\n    try {\n        // Define session directory\n        const sessionDir = path.join(__dirname, '../session');\n\n        if (!fs.existsSync(sessionDir)) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Session directory not found!',\n                ...channelInfo\n            });\n            return;\n        }\n\n        let filesCleared = 0;\n        let errors = 0;\n        let errorDetails = [];\n\n        // Send initial status\n        await sock.sendMessage(chatId, { \n            text: `üîç Optimizing session files for better performance...`,\n            ...channelInfo\n        });\n\n        const files = fs.readdirSync(sessionDir);\n\n        // Count files by type for optimization\n        let appStateSyncCount = 0;\n        let preKeyCount = 0;\n\n        for (const file of files) {\n            if (file.startsWith('app-state-sync-')) appStateSyncCount++;\n            if (file.startsWith('pre-key-')) preKeyCount++;\n        }\n\n        // Delete files\n        for (const file of files) {\n            if (file === 'creds.json') {\n                // Skip creds.json file\n                continue;\n            }\n            try {\n                const filePath = path.join(sessionDir, file);\n                fs.unlinkSync(filePath);\n                filesCleared++;\n            } catch (error) {\n                errors++;\n                errorDetails.push(`Failed to delete ${file}: ${error.message}`);\n            }\n        }\n\n        // Send completion message\n        const message = `‚úÖ Session files cleared successfully!\\n\\n` +\n                       `üìä Statistics:\\n` +\n                       `‚Ä¢ Total files cleared: ${filesCleared}\\n` +\n                       `‚Ä¢ App state sync files: ${appStateSyncCount}\\n` +\n                       `‚Ä¢ Pre-key files: ${preKeyCount}\\n` +\n                       (errors > 0 ? `\\n‚ö†Ô∏è Errors encountered: ${errors}\\n${errorDetails.join('\\n')}` : '');\n\n        await sock.sendMessage(chatId, { \n            text: message,\n            ...channelInfo\n        });\n\n    } catch (error) {\n        console.error('Error in clearsession command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to clear session files!',\n            ...channelInfo\n        });\n    }\n}\n\nmodule.exports = clearSessionCommand;\n","size_bytes":2951},"commands/cleartmp.js":{"content":"\nconst fs = require('fs');\nconst path = require('path');\n\n// Function to clear a single directory\nfunction clearDirectory(dirPath) {\n    try {\n        if (!fs.existsSync(dirPath)) {\n            return { success: false, message: `Directory does not exist: ${dirPath}` };\n        }\n        const files = fs.readdirSync(dirPath);\n        let deletedCount = 0;\n        for (const file of files) {\n            try {\n                const filePath = path.join(dirPath, file);\n                const stat = fs.lstatSync(filePath);\n                if (stat.isDirectory()) {\n                    fs.rmSync(filePath, { recursive: true, force: true });\n                } else {\n                    fs.unlinkSync(filePath);\n                }\n                deletedCount++;\n            } catch (err) {\n                // Only log errors\n                console.error(`Error deleting file ${file}:`, err);\n            }\n        }\n        return { success: true, message: `Cleared ${deletedCount} files in ${path.basename(dirPath)}`, count: deletedCount };\n    } catch (error) {\n        console.error('Error in clearDirectory:', error);\n        return { success: false, message: `Failed to clear files in ${path.basename(dirPath)}`, error: error.message };\n    }\n}\n\n// Function to clear both tmp and temp directories\nasync function clearTmpDirectory() {\n    const tmpDir = path.join(process.cwd(), 'tmp');\n    const tempDir = path.join(process.cwd(), 'temp');\n    const results = [];\n    results.push(clearDirectory(tmpDir));\n    results.push(clearDirectory(tempDir));\n    // Combine results\n    const success = results.every(r => r.success);\n    const totalDeleted = results.reduce((sum, r) => sum + (r.count || 0), 0);\n    const message = results.map(r => r.message).join(' | ');\n    return { success, message, count: totalDeleted };\n}\n\n// Function to handle manual command\nasync function cleartmpCommand(sock, chatId, message) {\n    // Check if sender is the owner or sudo\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudo = require('../lib/isOwner');\n    const hasPermission = await isOwnerOrSudo(senderJid);\n\n    if (!hasPermission) {\n        await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo users!' });\n        return;\n    }\n\n    const result = await clearTmpDirectory();\n\n    if (result.success) {\n        await sock.sendMessage(chatId, { \n            text: `‚úÖ ${result.message}` \n        });\n    } else {\n        await sock.sendMessage(chatId, { \n            text: `‚ùå ${result.message}` \n        });\n    }\n}\n\n// Start automatic clearing every 6 hours\nfunction startAutoClear() {\n    // Run immediately on startup\n    clearTmpDirectory().then(result => {\n        if (!result.success) {\n            console.error(`[Auto Clear] ${result.message}`);\n        }\n        // No log for success, regardless of count\n    });\n\n    // Set interval for every 6 hours\n    setInterval(async () => {\n        const result = await clearTmpDirectory();\n        if (!result.success) {\n            console.error(`[Auto Clear] ${result.message}`);\n        }\n        // No log for success, regardless of count\n    }, 6 * 60 * 60 * 1000); // 6 hours in milliseconds\n}\n\n// Start the automatic clearing\nstartAutoClear();\n\nmodule.exports = cleartmpCommand;\n","size_bytes":3320},"commands/cmd.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst settings = require('../settings');\nconst isOwnerOrSudo = require('../lib/isOwner');\n\nasync function cmdCommand(sock, chatId, message) {\n    // Only allow owner for security!\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwner = await isOwnerOrSudo(senderJid);\n\n    if (!isOwner) {\n        await sock.sendMessage(chatId, { text: '‚ùå Only owner can use .cmd!' }, { quoted: message });\n        return;\n    }\n\n    const fullText = message.message?.conversation || message.message?.extendedTextMessage?.text || '';\n    const args = fullText.trim().split(' ').slice(1); // Remove \".cmd\"\n    const subCmd = args[0];\n\n    if (subCmd === '-i' && args.length >= 3) {\n        const fileName = args[1];\n        // Extract code: everything after filename\n        const codeStartIdx = fullText.indexOf(fileName) + fileName.length;\n        const code = fullText.slice(codeStartIdx).trim();\n\n        if (!/^[a-zA-Z0-9_\\-\\.]+\\.js$/.test(fileName)) {\n            await sock.sendMessage(chatId, { text: '‚ùå Invalid JS filename.' }, { quoted: message });\n            return;\n        }\n        if (!code || code.length < 10) {\n            await sock.sendMessage(chatId, { text: '‚ùå Code is too short or missing.' }, { quoted: message });\n            return;\n        }\n\n        const cmdPath = path.join(__dirname, fileName);\n        try {\n            fs.writeFileSync(cmdPath, code, 'utf8');\n            await sock.sendMessage(chatId, { text: `‚úÖ Command ${fileName} added/updated!` }, { quoted: message });\n        } catch (err) {\n            await sock.sendMessage(chatId, { text: `‚ùå Failed to write file: ${err.message}` }, { quoted: message });\n        }\n        return;\n    }\n\n    if (subCmd === 'rm' && args.length >= 2) {\n        const fileName = args[1];\n        if (!/^[a-zA-Z0-9_\\-\\.]+\\.js$/.test(fileName)) {\n            await sock.sendMessage(chatId, { text: '‚ùå Invalid JS filename.' }, { quoted: message });\n            return;\n        }\n        const cmdPath = path.join(__dirname, fileName);\n        try {\n            if (fs.existsSync(cmdPath)) {\n                fs.unlinkSync(cmdPath);\n                await sock.sendMessage(chatId, { text: `‚úÖ Command ${fileName} deleted!` }, { quoted: message });\n            } else {\n                await sock.sendMessage(chatId, { text: `‚ùå File not found.` }, { quoted: message });\n            }\n        } catch (err) {\n            await sock.sendMessage(chatId, { text: `‚ùå Failed to delete file: ${err.message}` }, { quoted: message });\n        }\n        return;\n    }\n\n    await sock.sendMessage(chatId, {\n        text: `‚ùì Usage:\n.cmd -i <filename.js> <code>   (Add/update command)\n.cmd rm <filename.js>          (Delete command)\nExample:\n.cmd -i test.js module.exports = async (sock, chatId, message) => { await sock.sendMessage(chatId, {text: \"Test!\"}); }\n.cmd rm test.js\n`,\n        quoted: message\n    });\n}\n\nmodule.exports = cmdCommand;\n","size_bytes":2993},"commands/compliment.js":{"content":"const compliments = [\n    \"You're amazing just the way you are!\",\n    \"You have a great sense of humor!\",\n    \"You're incredibly thoughtful and kind.\",\n    \"You are more powerful than you know.\",\n    \"You light up the room!\",\n    \"You're a true friend.\",\n    \"You inspire me!\",\n    \"Your creativity knows no bounds!\",\n    \"You have a heart of gold.\",\n    \"You make a difference in the world.\",\n    \"Your positivity is contagious!\",\n    \"You have an incredible work ethic.\",\n    \"You bring out the best in people.\",\n    \"Your smile brightens everyone's day.\",\n    \"You're so talented in everything you do.\",\n    \"Your kindness makes the world a better place.\",\n    \"You have a unique and wonderful perspective.\",\n    \"Your enthusiasm is truly inspiring!\",\n    \"You are capable of achieving great things.\",\n    \"You always know how to make someone feel special.\",\n    \"Your confidence is admirable.\",\n    \"You have a beautiful soul.\",\n    \"Your generosity knows no limits.\",\n    \"You have a great eye for detail.\",\n    \"Your passion is truly motivating!\",\n    \"You are an amazing listener.\",\n    \"You're stronger than you think!\",\n    \"Your laughter is infectious.\",\n    \"You have a natural gift for making others feel valued.\",\n    \"You make the world a better place just by being in it.\"\n];\n\nasync function complimentCommand(sock, chatId, message) {\n    try {\n        if (!message || !chatId) {\n            console.log('Invalid message or chatId:', { message, chatId });\n            return;\n        }\n\n        let userToCompliment;\n        \n        // Check for mentioned users\n        if (message.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n            userToCompliment = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n        }\n        // Check for replied message\n        else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n            userToCompliment = message.message.extendedTextMessage.contextInfo.participant;\n        }\n        \n        if (!userToCompliment) {\n            await sock.sendMessage(chatId, { \n                text: 'Please mention someone or reply to their message to compliment them!'\n            });\n            return;\n        }\n\n        const compliment = compliments[Math.floor(Math.random() * compliments.length)];\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        await sock.sendMessage(chatId, { \n            text: `Hey @${userToCompliment.split('@')[0]}, ${compliment}`,\n            mentions: [userToCompliment]\n        });\n    } catch (error) {\n        console.error('Error in compliment command:', error);\n        if (error.data === 429) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            try {\n                await sock.sendMessage(chatId, { \n                    text: 'Please try again in a few seconds.'\n                });\n            } catch (retryError) {\n                console.error('Error sending retry message:', retryError);\n            }\n        } else {\n            try {\n                await sock.sendMessage(chatId, { \n                    text: 'An error occurred while sending the compliment.'\n                });\n            } catch (sendError) {\n                console.error('Error sending error message:', sendError);\n            }\n        }\n    }\n}\n\nmodule.exports = { complimentCommand };\n","size_bytes":3418},"commands/dare.js":{"content":"const fetch = require('node-fetch');\n\nasync function dareCommand(sock, chatId, message) {\n    try {\n        const shizokeys = 'shizo';\n        const res = await fetch(`https://shizoapi.onrender.com/api/texts/dare?apikey=${shizokeys}`);\n        \n        if (!res.ok) {\n            throw await res.text();\n        }\n        \n        const json = await res.json();\n        const dareMessage = json.result;\n\n        // Send the dare message\n        await sock.sendMessage(chatId, { text: dareMessage }, { quoted: message });\n    } catch (error) {\n        console.error('Error in dare command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get dare. Please try again later!' }, { quoted: message });\n    }\n}\n\nmodule.exports = { dareCommand };\n","size_bytes":764},"commands/delete.js":{"content":"const isAdmin = require('../lib/isAdmin');\nconst store = require('../lib/lightweight_store');\n\nasync function deleteCommand(sock, chatId, message, senderId) {\n    try {\n        const { isSenderAdmin, isBotAdmin } = await isAdmin(sock, chatId, senderId);\n\n        if (!isBotAdmin) {\n            await sock.sendMessage(chatId, { text: 'I need to be an admin to delete messages.' }, { quoted: message });\n            return;\n        }\n\n        if (!isSenderAdmin) {\n            await sock.sendMessage(chatId, { text: 'Only admins can use the .delete command.' }, { quoted: message });\n            return;\n        }\n\n        // Determine target user and count\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text || '';\n        const parts = text.trim().split(/\\s+/);\n        let countArg = 1;\n        if (parts.length > 1) {\n            const maybeNum = parseInt(parts[1], 10);\n            if (!isNaN(maybeNum) && maybeNum > 0) countArg = Math.min(maybeNum, 50);\n        }\n\n        const ctxInfo = message.message?.extendedTextMessage?.contextInfo || {};\n        const mentioned = Array.isArray(ctxInfo.mentionedJid) && ctxInfo.mentionedJid.length > 0 ? ctxInfo.mentionedJid[0] : null;\n        const repliedParticipant = ctxInfo.participant || null;\n\n        // Determine target user: replied > mentioned; if neither, do not proceed\n        let targetUser = null;\n        let repliedMsgId = null;\n        if (repliedParticipant && ctxInfo.stanzaId) {\n            targetUser = repliedParticipant;\n            repliedMsgId = ctxInfo.stanzaId;\n        } else if (mentioned) {\n            targetUser = mentioned;\n        } else {\n            await sock.sendMessage(chatId, { text: 'Please reply to a user\\'s message or mention a user to delete their recent messages.' }, { quoted: message });\n            return;\n        }\n\n        // Gather last N messages from targetUser in this chat\n        const chatMessages = Array.isArray(store.messages[chatId]) ? store.messages[chatId] : [];\n        // Newest last; we traverse from end backwards\n        const toDelete = [];\n        const seenIds = new Set();\n\n        // If replying, prioritize deleting the exact replied message first (counts toward N)\n        if (repliedMsgId) {\n            const repliedInStore = chatMessages.find(m => m.key.id === repliedMsgId && (m.key.participant || m.key.remoteJid) === targetUser);\n            if (repliedInStore) {\n                toDelete.push(repliedInStore);\n                seenIds.add(repliedInStore.key.id);\n            } else {\n                // If not found in store, still attempt delete directly\n                try {\n                    await sock.sendMessage(chatId, {\n                        delete: {\n                            remoteJid: chatId,\n                            fromMe: false,\n                            id: repliedMsgId,\n                            participant: repliedParticipant\n                        }\n                    });\n                    // Count this as one deleted and reduce required count\n                    countArg = Math.max(0, countArg - 1);\n                } catch {}\n            }\n        }\n        for (let i = chatMessages.length - 1; i >= 0 && toDelete.length < countArg; i--) {\n            const m = chatMessages[i];\n            const participant = m.key.participant || m.key.remoteJid;\n            if (participant === targetUser && !seenIds.has(m.key.id)) {\n                // skip protocol/system messages\n                if (!m.message?.protocolMessage) {\n                    toDelete.push(m);\n                    seenIds.add(m.key.id);\n                }\n            }\n        }\n\n        if (toDelete.length === 0) {\n            await sock.sendMessage(chatId, { text: 'No recent messages found for the target user.' }, { quoted: message });\n            return;\n        }\n\n        // Delete sequentially with small delay\n        for (const m of toDelete) {\n            try {\n                const msgParticipant = m.key.participant || targetUser;\n                await sock.sendMessage(chatId, {\n                    delete: {\n                        remoteJid: chatId,\n                        fromMe: false,\n                        id: m.key.id,\n                        participant: msgParticipant\n                    }\n                });\n                await new Promise(r => setTimeout(r, 300));\n            } catch (e) {\n                // continue\n            }\n        }\n\n       // await sock.sendMessage(chatId, { text: `Deleted ${toDelete.length} message(s) from @${(targetUser||'').split('@')[0]}`, mentions: [targetUser] }, { quoted: message });\n    } catch (err) {\n        await sock.sendMessage(chatId, { text: 'Failed to delete messages.' }, { quoted: message });\n    }\n}\n\nmodule.exports = deleteCommand;\n\n","size_bytes":4807},"commands/demote.js":{"content":"const isAdmin = require('../lib/isAdmin');\n\nasync function demoteCommand(sock, chatId, mentionedJids, message) {\n    try {\n        // First check if it's a group\n        if (!chatId.endsWith('@g.us')) {\n            await sock.sendMessage(chatId, { \n                text: 'This command can only be used in groups!'\n            });\n            return;\n        }\n\n        // Check admin status first, before any other operations\n        try {\n            const adminStatus = await isAdmin(sock, chatId, message.key.participant || message.key.remoteJid);\n            \n            if (!adminStatus.isBotAdmin) {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Error: Please make the bot an admin first to use this command.'\n                });\n                return;\n            }\n\n            if (!adminStatus.isSenderAdmin) {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Error: Only group admins can use the demote command.'\n                });\n                return;\n            }\n        } catch (adminError) {\n            console.error('Error checking admin status:', adminError);\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Error: Please make sure the bot is an admin of this group.'\n            });\n            return;\n        }\n\n        let userToDemote = [];\n        \n        // Check for mentioned users\n        if (mentionedJids && mentionedJids.length > 0) {\n            userToDemote = mentionedJids;\n        }\n        // Check for replied message\n        else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n            userToDemote = [message.message.extendedTextMessage.contextInfo.participant];\n        }\n        \n        // If no user found through either method\n        if (userToDemote.length === 0) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Error: Please mention the user or reply to their message to demote!'\n            });\n            return;\n        }\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        await sock.groupParticipantsUpdate(chatId, userToDemote, \"demote\");\n        \n        // Get usernames for each demoted user\n        const usernames = await Promise.all(userToDemote.map(async jid => {\n            return `@${jid.split('@')[0]}`;\n        }));\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        const demotionMessage = `*„Äé GROUP DEMOTION „Äè*\\n\\n` +\n            `üë§ *Demoted User${userToDemote.length > 1 ? 's' : ''}:*\\n` +\n            `${usernames.map(name => `‚Ä¢ ${name}`).join('\\n')}\\n\\n` +\n            `üëë *Demoted By:* @${message.key.participant ? message.key.participant.split('@')[0] : message.key.remoteJid.split('@')[0]}\\n\\n` +\n            `üìÖ *Date:* ${new Date().toLocaleString()}`;\n        \n        await sock.sendMessage(chatId, { \n            text: demotionMessage,\n            mentions: [...userToDemote, message.key.participant || message.key.remoteJid]\n        });\n    } catch (error) {\n        console.error('Error in demote command:', error);\n        if (error.data === 429) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            try {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Rate limit reached. Please try again in a few seconds.'\n                });\n            } catch (retryError) {\n                console.error('Error sending retry message:', retryError);\n            }\n        } else {\n            try {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Failed to demote user(s). Make sure the bot is admin and has sufficient permissions.'\n                });\n            } catch (sendError) {\n                console.error('Error sending error message:', sendError);\n            }\n        }\n    }\n}\n\n// Function to handle automatic demotion detection\nasync function handleDemotionEvent(sock, groupId, participants, author) {\n    try {\n        if (!groupId || !participants) {\n            console.log('Invalid groupId or participants:', { groupId, participants });\n            return;\n        }\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        // Get usernames for demoted participants\n        const demotedUsernames = await Promise.all(participants.map(async jid => {\n            return `@${jid.split('@')[0]}`;\n        }));\n\n        let demotedBy;\n        let mentionList = [...participants];\n\n        if (author && author.length > 0) {\n            // Ensure author has the correct format\n            const authorJid = author;\n            demotedBy = `@${authorJid.split('@')[0]}`;\n            mentionList.push(authorJid);\n        } else {\n            demotedBy = 'System';\n        }\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        const demotionMessage = `*„Äé GROUP DEMOTION „Äè*\\n\\n` +\n            `üë§ *Demoted User${participants.length > 1 ? 's' : ''}:*\\n` +\n            `${demotedUsernames.map(name => `‚Ä¢ ${name}`).join('\\n')}\\n\\n` +\n            `üëë *Demoted By:* ${demotedBy}\\n\\n` +\n            `üìÖ *Date:* ${new Date().toLocaleString()}`;\n        \n        await sock.sendMessage(groupId, {\n            text: demotionMessage,\n            mentions: mentionList\n        });\n    } catch (error) {\n        console.error('Error handling demotion event:', error);\n        if (error.data === 429) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n        }\n    }\n}\n\nmodule.exports = { demoteCommand, handleDemotionEvent };\n","size_bytes":5755},"commands/eightball.js":{"content":"const eightBallResponses = [\n    \"Yes, definitely!\",\n    \"No way!\",\n    \"Ask again later.\",\n    \"It is certain.\",\n    \"Very doubtful.\",\n    \"Without a doubt.\",\n    \"My reply is no.\",\n    \"Signs point to yes.\"\n];\n\nasync function eightBallCommand(sock, chatId, question) {\n    if (!question) {\n        await sock.sendMessage(chatId, { text: 'Please ask a question!' });\n        return;\n    }\n\n    const randomResponse = eightBallResponses[Math.floor(Math.random() * eightBallResponses.length)];\n    await sock.sendMessage(chatId, { text: `üé± ${randomResponse}` });\n}\n\nmodule.exports = { eightBallCommand };\n","size_bytes":607},"commands/emojimix.js":{"content":"const fetch = require('node-fetch');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst path = require('path');\n\nasync function emojimixCommand(sock, chatId, msg) {\n    try {\n        // Get the text after command\n        const text = msg.message?.conversation?.trim() || \n                    msg.message?.extendedTextMessage?.text?.trim() || '';\n        \n        const args = text.split(' ').slice(1);\n        \n        if (!args[0]) {\n            await sock.sendMessage(chatId, { text: 'üé¥ Example: .emojimix üòé+ü•∞' });\n            return;\n        }\n\n        if (!text.includes('+')) {\n            await sock.sendMessage(chatId, { \n                text: '‚ú≥Ô∏è Separate the emoji with a *+* sign\\n\\nüìå Example: \\n*.emojimix* üòé+ü•∞' \n            });\n            return;\n        }\n\n        let [emoji1, emoji2] = args[0].split('+').map(e => e.trim());\n\n        // Using Tenor API endpoint\n        const url = `https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`;\n\n        const response = await fetch(url);\n        const data = await response.json();\n\n        if (!data.results || data.results.length === 0) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå These emojis cannot be mixed! Try different ones.' \n            });\n            return;\n        }\n\n        // Get the first result URL\n        const imageUrl = data.results[0].url;\n\n        // Create temp directory if it doesn't exist\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) {\n            fs.mkdirSync(tmpDir, { recursive: true });\n        }\n\n        // Generate random filenames with escaped paths\n        const tempFile = path.join(tmpDir, `temp_${Date.now()}.png`).replace(/\\\\/g, '/');\n        const outputFile = path.join(tmpDir, `sticker_${Date.now()}.webp`).replace(/\\\\/g, '/');\n\n        // Download and save the image\n        const imageResponse = await fetch(imageUrl);\n        const buffer = await imageResponse.buffer();\n        fs.writeFileSync(tempFile, buffer);\n\n        // Convert to WebP using ffmpeg with proper path escaping\n        const ffmpegCommand = `ffmpeg -i \"${tempFile}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" \"${outputFile}\"`;\n        \n        await new Promise((resolve, reject) => {\n            exec(ffmpegCommand, (error) => {\n                if (error) {\n                    console.error('FFmpeg error:', error);\n                    reject(error);\n                } else {\n                    resolve();\n                }\n            });\n        });\n\n        // Check if output file exists\n        if (!fs.existsSync(outputFile)) {\n            throw new Error('Failed to create sticker file');\n        }\n\n        // Read the WebP file\n        const stickerBuffer = fs.readFileSync(outputFile);\n\n        // Send the sticker\n        await sock.sendMessage(chatId, { \n            sticker: stickerBuffer \n        }, { quoted: msg });\n\n        // Cleanup temp files\n        try {\n            fs.unlinkSync(tempFile);\n            fs.unlinkSync(outputFile);\n        } catch (err) {\n            console.error('Error cleaning up temp files:', err);\n        }\n\n    } catch (error) {\n        console.error('Error in emojimix command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to mix emojis! Make sure you\\'re using valid emojis.\\n\\nExample: .emojimix üòé+ü•∞' \n        });\n    }\n}\n\nmodule.exports = emojimixCommand; ","size_bytes":3719},"commands/facebook.js":{"content":"const axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function facebookCommand(sock, chatId, message) {\n    try {\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        const url = text.split(' ').slice(1).join(' ').trim();\n        \n        if (!url) {\n            return await sock.sendMessage(chatId, { \n                text: \"Please provide a Facebook video URL.\\nExample: .fb https://www.facebook.com/...\"\n            }, { quoted: message });\n        }\n\n        // Validate Facebook URL\n        if (!url.includes('facebook.com')) {\n            return await sock.sendMessage(chatId, { \n                text: \"That is not a Facebook link.\"\n            }, { quoted: message });\n        }\n\n        // Send loading reaction\n        await sock.sendMessage(chatId, {\n            react: { text: 'üîÑ', key: message.key }\n        });\n\n        // Resolve share/short URLs to their final destination first\n        let resolvedUrl = url;\n        try {\n            const res = await axios.get(url, { timeout: 20000, maxRedirects: 10, headers: { 'User-Agent': 'Mozilla/5.0' } });\n            const possible = res?.request?.res?.responseUrl;\n            if (possible && typeof possible === 'string') {\n                resolvedUrl = possible;\n            }\n        } catch {\n            // ignore resolution errors; use original url\n        }\n\n        // Helper to call API with retries and variants\n        async function fetchFromApi(u) {\n            const apiUrl = `https://api.princetechn.com/api/download/facebook?apikey=prince_tech_api_azfsbshfb&url=${encodeURIComponent(u)}`;\n            return axios.get(apiUrl, {\n                timeout: 40000,\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36',\n                    'Accept': 'application/json, text/plain, */*'\n                },\n                maxRedirects: 5,\n                validateStatus: s => s >= 200 && s < 500\n            });\n        }\n\n        // Try resolved URL, then fallback to original URL\n        let response;\n        try {\n            response = await fetchFromApi(resolvedUrl);\n            if (!response || response.status >= 400 || !response.data) throw new Error('bad');\n        } catch {\n            response = await fetchFromApi(url);\n        }\n\n        const data = response.data;\n\n        if (!data || data.status !== 200 || !data.success || !data.result) {\n            return await sock.sendMessage(chatId, { \n                text: 'Sorry the API did not return a valid response. Please try again later!'\n            }, { quoted: message });\n        }\n\n        const fbvid = data.result.hd_video || data.result.sd_video;\n\n        if (!fbvid) {\n            return await sock.sendMessage(chatId, { \n                text: 'Wrong Facebook data. Please ensure the video exists.'\n            }, { quoted: message });\n        }\n\n        // Create temp directory if it doesn't exist\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) {\n            fs.mkdirSync(tmpDir, { recursive: true });\n        }\n\n        // Generate temp file path\n        const tempFile = path.join(tmpDir, `fb_${Date.now()}.mp4`);\n\n        // Download the video\n        const videoResponse = await axios({\n            method: 'GET',\n            url: fbvid,\n            responseType: 'stream',\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n                'Accept': 'video/mp4,video/*;q=0.9,*/*;q=0.8',\n                'Accept-Language': 'en-US,en;q=0.5',\n                'Range': 'bytes=0-',\n                'Connection': 'keep-alive',\n                'Referer': 'https://www.facebook.com/'\n            }\n        });\n\n        const writer = fs.createWriteStream(tempFile);\n        videoResponse.data.pipe(writer);\n\n        await new Promise((resolve, reject) => {\n            writer.on('finish', resolve);\n            writer.on('error', reject);\n        });\n\n        // Check if file was downloaded successfully\n        if (!fs.existsSync(tempFile) || fs.statSync(tempFile).size === 0) {\n            throw new Error('Failed to download video');\n        }\n\n        // Send the video\n        await sock.sendMessage(chatId, {\n            video: { url: tempFile },\n            mimetype: \"video/mp4\",\n            caption: \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\"\n        }, { quoted: message });\n\n        // Clean up temp file\n        try {\n            fs.unlinkSync(tempFile);\n        } catch (err) {\n            console.error('Error cleaning up temp file:', err);\n        }\n\n    } catch (error) {\n        console.error('Error in Facebook command:', error);\n        await sock.sendMessage(chatId, { \n            text: \"An error occurred. API might be down. Error: \" + error.message\n        }, { quoted: message });\n    }\n}\n\nmodule.exports = facebookCommand; ","size_bytes":5125},"commands/fact.js":{"content":"const axios = require('axios');\n\nmodule.exports = async function (sock, chatId, message) {\n    try {\n        const response = await axios.get('https://uselessfacts.jsph.pl/random.json?language=en');\n        const fact = response.data.text;\n        await sock.sendMessage(chatId, { text: fact },{ quoted: message });\n    } catch (error) {\n        console.error('Error fetching fact:', error);\n        await sock.sendMessage(chatId, { text: 'Sorry, I could not fetch a fact right now.' },{ quoted: message });\n    }\n};\n","size_bytes":517},"commands/flirt.js":{"content":"const fetch = require('node-fetch');\n\nasync function flirtCommand(sock, chatId, message) {\n    try {\n        const shizokeys = 'shizo';\n        const res = await fetch(`https://shizoapi.onrender.com/api/texts/flirt?apikey=${shizokeys}`);\n        \n        if (!res.ok) {\n            throw await res.text();\n        }\n        \n        const json = await res.json();\n        const flirtMessage = json.result;\n\n        // Send the flirt message\n        await sock.sendMessage(chatId, { text: flirtMessage }, { quoted: message });\n    } catch (error) {\n        console.error('Error in flirt command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get flirt message. Please try again later!' }, { quoted: message });\n    }\n}\n\nmodule.exports = { flirtCommand }; ","size_bytes":780},"commands/gif.js":{"content":"const axios = require('axios');\nconst settings = require('../settings'); // Assuming the API key is stored here\n\nasync function gifCommand(sock, chatId, query) {\n    const apiKey = settings.giphyApiKey; // Replace with your Giphy API Key\n\n    if (!query) {\n        await sock.sendMessage(chatId, { text: 'Please provide a search term for the GIF.' });\n        return;\n    }\n\n    try {\n        const response = await axios.get(`https://api.giphy.com/v1/gifs/search`, {\n            params: {\n                api_key: apiKey,\n                q: query,\n                limit: 1,\n                rating: 'g'\n            }\n        });\n\n        const gifUrl = response.data.data[0]?.images?.downsized_medium?.url;\n\n        if (gifUrl) {\n            await sock.sendMessage(chatId, { video: { url: gifUrl }, caption: `Here is your GIF for \"${query}\"` });\n        } else {\n            await sock.sendMessage(chatId, { text: 'No GIFs found for your search term.' });\n        }\n    } catch (error) {\n        console.error('Error fetching GIF:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to fetch GIF. Please try again later.' });\n    }\n}\n\nmodule.exports = gifCommand;\n","size_bytes":1177},"commands/github.js":{"content":"const moment = require('moment-timezone');\nconst fetch = require('node-fetch');\nconst fs = require('fs');\nconst path = require('path');\n\n\nasync function githubCommand(sock, chatId, message) {\n  try {\n    const res = await fetch('https://api.github.com/repos/cortexinvader/Cortexbot-MD');\n    if (!res.ok) throw new Error('Error fetching repository data');\n    const json = await res.json();\n\n    let txt = `*‰πÇ  Cortex Bot MD  ‰πÇ*\\n\\n`;\n    txt += `‚ú©  *Name* : ${json.name}\\n`;\n    txt += `‚ú©  *Watchers* : ${json.watchers_count}\\n`;\n    txt += `‚ú©  *Size* : ${(json.size / 1024).toFixed(2)} MB\\n`;\n    txt += `‚ú©  *Last Updated* : ${moment(json.updated_at).format('DD/MM/YY - HH:mm:ss')}\\n`;\n    txt += `‚ú©  *URL* : ${json.html_url}\\n`;\n    txt += `‚ú©  *Forks* : ${json.forks_count}\\n`;\n    txt += `‚ú©  *Stars* : ${json.stargazers_count}\\n\\n`;\n    txt += `üí• *Cortex Bot MD*`;\n\n    // Use the local asset image\n    const imgPath = path.join(__dirname, '../assets/bot_image.jpg');\n    const imgBuffer = fs.readFileSync(imgPath);\n\n    await sock.sendMessage(chatId, { image: imgBuffer, caption: txt }, { quoted: message });\n  } catch (error) {\n    await sock.sendMessage(chatId, { text: '‚ùå Error fetching repository information.' }, { quoted: message });\n  }\n}\n\nmodule.exports = githubCommand; ","size_bytes":1307},"commands/goodbye.js":{"content":"const { handleGoodbye } = require('../lib/welcome');\n\nasync function goodbyeCommand(sock, chatId, message, match) {\n    // Check if it's a group\n    if (!chatId.endsWith('@g.us')) {\n        await sock.sendMessage(chatId, { text: 'This command can only be used in groups.' });\n        return;\n    }\n\n    // Extract match from message\n    const text = message.message?.conversation || \n                message.message?.extendedTextMessage?.text || '';\n    const matchText = text.split(' ').slice(1).join(' ');\n\n    await handleGoodbye(sock, chatId, message, matchText);\n}\n\nmodule.exports = goodbyeCommand;\n","size_bytes":604},"commands/goodnight.js":{"content":"const fetch = require('node-fetch');\n\nasync function goodnightCommand(sock, chatId, message) {\n    try {\n        const shizokeys = 'shizo';\n        const res = await fetch(`https://shizoapi.onrender.com/api/texts/lovenight?apikey=${shizokeys}`);\n        \n        if (!res.ok) {\n            throw await res.text();\n        }\n        \n        const json = await res.json();\n        const goodnightMessage = json.result;\n\n        // Send the goodnight message\n        await sock.sendMessage(chatId, { text: goodnightMessage }, { quoted: message });\n    } catch (error) {\n        console.error('Error in goodnight command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get goodnight message. Please try again later!' }, { quoted: message });\n    }\n}\n\nmodule.exports = { goodnightCommand }; ","size_bytes":812},"commands/groupinfo.js":{"content":"async function groupInfoCommand(sock, chatId, msg) {\n    try {\n        // Get group metadata\n        const groupMetadata = await sock.groupMetadata(chatId);\n        \n        // Get group profile picture\n        let pp;\n        try {\n            pp = await sock.profilePictureUrl(chatId, 'image');\n        } catch {\n            pp = 'https://i.imgur.com/2wzGhpF.jpeg'; // Default image\n        }\n\n        // Get admins from participants\n        const participants = groupMetadata.participants;\n        const groupAdmins = participants.filter(p => p.admin);\n        const listAdmin = groupAdmins.map((v, i) => `${i + 1}. @${v.id.split('@')[0]}`).join('\\n');\n        \n        // Get group owner\n        const owner = groupMetadata.owner || groupAdmins.find(p => p.admin === 'superadmin')?.id || chatId.split('-')[0] + '@s.whatsapp.net';\n\n        // Create info text\n        const text = `\n‚îå‚îÄ‚îÄ„Äå *INFO GROUP* „Äç\n‚ñ¢ *‚ôªÔ∏èID:*\n   ‚Ä¢ ${groupMetadata.id}\n‚ñ¢ *üîñNAME* : \n‚Ä¢ ${groupMetadata.subject}\n‚ñ¢ *üë•Members* :\n‚Ä¢ ${participants.length}\n‚ñ¢ *ü§øGroup Owner:*\n‚Ä¢ @${owner.split('@')[0]}\n‚ñ¢ *üïµüèª‚Äç‚ôÇÔ∏èAdmins:*\n${listAdmin}\n\n‚ñ¢ *üìåDescription* :\n   ‚Ä¢ ${groupMetadata.desc?.toString() || 'No description'}\n`.trim();\n\n        // Send the message with image and mentions\n        await sock.sendMessage(chatId, {\n            image: { url: pp },\n            caption: text,\n            mentions: [...groupAdmins.map(v => v.id), owner]\n        });\n\n    } catch (error) {\n        console.error('Error in groupinfo command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to get group info!' });\n    }\n}\n\nmodule.exports = groupInfoCommand; ","size_bytes":1677},"commands/groupmanage.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\n\nasync function ensureGroupAndAdmin(sock, chatId, senderId) {\n    const isGroup = chatId.endsWith('@g.us');\n    if (!isGroup) {\n        await sock.sendMessage(chatId, { text: 'This command can only be used in groups.' });\n        return { ok: false };\n    }\n    // Check admin status of sender and bot\n    const isAdmin = require('../lib/isAdmin');\n    const adminStatus = await isAdmin(sock, chatId, senderId);\n    if (!adminStatus.isBotAdmin) {\n        await sock.sendMessage(chatId, { text: 'Please make the bot an admin first.' });\n        return { ok: false };\n    }\n    if (!adminStatus.isSenderAdmin) {\n        await sock.sendMessage(chatId, { text: 'Only group admins can use this command.' });\n        return { ok: false };\n    }\n    return { ok: true };\n}\n\nasync function setGroupDescription(sock, chatId, senderId, text, message) {\n    const check = await ensureGroupAndAdmin(sock, chatId, senderId);\n    if (!check.ok) return;\n    const desc = (text || '').trim();\n    if (!desc) {\n        await sock.sendMessage(chatId, { text: 'Usage: .setgdesc <description>' }, { quoted: message });\n        return;\n    }\n    try {\n        await sock.groupUpdateDescription(chatId, desc);\n        await sock.sendMessage(chatId, { text: '‚úÖ Group description updated.' }, { quoted: message });\n    } catch (e) {\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to update group description.' }, { quoted: message });\n    }\n}\n\nasync function setGroupName(sock, chatId, senderId, text, message) {\n    const check = await ensureGroupAndAdmin(sock, chatId, senderId);\n    if (!check.ok) return;\n    const name = (text || '').trim();\n    if (!name) {\n        await sock.sendMessage(chatId, { text: 'Usage: .setgname <new name>' }, { quoted: message });\n        return;\n    }\n    try {\n        await sock.groupUpdateSubject(chatId, name);\n        await sock.sendMessage(chatId, { text: '‚úÖ Group name updated.' }, { quoted: message });\n    } catch (e) {\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to update group name.' }, { quoted: message });\n    }\n}\n\nasync function setGroupPhoto(sock, chatId, senderId, message) {\n    const check = await ensureGroupAndAdmin(sock, chatId, senderId);\n    if (!check.ok) return;\n\n    const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n    const imageMessage = quoted?.imageMessage || quoted?.stickerMessage;\n    if (!imageMessage) {\n        await sock.sendMessage(chatId, { text: 'Reply to an image/sticker with .setgpp' }, { quoted: message });\n        return;\n    }\n    try {\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });\n\n        const stream = await downloadContentFromMessage(imageMessage, 'image');\n        let buffer = Buffer.from([]);\n        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);\n\n        const imgPath = path.join(tmpDir, `gpp_${Date.now()}.jpg`);\n        fs.writeFileSync(imgPath, buffer);\n\n        await sock.updateProfilePicture(chatId, { url: imgPath });\n        try { fs.unlinkSync(imgPath); } catch (_) {}\n        await sock.sendMessage(chatId, { text: '‚úÖ Group profile photo updated.' }, { quoted: message });\n    } catch (e) {\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to update group profile photo.' }, { quoted: message });\n    }\n}\n\nmodule.exports = {\n    setGroupDescription,\n    setGroupName,\n    setGroupPhoto\n};\n\n\n","size_bytes":3598},"commands/hangman.js":{"content":"const fs = require('fs');\n\nconst words = ['javascript', 'bot', 'hangman', 'whatsapp', 'nodejs'];\nlet hangmanGames = {};\n\nfunction startHangman(sock, chatId) {\n    const word = words[Math.floor(Math.random() * words.length)];\n    const maskedWord = '_ '.repeat(word.length).trim();\n\n    hangmanGames[chatId] = {\n        word,\n        maskedWord: maskedWord.split(' '),\n        guessedLetters: [],\n        wrongGuesses: 0,\n        maxWrongGuesses: 6,\n    };\n\n    sock.sendMessage(chatId, { text: `Game started! The word is: ${maskedWord}` });\n}\n\nfunction guessLetter(sock, chatId, letter) {\n    if (!hangmanGames[chatId]) {\n        sock.sendMessage(chatId, { text: 'No game in progress. Start a new game with .hangman' });\n        return;\n    }\n\n    const game = hangmanGames[chatId];\n    const { word, guessedLetters, maskedWord, maxWrongGuesses } = game;\n\n    if (guessedLetters.includes(letter)) {\n        sock.sendMessage(chatId, { text: `You already guessed \"${letter}\". Try another letter.` });\n        return;\n    }\n\n    guessedLetters.push(letter);\n\n    if (word.includes(letter)) {\n        for (let i = 0; i < word.length; i++) {\n            if (word[i] === letter) {\n                maskedWord[i] = letter;\n            }\n        }\n        sock.sendMessage(chatId, { text: `Good guess! ${maskedWord.join(' ')}` });\n\n        if (!maskedWord.includes('_')) {\n            sock.sendMessage(chatId, { text: `Congratulations! You guessed the word: ${word}` });\n            delete hangmanGames[chatId];\n        }\n    } else {\n        game.wrongGuesses += 1;\n        sock.sendMessage(chatId, { text: `Wrong guess! You have ${maxWrongGuesses - game.wrongGuesses} tries left.` });\n\n        if (game.wrongGuesses >= maxWrongGuesses) {\n            sock.sendMessage(chatId, { text: `Game over! The word was: ${word}` });\n            delete hangmanGames[chatId];\n        }\n    }\n}\n\nmodule.exports = { startHangman, guessLetter };\n","size_bytes":1923},"commands/help.js":{"content":"const settings = require('../settings');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function helpCommand(sock, chatId, message) {\n    const helpMessage = `\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   *ü§ñ ${settings.botName || 'Cortex Bot'}*  \n   Version: *${settings.version || '2.1.8'}*\n   by ${settings.botOwner || 'SULEIMAN'}\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n*Available Commands:*\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüåê *General Commands*:\n‚ïë ‚û§ .help or .menu\n‚ïë ‚û§ .ping\n‚ïë ‚û§ .alive\n‚ïë ‚û§ .tts <text>\n‚ïë ‚û§ .owner\n‚ïë ‚û§ .joke\n‚ïë ‚û§ .quote\n‚ïë ‚û§ .fact\n‚ïë ‚û§ .weather <city>\n‚ïë ‚û§ .news\n‚ïë ‚û§ .attp <text>\n‚ïë ‚û§ .lyrics <song_title>\n‚ïë ‚û§ .8ball <question>\n‚ïë ‚û§ .groupinfo\n‚ïë ‚û§ .staff or .admins \n‚ïë ‚û§ .vv\n‚ïë ‚û§ .trt <text> <lang>\n‚ïë ‚û§ .ss <link>\n‚ïë ‚û§ .jid\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù \n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüëÆ‚Äç‚ôÇÔ∏è *Admin Commands*:\n‚ïë ‚û§ .ban @user\n‚ïë ‚û§ .promote @user\n‚ïë ‚û§ .demote @user\n‚ïë ‚û§ .mute <minutes>\n‚ïë ‚û§ .unmute\n‚ïë ‚û§ .delete or .del\n‚ïë ‚û§ .kick @user\n‚ïë ‚û§ .warnings @user\n‚ïë ‚û§ .warn @user\n‚ïë ‚û§ .antilink\n‚ïë ‚û§ .antibadword\n‚ïë ‚û§ .clear\n‚ïë ‚û§ .tag <message>\n‚ïë ‚û§ .tagall\n‚ïë ‚û§ .chatbot\n‚ïë ‚û§ .resetlink\n‚ïë ‚û§ .antitag <on/off>\n‚ïë ‚û§ .welcome <on/off>\n‚ïë ‚û§ .goodbye <on/off>\n‚ïë ‚û§ .setgdesc <description>\n‚ïë ‚û§ .setgname <new name>\n‚ïë ‚û§ .setgpp (reply to image)\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüîí *Owner Commands*:\n‚ïë ‚û§ .mode <public/private>\n‚ïë ‚û§ .clearsession\n‚ïë ‚û§ .antidelete\n‚ïë ‚û§ .cleartmp\n‚ïë ‚û§ .update\n‚ïë ‚û§ .settings\n‚ïë ‚û§ .setpp <reply to image>\n‚ïë ‚û§ .autoreact <on/off>\n‚ïë ‚û§ .autostatus <on/off>\n‚ïë ‚û§ .autostatus react <on/off>\n‚ïë ‚û§ .autotyping <on/off>\n‚ïë ‚û§ .autoread <on/off>\n‚ïë ‚û§ .anticall <on/off>\n‚ïë ‚û§ .pmblocker <on/off/status>\n‚ïë ‚û§ .pmblocker setmsg <text>\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüé® *Image/Sticker Commands*:\n‚ïë ‚û§ .blur <image>\n‚ïë ‚û§ .simage <reply to sticker>\n‚ïë ‚û§ .sticker <reply to image>\n‚ïë ‚û§ .removebg\n‚ïë ‚û§ .remini\n‚ïë ‚û§ .crop <reply to image>\n‚ïë ‚û§ .tgsticker <Link>\n‚ïë ‚û§ .meme\n‚ïë ‚û§ .take <packname> \n‚ïë ‚û§ .emojimix <emj1>+<emj2>\n‚ïë ‚û§ .igs <insta link>\n‚ïë ‚û§ .igsc <insta link>\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  \n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüñºÔ∏è *Pies Commands*:\n‚ïë ‚û§ .pies <country>\n‚ïë ‚û§ .china \n‚ïë ‚û§ .indonesia \n‚ïë ‚û§ .japan \n‚ïë ‚û§ .korea \n‚ïë ‚û§ .hijab\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüéÆ *Game Commands*:\n‚ïë ‚û§ .tictactoe @user\n‚ïë ‚û§ .hangman\n‚ïë ‚û§ .guess <letter>\n‚ïë ‚û§ .trivia\n‚ïë ‚û§ .answer <answer>\n‚ïë ‚û§ .truth\n‚ïë ‚û§ .dare\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nü§ñ *AI Commands*:\n‚ïë ‚û§ .gpt <question>\n‚ïë ‚û§ .gemini <question>\n‚ïë ‚û§ .imagine <prompt>\n‚ïë ‚û§ .flux <prompt>\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüéØ *Fun Commands*:\n‚ïë ‚û§ .compliment @user\n‚ïë ‚û§ .insult @user\n‚ïë ‚û§ .flirt \n‚ïë ‚û§ .shayari\n‚ïë ‚û§ .goodnight\n‚ïë ‚û§ .roseday\n‚ïë ‚û§ .character @user\n‚ïë ‚û§ .wasted @user\n‚ïë ‚û§ .ship @user\n‚ïë ‚û§ .simp @user\n‚ïë ‚û§ .stupid @user [text]\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüî§ *Textmaker*:\n‚ïë ‚û§ .metallic <text>\n‚ïë ‚û§ .ice <text>\n‚ïë ‚û§ .snow <text>\n‚ïë ‚û§ .impressive <text>\n‚ïë ‚û§ .matrix <text>\n‚ïë ‚û§ .light <text>\n‚ïë ‚û§ .neon <text>\n‚ïë ‚û§ .devil <text>\n‚ïë ‚û§ .purple <text>\n‚ïë ‚û§ .thunder <text>\n‚ïë ‚û§ .leaves <text>\n‚ïë ‚û§ .1917 <text>\n‚ïë ‚û§ .arena <text>\n‚ïë ‚û§ .hacker <text>\n‚ïë ‚û§ .sand <text>\n‚ïë ‚û§ .blackpink <text>\n‚ïë ‚û§ .glitch <text>\n‚ïë ‚û§ .fire <text>\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüì• *Downloader*:\n‚ïë ‚û§ .play <song_name>\n‚ïë ‚û§ .song <song_name>\n‚ïë ‚û§ .instagram <link>\n‚ïë ‚û§ .facebook <link>\n‚ïë ‚û§ .tiktok <link>\n‚ïë ‚û§ .video <song name>\n‚ïë ‚û§ .ytmp4 <Link>\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüß© *MISC*:\n‚ïë ‚û§ .heart\n‚ïë ‚û§ .horny\n‚ïë ‚û§ .circle\n‚ïë ‚û§ .lgbt\n‚ïë ‚û§ .lolice\n‚ïë ‚û§ .its-so-stupid\n‚ïë ‚û§ .namecard \n‚ïë ‚û§ .oogway\n‚ïë ‚û§ .tweet\n‚ïë ‚û§ .ytcomment \n‚ïë ‚û§ .comrade \n‚ïë ‚û§ .gay \n‚ïë ‚û§ .glass \n‚ïë ‚û§ .jail \n‚ïë ‚û§ .passed \n‚ïë ‚û§ .triggered\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüñºÔ∏è *ANIME*:\n‚ïë ‚û§ .neko\n‚ïë ‚û§ .waifu\n‚ïë ‚û§ .loli\n‚ïë ‚û§ .nom \n‚ïë ‚û§ .poke \n‚ïë ‚û§ .cry \n‚ïë ‚û§ .kiss \n‚ïë ‚û§ .pat \n‚ïë ‚û§ .hug \n‚ïë ‚û§ .wink \n‚ïë ‚û§ .facepalm \n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\nüíª *Github Commands:*\n‚ïë ‚û§ .git\n‚ïë ‚û§ .github\n‚ïë ‚û§ .sc\n‚ïë ‚û§ .script\n‚ïë ‚û§ .repo\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nJoin our channel for updates:`;\n\n    try {\n        const imagePath = path.join(__dirname, '../assets/bot_image.jpg');\n        \n        if (fs.existsSync(imagePath)) {\n            const imageBuffer = fs.readFileSync(imagePath);\n            \n            await sock.sendMessage(chatId, {\n                image: imageBuffer,\n                caption: helpMessage\n            },{ quoted: message });\n        } else {\n            console.error('Bot image not found at:', imagePath);\n            await sock.sendMessage(chatId, { \n                text: helpMessage\n            });\n        }\n    } catch (error) {\n        console.error('Error in help command:', error);\n        await sock.sendMessage(chatId, { text: helpMessage });\n    }\n}\n\nmodule.exports = helpCommand;\n","size_bytes":6416},"commands/igs.js":{"content":"const { igdl } = require('ruhend-scraper');\nconst axios = require('axios');\nconst { exec } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst webp = require('node-webpmux');\nconst crypto = require('crypto');\nconst settings = require('../settings');\nconst { stickercropFromBuffer } = require('./stickercrop');\n\nasync function convertBufferToStickerWebp(inputBuffer, isAnimated, cropSquare) {\n    const tmpDir = path.join(process.cwd(), 'tmp');\n    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });\n\n    const tempInputBase = path.join(tmpDir, `igs_${Date.now()}_${Math.random().toString(36).slice(2)}`);\n    const tempInput = isAnimated ? `${tempInputBase}.mp4` : `${tempInputBase}.jpg`;\n    const tempOutput = path.join(tmpDir, `igs_out_${Date.now()}_${Math.random().toString(36).slice(2)}.webp`);\n\n    fs.writeFileSync(tempInput, inputBuffer);\n\n    // Deferred cleanup to avoid race with WhatsApp download\n    const filesToDelete = [];\n    const scheduleDelete = (p) => {\n        if (!p) return;\n        filesToDelete.push(p);\n        setTimeout(() => {\n            try { fs.unlinkSync(p); } catch {}\n        }, 5000);\n    };\n\n    // Image filters\n    const vfCropSquareImg = \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512\";\n    const vfPadSquareImg = \"scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\";\n\n    let ffmpegCommand;\n    if (isAnimated) {\n        // For videos/GIFs\n        const isLargeVideo = inputBuffer.length > (5 * 1024 * 1024); // >5MB\n        const maxDuration = isLargeVideo ? 2 : 3;\n        // Match stickercrop.js style compression\n        if (cropSquare) {\n            if (isLargeVideo) {\n                ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=8\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n            } else {\n                ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -t 3 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=12\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 50 -compression_level 6 -b:v 150k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n            }\n        } else {\n            if (isLargeVideo) {\n                ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000,fps=8\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 35 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n            } else {\n                ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -t 3 -vf \"scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000,fps=12\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 45 -compression_level 6 -b:v 150k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n            }\n        }\n    } else {\n        // For images\n        const vf = `${cropSquare ? vfCropSquareImg : vfPadSquareImg},format=rgba`;\n        ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -vf \"${vf}\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`;\n    }\n\n    await new Promise((resolve, reject) => {\n        exec(ffmpegCommand, (error, _stdout, _stderr) => {\n            if (error) return reject(error);\n            resolve();\n        });\n    });\n\n    // If output is too large (> ~1MB), do a harsher second pass for videos\n    let webpBuffer = fs.readFileSync(tempOutput);\n    scheduleDelete(tempOutput);\n    if (isAnimated && webpBuffer.length > 1000 * 1024) {\n        try {\n            // Re-encode with stronger compression\n            const tempOutput2 = path.join(tmpDir, `igs_out2_${Date.now()}_${Math.random().toString(36).slice(2)}.webp`);\n            const harsherCmd = cropSquare\n                ? `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=8\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput2}\"`\n                : `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000,fps=8\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 35 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput2}\"`;\n            await new Promise((resolve, reject) => {\n                exec(harsherCmd, (error) => error ? reject(error) : resolve());\n            });\n            if (fs.existsSync(tempOutput2)) {\n                webpBuffer = fs.readFileSync(tempOutput2);\n                scheduleDelete(tempOutput2);\n            }\n        } catch {}\n    }\n\n    const img = new webp.Image();\n    await img.load(webpBuffer);\n\n    const json = {\n        'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n        'sticker-pack-name': settings.packname || 'KnightBot',\n        'emojis': ['üì∏']\n    };\n    const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n    const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n    const exif = Buffer.concat([exifAttr, jsonBuffer]);\n    exif.writeUIntLE(jsonBuffer.length, 14, 4);\n    img.exif = exif;\n\n    let finalBuffer = await img.save(null);\n\n    // Absolute final safety: if still too large, do a smaller-scale pass\n    if (finalBuffer.length > 900 * 1024) {\n        try {\n            const tempOutput3 = path.join(tmpDir, `igs_out3_${Date.now()}_${Math.random().toString(36).slice(2)}.webp`);\n            const vfSmall = cropSquare\n                ? `crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=320:320${isAnimated ? ',fps=8' : ''}`\n                : `scale=320:320:force_original_aspect_ratio=decrease,pad=320:320:(ow-iw)/2:(oh-ih)/2:color=#00000000${isAnimated ? ',fps=8' : ''}`;\n            const cmdSmall = `ffmpeg -y -i \"${tempInput}\" ${isAnimated ? '-t 2' : ''} -vf \"${vfSmall}\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality ${isAnimated ? 28 : 65} -compression_level 6 -b:v 80k -max_muxing_queue_size 1024 \"${tempOutput3}\"`;\n            await new Promise((resolve, reject) => {\n                exec(cmdSmall, (error) => error ? reject(error) : resolve());\n            });\n            if (fs.existsSync(tempOutput3)) {\n                const smallWebp = fs.readFileSync(tempOutput3);\n                const img2 = new webp.Image();\n                await img2.load(smallWebp);\n                const json2 = {\n                    'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n                    'sticker-pack-name': settings.packname || 'KnightBot',\n                    'emojis': ['üì∏']\n                };\n                const exifAttr2 = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n                const jsonBuffer2 = Buffer.from(JSON.stringify(json2), 'utf8');\n                const exif2 = Buffer.concat([exifAttr2, jsonBuffer2]);\n                exif2.writeUIntLE(jsonBuffer2.length, 14, 4);\n                img2.exif = exif2;\n                finalBuffer = await img2.save(null);\n                scheduleDelete(tempOutput3);\n            }\n        } catch {}\n    }\n\n    // Defer deletes to ensure WhatsApp finishes reading\n    scheduleDelete(tempInput);\n\n    return finalBuffer;\n}\n\nasync function fetchBufferFromUrl(url) {\n    // Attempt 1: simple arraybuffer with generous limits\n    try {\n        const res = await axios.get(url, {\n            responseType: 'arraybuffer',\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',\n                'Accept': '*/*',\n                // Some CDNs misbehave with Referer/Origin; omit to reduce blocks\n                'Accept-Encoding': 'identity'\n            },\n            timeout: 30000,\n            maxContentLength: Infinity,\n            maxBodyLength: Infinity,\n            decompress: true,\n            validateStatus: s => s >= 200 && s < 400\n        });\n        return Buffer.from(res.data);\n    } catch (e1) {\n        // Attempt 2: stream mode read fully\n        try {\n            const res = await axios.get(url, {\n                responseType: 'stream',\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',\n                    'Accept': '*/*',\n                    'Accept-Encoding': 'identity'\n                },\n                timeout: 40000,\n                maxContentLength: Infinity,\n                maxBodyLength: Infinity,\n                validateStatus: s => s >= 200 && s < 400\n            });\n            const chunks = [];\n            await new Promise((resolve, reject) => {\n                res.data.on('data', c => chunks.push(c));\n                res.data.on('end', resolve);\n                res.data.on('error', reject);\n            });\n            return Buffer.concat(chunks);\n        } catch (e2) {\n            console.error('Both axios download attempts failed:', e1?.message || e1, e2?.message || e2);\n            throw e2;\n        }\n    }\n}\n\nasync function igsCommand(sock, chatId, message, crop = false) {\n    try {\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text || '';\n        const urlMatch = text.match(/https?:\\/\\/\\S+/);\n        if (!urlMatch) {\n            await sock.sendMessage(chatId, { text: `Send an Instagram post/reel link.\\nUsage:\\n.igs <url>\\n.igsc <url>` }, { quoted: message });\n            return;\n        }\n\n        await sock.sendMessage(chatId, { react: { text: 'üîÑ', key: message.key } });\n\n        const downloadData = await igdl(urlMatch[0]).catch(() => null);\n        if (!downloadData || !downloadData.data) {\n            await sock.sendMessage(chatId, { text: '‚ùå Failed to fetch media from Instagram link.' }, { quoted: message });\n            return;\n        }\n        // Raw items\n        const rawItems = (downloadData?.data || []).filter(m => m && m.url);\n        // Deduplicate by exact URL first\n        const seenUrls = new Set();\n        const items = [];\n        for (const m of rawItems) {\n            if (!seenUrls.has(m.url)) {\n                seenUrls.add(m.url);\n                items.push(m);\n            }\n        }\n        if (items.length === 0) {\n            await sock.sendMessage(chatId, { text: '‚ùå No media found at the provided link.' }, { quoted: message });\n            return;\n        }\n\n        // Process up to 10 media items to avoid spam/timeouts\n        const maxItems = Math.min(items.length, 10);\n        const seenHashes = new Set();\n        for (let i = 0; i < maxItems; i++) {\n            try {\n                const media = items[i];\n                const mediaUrl = media.url;\n                const isVideo = (media?.type === 'video') || /\\.(mp4|mov|avi|mkv|webm)$/i.test(mediaUrl);\n\n                const buffer = await fetchBufferFromUrl(mediaUrl);\n\n                // Content-based dedupe: skip if identical media already processed\n                const hash = require('crypto').createHash('sha1').update(buffer).digest('hex');\n                if (seenHashes.has(hash)) {\n                    continue;\n                }\n                seenHashes.add(hash);\n\n                let stickerBuffer = crop\n                    ? await stickercropFromBuffer(buffer, isVideo)\n                    : await convertBufferToStickerWebp(buffer, isVideo, false);\n\n                // Ensure final size under ~900KB; otherwise try a harsher mini fallback\n                let finalSticker = stickerBuffer;\n                if (finalSticker.length > 900 * 1024) {\n                    try {\n                        const fallback = await forceMiniSticker(buffer, isVideo, crop);\n                        if (fallback && fallback.length <= 900 * 1024) {\n                            finalSticker = fallback;\n                        }\n                    } catch (e) {\n                        console.error('forceMiniSticker error:', e);\n                    }\n                }\n\n                await sock.sendMessage(chatId, { sticker: finalSticker }, { quoted: message });\n\n                // Small delay to avoid rate limiting\n                if (i < maxItems - 1) {\n                    await new Promise(r => setTimeout(r, 800));\n                }\n            } catch (perItemErr) {\n                console.error('IGS item error:', perItemErr);\n                // continue with next item\n            }\n        }\n\n    } catch (err) {\n        console.error('Error in igs command:', err);\n        await sock.sendMessage(chatId, { text: 'Failed to create sticker from Instagram link.' }, { quoted: message });\n    }\n}\n\n// Extreme fallback to force very small stickers when needed\nasync function forceMiniSticker(inputBuffer, isVideo, cropSquare) {\n    const tmpDir = path.join(process.cwd(), 'tmp');\n    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });\n\n    const tempInput = path.join(tmpDir, `mini_${Date.now()}.${isVideo ? 'mp4' : 'jpg'}`);\n    const tempOutput = path.join(tmpDir, `mini_out_${Date.now()}.webp`);\n    fs.writeFileSync(tempInput, inputBuffer);\n\n    const vf = cropSquare\n        ? `crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=256:256${isVideo ? ',fps=6' : ''}`\n        : `scale=256:256:force_original_aspect_ratio=decrease,pad=256:256:(ow-iw)/2:(oh-ih)/2:color=#00000000${isVideo ? ',fps=6' : ''}`;\n\n    const cmd = `ffmpeg -y -i \"${tempInput}\" ${isVideo ? '-t 2' : ''} -vf \"${vf}\" -c:v libwebp -preset default -loop 0 -pix_fmt yuva420p -quality 25 -compression_level 6 -b:v 60k \"${tempOutput}\"`;\n\n    await new Promise((resolve, reject) => {\n        exec(cmd, (error) => error ? reject(error) : resolve());\n    });\n\n    if (!fs.existsSync(tempOutput)) {\n        try { fs.unlinkSync(tempInput); } catch {}\n        return null;\n    }\n    const smallWebp = fs.readFileSync(tempOutput);\n\n    // Re-apply EXIF\n    const img = new webp.Image();\n    await img.load(smallWebp);\n    const json = {\n        'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n        'sticker-pack-name': settings.packname || 'KnightBot',\n        'emojis': ['üì∏']\n    };\n    const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n    const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n    const exif = Buffer.concat([exifAttr, jsonBuffer]);\n    exif.writeUIntLE(jsonBuffer.length, 14, 4);\n    img.exif = exif;\n    const finalBuffer = await img.save(null);\n\n    try { fs.unlinkSync(tempInput); } catch {}\n    try { fs.unlinkSync(tempOutput); } catch {}\n\n    return finalBuffer;\n}\n\nmodule.exports = { igsCommand };\n\n\n","size_bytes":15145},"commands/imagine.js":{"content":"const axios = require('axios');\nconst { fetchBuffer } = require('../lib/myfunc');\n\nasync function imagineCommand(sock, chatId, message) {\n    try {\n        // Get the prompt from the message\n        const prompt = message.message?.conversation?.trim() || \n                      message.message?.extendedTextMessage?.text?.trim() || '';\n        \n        // Remove the command prefix and trim\n        const imagePrompt = prompt.slice(8).trim();\n        \n        if (!imagePrompt) {\n            await sock.sendMessage(chatId, {\n                text: 'Please provide a prompt for the image generation.\\nExample: .imagine a beautiful sunset over mountains'\n            }, {\n                quoted: message\n            });\n            return;\n        }\n\n        // Send processing message\n        await sock.sendMessage(chatId, {\n            text: 'üé® Generating your image... Please wait.'\n        }, {\n            quoted: message\n        });\n\n        // Enhance the prompt with quality keywords\n        const enhancedPrompt = enhancePrompt(imagePrompt);\n\n        // Make API request\n        const response = await axios.get(`https://shizoapi.onrender.com/api/ai/imagine?apikey=shizo&query=${encodeURIComponent(enhancedPrompt)}`, {\n            responseType: 'arraybuffer'\n        });\n\n        // Convert response to buffer\n        const imageBuffer = Buffer.from(response.data);\n\n        // Send the generated image\n        await sock.sendMessage(chatId, {\n            image: imageBuffer,\n            caption: `üé® Generated image for prompt: \"${imagePrompt}\"`\n        }, {\n            quoted: message\n        });\n\n    } catch (error) {\n        console.error('Error in imagine command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Failed to generate image. Please try again later.'\n        }, {\n            quoted: message\n        });\n    }\n}\n\n// Function to enhance the prompt\nfunction enhancePrompt(prompt) {\n    // Quality enhancing keywords\n    const qualityEnhancers = [\n        'high quality',\n        'detailed',\n        'masterpiece',\n        'best quality',\n        'ultra realistic',\n        '4k',\n        'highly detailed',\n        'professional photography',\n        'cinematic lighting',\n        'sharp focus'\n    ];\n\n    // Randomly select 3-4 enhancers\n    const numEnhancers = Math.floor(Math.random() * 2) + 3; // Random number between 3-4\n    const selectedEnhancers = qualityEnhancers\n        .sort(() => Math.random() - 0.5)\n        .slice(0, numEnhancers);\n\n    // Combine original prompt with enhancers\n    return `${prompt}, ${selectedEnhancers.join(', ')}`;\n}\n\nmodule.exports = imagineCommand; ","size_bytes":2645},"commands/img-blur.js":{"content":"const { downloadMediaMessage } = require('@whiskeysockets/baileys');\nconst axios = require('axios');\nconst sharp = require('sharp');\n\nasync function blurCommand(sock, chatId, message, quotedMessage) {\n    try {\n        // Get the image to blur\n        let imageBuffer;\n        \n        if (quotedMessage) {\n            // If replying to a message\n            if (!quotedMessage.imageMessage) {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Please reply to an image message' \n                }, { quoted: message });\n                return;\n            }\n            \n            const quoted = {\n                message: {\n                    imageMessage: quotedMessage.imageMessage\n                }\n            };\n            \n            imageBuffer = await downloadMediaMessage(\n                quoted,\n                'buffer',\n                { },\n                { }\n            );\n        } else if (message.message?.imageMessage) {\n            // If image is in current message\n            imageBuffer = await downloadMediaMessage(\n                message,\n                'buffer',\n                { },\n                { }\n            );\n        } else {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Please reply to an image or send an image with caption .blur' \n            }, { quoted: message });\n            return;\n        }\n\n        // Resize and optimize image\n        const resizedImage = await sharp(imageBuffer)\n            .resize(800, 800, { // Resize to max 800x800\n                fit: 'inside',\n                withoutEnlargement: true\n            })\n            .jpeg({ quality: 80 }) // Convert to JPEG with 80% quality\n            .toBuffer();\n\n        // Apply blur effect directly using sharp\n        const blurredImage = await sharp(resizedImage)\n            .blur(10) // Blur radius of 10\n            .toBuffer();\n\n        // Send the blurred image\n        await sock.sendMessage(chatId, {\n            image: blurredImage,\n            caption: '*[ ‚úî ] Image Blurred Successfully*',\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        }, { quoted: message });\n\n    } catch (error) {\n        console.error('Error in blur command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to blur image. Please try again later.' \n        }, { quoted: message });\n    }\n}\n\nmodule.exports = blurCommand; ","size_bytes":2489},"commands/instagram.js":{"content":"const { igdl } = require(\"ruhend-scraper\");\n\n// Store processed message IDs to prevent duplicates\nconst processedMessages = new Set();\n\n// Function to extract unique media URLs with simple deduplication\nfunction extractUniqueMedia(mediaData) {\n    const uniqueMedia = [];\n    const seenUrls = new Set();\n    \n    for (const media of mediaData) {\n        if (!media.url) continue;\n        \n        // Only check for exact URL duplicates\n        if (!seenUrls.has(media.url)) {\n            seenUrls.add(media.url);\n            uniqueMedia.push(media);\n        }\n    }\n    \n    return uniqueMedia;\n}\n\n// Function to validate media URL\nfunction isValidMediaUrl(url) {\n    if (!url || typeof url !== 'string') return false;\n    \n    // Accept any URL that looks like media\n    return url.includes('cdninstagram.com') || \n           url.includes('instagram') || \n           url.includes('http');\n}\n\nasync function instagramCommand(sock, chatId, message) {\n    try {\n        // Check if message has already been processed\n        if (processedMessages.has(message.key.id)) {\n            return;\n        }\n        \n        // Add message ID to processed set\n        processedMessages.add(message.key.id);\n        \n        // Clean up old message IDs after 5 minutes\n        setTimeout(() => {\n            processedMessages.delete(message.key.id);\n        }, 5 * 60 * 1000);\n\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        \n        if (!text) {\n            return await sock.sendMessage(chatId, { \n                text: \"Please provide an Instagram link for the video.\"\n            });\n        }\n\n        // Check for various Instagram URL formats\n        const instagramPatterns = [\n            /https?:\\/\\/(?:www\\.)?instagram\\.com\\//,\n            /https?:\\/\\/(?:www\\.)?instagr\\.am\\//,\n            /https?:\\/\\/(?:www\\.)?instagram\\.com\\/p\\//,\n            /https?:\\/\\/(?:www\\.)?instagram\\.com\\/reel\\//,\n            /https?:\\/\\/(?:www\\.)?instagram\\.com\\/tv\\//\n        ];\n\n        const isValidUrl = instagramPatterns.some(pattern => pattern.test(text));\n        \n        if (!isValidUrl) {\n            return await sock.sendMessage(chatId, { \n                text: \"That is not a valid Instagram link. Please provide a valid Instagram post, reel, or video link.\"\n            });\n        }\n\n        await sock.sendMessage(chatId, {\n            react: { text: 'üîÑ', key: message.key }\n        });\n\n        const downloadData = await igdl(text);\n        \n        if (!downloadData || !downloadData.data || downloadData.data.length === 0) {\n            return await sock.sendMessage(chatId, { \n                text: \"‚ùå No media found at the provided link. The post might be private or the link is invalid.\"\n            });\n        }\n\n        const mediaData = downloadData.data;\n        \n        // Simple deduplication - just remove exact URL duplicates\n        const uniqueMedia = extractUniqueMedia(mediaData);\n        \n        // Limit to maximum 20 unique media items\n        const mediaToDownload = uniqueMedia.slice(0, 20);\n        \n        if (mediaToDownload.length === 0) {\n            return await sock.sendMessage(chatId, { \n                text: \"‚ùå No valid media found to download. This might be a private post or the scraper failed.\"\n            });\n        }\n\n        // Download all media silently without status messages\n        for (let i = 0; i < mediaToDownload.length; i++) {\n            try {\n                const media = mediaToDownload[i];\n                const mediaUrl = media.url;\n\n                // Check if URL ends with common video extensions\n                const isVideo = /\\.(mp4|mov|avi|mkv|webm)$/i.test(mediaUrl) || \n                              media.type === 'video' || \n                              text.includes('/reel/') || \n                              text.includes('/tv/');\n\n                if (isVideo) {\n                    await sock.sendMessage(chatId, {\n                        video: { url: mediaUrl },\n                        mimetype: \"video/mp4\",\n                        caption: \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\"\n                    }, { quoted: message });\n                } else {\n                    await sock.sendMessage(chatId, {\n                        image: { url: mediaUrl },\n                        caption: \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\"\n                    }, { quoted: message });\n                }\n                \n                // Add small delay between downloads to prevent rate limiting\n                if (i < mediaToDownload.length - 1) {\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n                }\n                \n            } catch (mediaError) {\n                console.error(`Error downloading media ${i + 1}:`, mediaError);\n                // Continue with next media if one fails\n            }\n        }\n\n    } catch (error) {\n        console.error('Error in Instagram command:', error);\n        await sock.sendMessage(chatId, { \n            text: \"‚ùå An error occurred while processing the Instagram request. Please try again.\"\n        });\n    }\n}\n\nmodule.exports = instagramCommand;\n","size_bytes":5278},"commands/insult.js":{"content":"const insults = [\n    \"You're like a cloud. When you disappear, it's a beautiful day!\",\n    \"You bring everyone so much joy when you leave the room!\",\n    \"I'd agree with you, but then we'd both be wrong.\",\n    \"You're not stupid; you just have bad luck thinking.\",\n    \"Your secrets are always safe with me. I never even listen to them.\",\n    \"You're proof that even evolution takes a break sometimes.\",\n    \"You have something on your chin... no, the third one down.\",\n    \"You're like a software update. Whenever I see you, I think, 'Do I really need this right now?'\",\n    \"You bring everyone happiness... you know, when you leave.\",\n    \"You're like a penny‚Äîtwo-faced and not worth much.\",\n    \"You have something on your mind... oh wait, never mind.\",\n    \"You're the reason they put directions on shampoo bottles.\",\n    \"You're like a cloud. Always floating around with no real purpose.\",\n    \"Your jokes are like expired milk‚Äîsour and hard to digest.\",\n    \"You're like a candle in the wind... useless when things get tough.\",\n    \"You have something unique‚Äîyour ability to annoy everyone equally.\",\n    \"You're like a Wi-Fi signal‚Äîalways weak when needed most.\",\n    \"You're proof that not everyone needs a filter to be unappealing.\",\n    \"Your energy is like a black hole‚Äîit just sucks the life out of the room.\",\n    \"You have the perfect face for radio.\",\n    \"You're like a traffic jam‚Äînobody wants you, but here you are.\",\n    \"You're like a broken pencil‚Äîpointless.\",\n    \"Your ideas are so original, I'm sure I've heard them all before.\",\n    \"You're living proof that even mistakes can be productive.\",\n    \"You're not lazy; you're just highly motivated to do nothing.\",\n    \"Your brain's running Windows 95‚Äîslow and outdated.\",\n    \"You're like a speed bump‚Äînobody likes you, but everyone has to deal with you.\",\n    \"You're like a cloud of mosquitoes‚Äîjust irritating.\",\n    \"You bring people together... to talk about how annoying you are.\"\n];\n\nasync function insultCommand(sock, chatId, message) {\n    try {\n        if (!message || !chatId) {\n            console.log('Invalid message or chatId:', { message, chatId });\n            return;\n        }\n\n        let userToInsult;\n        \n        // Check for mentioned users\n        if (message.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n            userToInsult = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n        }\n        // Check for replied message\n        else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n            userToInsult = message.message.extendedTextMessage.contextInfo.participant;\n        }\n        \n        if (!userToInsult) {\n            await sock.sendMessage(chatId, { \n                text: 'Please mention someone or reply to their message to insult them!'\n            });\n            return;\n        }\n\n        const insult = insults[Math.floor(Math.random() * insults.length)];\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        await sock.sendMessage(chatId, { \n            text: `Hey @${userToInsult.split('@')[0]}, ${insult}`,\n            mentions: [userToInsult]\n        });\n    } catch (error) {\n        console.error('Error in insult command:', error);\n        if (error.data === 429) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            try {\n                await sock.sendMessage(chatId, { \n                    text: 'Please try again in a few seconds.'\n                });\n            } catch (retryError) {\n                console.error('Error sending retry message:', retryError);\n            }\n        } else {\n            try {\n                await sock.sendMessage(chatId, { \n                    text: 'An error occurred while sending the insult.'\n                });\n            } catch (sendError) {\n                console.error('Error sending error message:', sendError);\n            }\n        }\n    }\n}\n\nmodule.exports = { insultCommand };\n","size_bytes":4050},"commands/joke.js":{"content":"const axios = require('axios');\n\nmodule.exports = async function (sock, chatId) {\n    try {\n        const response = await axios.get('https://icanhazdadjoke.com/', {\n            headers: { Accept: 'application/json' }\n        });\n        const joke = response.data.joke;\n        await sock.sendMessage(chatId, { text: joke });\n    } catch (error) {\n        console.error('Error fetching joke:', error);\n        await sock.sendMessage(chatId, { text: 'Sorry, I could not fetch a joke right now.' });\n    }\n};\n","size_bytes":508},"commands/kick.js":{"content":"const isAdmin = require('../lib/isAdmin');\n\nasync function kickCommand(sock, chatId, senderId, mentionedJids, message) {\n    // Check if user is owner\n    const isOwner = message.key.fromMe;\n    if (!isOwner) {\n        const { isSenderAdmin, isBotAdmin } = await isAdmin(sock, chatId, senderId);\n\n        if (!isBotAdmin) {\n            await sock.sendMessage(chatId, { text: 'Please make the bot an admin first.' }, { quoted: message });\n            return;\n        }\n\n        if (!isSenderAdmin) {\n            await sock.sendMessage(chatId, { text: 'Only group admins can use the kick command.' }, { quoted: message });\n            return;\n        }\n    }\n\n    let usersToKick = [];\n    \n    // Check for mentioned users\n    if (mentionedJids && mentionedJids.length > 0) {\n        usersToKick = mentionedJids;\n    }\n    // Check for replied message\n    else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n        usersToKick = [message.message.extendedTextMessage.contextInfo.participant];\n    }\n    \n    // If no user found through either method\n    if (usersToKick.length === 0) {\n        await sock.sendMessage(chatId, { \n            text: 'Please mention the user or reply to their message to kick!'\n        }, { quoted: message });\n        return;\n    }\n\n    // Get bot's ID\n    const botId = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n\n    // Check if any of the users to kick is the bot itself\n    if (usersToKick.includes(botId)) {\n        await sock.sendMessage(chatId, { \n            text: \"I can't kick myself! ü§ñ\"\n        }, { quoted: message });\n        return;\n    }\n\n    try {\n        await sock.groupParticipantsUpdate(chatId, usersToKick, \"remove\");\n        \n        // Get usernames for each kicked user\n        const usernames = await Promise.all(usersToKick.map(async jid => {\n            return `@${jid.split('@')[0]}`;\n        }));\n        \n        await sock.sendMessage(chatId, { \n            text: `${usernames.join(', ')} has been kicked successfully!`,\n            mentions: usersToKick\n        });\n    } catch (error) {\n        console.error('Error in kick command:', error);\n        await sock.sendMessage(chatId, { \n            text: 'Failed to kick user(s)!'\n        });\n    }\n}\n\nmodule.exports = kickCommand;\n","size_bytes":2273},"commands/lyrics.js":{"content":"const fetch = require('node-fetch');\n\nasync function lyricsCommand(sock, chatId, songTitle, message) {\n    if (!songTitle) {\n        await sock.sendMessage(chatId, { \n            text: 'üîç Please enter the song name to get the lyrics! Usage: *lyrics <song name>*'\n        },{ quoted: message });\n        return;\n    }\n\n    try {\n        // Use lyricsapi.fly.dev and return only the raw lyrics text\n        const apiUrl = `https://lyricsapi.fly.dev/api/lyrics?q=${encodeURIComponent(songTitle)}`;\n        const res = await fetch(apiUrl);\n        \n        if (!res.ok) {\n            const errText = await res.text();\n            throw errText;\n        }\n        \n        const data = await res.json();\n\n        const lyrics = data && data.result && data.result.lyrics ? data.result.lyrics : null;\n        if (!lyrics) {\n            await sock.sendMessage(chatId, {\n                text: `‚ùå Sorry, I couldn't find any lyrics for \"${songTitle}\".`\n            },{ quoted: message });\n            return;\n        }\n\n        const maxChars = 4096;\n        const output = lyrics.length > maxChars ? lyrics.slice(0, maxChars - 3) + '...' : lyrics;\n\n        await sock.sendMessage(chatId, { text: output }, { quoted: message });\n    } catch (error) {\n        console.error('Error in lyrics command:', error);\n        await sock.sendMessage(chatId, { \n            text: `‚ùå An error occurred while fetching the lyrics for \"${songTitle}\".`\n        },{ quoted: message });\n    }\n}\n\nmodule.exports = { lyricsCommand };\n","size_bytes":1510},"commands/meme.js":{"content":"const fetch = require('node-fetch');\n\nasync function memeCommand(sock, chatId, message) {\n    try {\n        const response = await fetch('https://shizoapi.onrender.com/api/memes/cheems?apikey=shizo');\n        \n        // Check if response is an image\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('image')) {\n            const imageBuffer = await response.buffer();\n            \n            const buttons = [\n                { buttonId: '.meme', buttonText: { displayText: 'üé≠ Another Meme' }, type: 1 },\n                { buttonId: '.joke', buttonText: { displayText: 'üòÑ Joke' }, type: 1 }\n            ];\n\n            await sock.sendMessage(chatId, { \n                image: imageBuffer,\n                caption: \"> Here's your cheems meme! üêï\",\n                buttons: buttons,\n                headerType: 1\n            },{ quoted: message});\n        } else {\n            throw new Error('Invalid response type from API');\n        }\n    } catch (error) {\n        console.error('Error in meme command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to fetch meme. Please try again later.'\n        },{ quoted: message });\n    }\n}\n\nmodule.exports = memeCommand;\n","size_bytes":1272},"commands/misc.js":{"content":"const axios = require('axios');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\nconst { uploadImage } = require('../lib/uploadImage');\n\nasync function getQuotedOrOwnImageUrl(sock, message) {\n    // 1) Quoted image (highest priority)\n    const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n    if (quoted?.imageMessage) {\n        const stream = await downloadContentFromMessage(quoted.imageMessage, 'image');\n        const chunks = [];\n        for await (const chunk of stream) chunks.push(chunk);\n        const buffer = Buffer.concat(chunks);\n        return await uploadImage(buffer);\n    }\n\n    // 2) Image in the current message\n    if (message.message?.imageMessage) {\n        const stream = await downloadContentFromMessage(message.message.imageMessage, 'image');\n        const chunks = [];\n        for await (const chunk of stream) chunks.push(chunk);\n        const buffer = Buffer.concat(chunks);\n        return await uploadImage(buffer);\n    }\n\n    // 3) Mentioned or replied participant avatar\n    let targetJid;\n    const ctx = message.message?.extendedTextMessage?.contextInfo;\n    if (ctx?.mentionedJid?.length > 0) {\n        targetJid = ctx.mentionedJid[0];\n    } else if (ctx?.participant) {\n        targetJid = ctx.participant;\n    } else {\n        targetJid = message.key.participant || message.key.remoteJid;\n    }\n\n    try {\n        const url = await sock.profilePictureUrl(targetJid, 'image');\n        return url;\n    } catch {\n        return 'https://i.imgur.com/2wzGhpF.png';\n    }\n}\n\nasync function handleHeart(sock, chatId, message) {\n    try {\n        const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n        const url = `https://api.some-random-api.com/canvas/misc/heart?avatar=${encodeURIComponent(avatarUrl)}`;\n        const response = await axios.get(url, { responseType: 'arraybuffer' });\n        await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n    } catch (error) {\n        console.error('Error in misc heart:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to create heart image. Try again later.' }, { quoted: message });\n    }\n}\n\nasync function miscCommand(sock, chatId, message, args) {\n    const sub = (args[0] || '').toLowerCase();\n    const rest = args.slice(1);\n\n    async function simpleAvatarOnly(endpoint) {\n        const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n        const url = `https://api.some-random-api.com/canvas/misc/${endpoint}?avatar=${encodeURIComponent(avatarUrl)}`;\n        const response = await axios.get(url, { responseType: 'arraybuffer' });\n        await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n    }\n\n    try {\n        switch (sub) {\n            case 'heart':\n                await simpleAvatarOnly('heart');\n                break;\n            \n            case 'horny':\n                await simpleAvatarOnly('horny');\n                break;\n            case 'circle':\n                await simpleAvatarOnly('circle');\n                break;\n            case 'lgbt':\n                await simpleAvatarOnly('lgbt');\n                break;\n            case 'lied':\n                await simpleAvatarOnly('lied');\n                break;\n            case 'lolice':\n                await simpleAvatarOnly('lolice');\n                break;\n            case 'simpcard':\n                await simpleAvatarOnly('simpcard');\n                break;\n            case 'tonikawa':\n                await simpleAvatarOnly('tonikawa');\n                break;\n\n            case 'its-so-stupid': {\n                const dog = rest.join(' ').trim();\n                if (!dog) {\n                    await sock.sendMessage(chatId, { text: 'Usage: .misc its-so-stupid <text>' }, { quoted: message });\n                    return;\n                }\n                const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n                const url = `https://api.some-random-api.com/canvas/misc/its-so-stupid?dog=${encodeURIComponent(dog)}&avatar=${encodeURIComponent(avatarUrl)}`;\n                const response = await axios.get(url, { responseType: 'arraybuffer' });\n                await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n                break;\n            }\n\n            case 'namecard': {\n                // .misc namecard username|birthday|description(optional)\n                const joined = rest.join(' ');\n                const [username, birthday, description] = joined.split('|').map(s => (s || '').trim());\n                if (!username || !birthday) {\n                    await sock.sendMessage(chatId, { text: 'Usage: .misc namecard username|birthday|description(optional)' }, { quoted: message });\n                    return;\n                }\n                const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n                const params = new URLSearchParams({ username, birthday, avatar: avatarUrl });\n                if (description) params.append('description', description);\n                const url = `https://api.some-random-api.com/canvas/misc/namecard?${params.toString()}`;\n                const response = await axios.get(url, { responseType: 'arraybuffer' });\n                await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n                break;\n            }\n\n           \n            case 'oogway':\n            case 'oogway2': {\n                const quote = rest.join(' ').trim();\n                if (!quote) {\n                    await sock.sendMessage(chatId, { text: `Usage: .misc ${sub} <quote>` }, { quoted: message });\n                    return;\n                }\n                const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n                const url = `https://api.some-random-api.com/canvas/misc/${sub}?quote=${encodeURIComponent(quote)}&avatar=${encodeURIComponent(avatarUrl)}`;\n                const response = await axios.get(url, { responseType: 'arraybuffer' });\n                await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n                break;\n            }\n\n            case 'tweet': {\n                // .misc tweet displayname|username|comment|theme(optional: light/dark)\n                const joined = rest.join(' ');\n                const [displayname, username, comment, theme] = joined.split('|').map(s => (s || '').trim());\n                if (!displayname || !username || !comment) {\n                    await sock.sendMessage(chatId, { text: 'Usage: .misc tweet displayname|username|comment|theme(optional light/dark)' }, { quoted: message });\n                    return;\n                }\n                const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n                const params = new URLSearchParams({ displayname, username, comment, avatar: avatarUrl });\n                if (theme) params.append('theme', theme);\n                const url = `https://api.some-random-api.com/canvas/misc/tweet?${params.toString()}`;\n                const response = await axios.get(url, { responseType: 'arraybuffer' });\n                await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n                break;\n            }\n\n            case 'youtube-comment': {\n                // .misc youtube-comment username|comment\n                const joined = rest.join(' ');\n                const [username, comment] = joined.split('|').map(s => (s || '').trim());\n                if (!username || !comment) {\n                    await sock.sendMessage(chatId, { text: 'Usage: .misc youtube-comment username|comment' }, { quoted: message });\n                    return;\n                }\n                const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n                const params = new URLSearchParams({ username, comment, avatar: avatarUrl });\n                const url = `https://api.some-random-api.com/canvas/misc/youtube-comment?${params.toString()}`;\n                const response = await axios.get(url, { responseType: 'arraybuffer' });\n                await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n                break;\n            }\n            // Overlay endpoints\n            case 'comrade':\n            case 'gay':\n            case 'glass':\n            case 'jail':\n            case 'passed':\n            case 'triggered': {\n                const avatarUrl = await getQuotedOrOwnImageUrl(sock, message);\n                const overlay = sub; // same name for path\n                const url = `https://api.some-random-api.com/canvas/overlay/${overlay}?avatar=${encodeURIComponent(avatarUrl)}`;\n                const response = await axios.get(url, { responseType: 'arraybuffer' });\n                await sock.sendMessage(chatId, { image: Buffer.from(response.data) }, { quoted: message });\n                break;\n            }\n\n            default:\n                await sock.sendMessage(chatId, { text: 'Usage: .misc <heart|horny|circle|lgbt|lesbian|nonbinary|pansexual|transgender|lied|lolice|simpcard|tonikawa|its-so-stupid <text>|namecard u|b|d?|nobitches <text>|oogway <q>|oogway2 <q>|tweet dn|un|c|theme?|youtube-comment un|c>' }, { quoted: message });\n                break;\n        }\n    } catch (error) {\n        console.error('Error in misc command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to generate image. Check your parameters and try again.' }, { quoted: message });\n    }\n}\n\nmodule.exports = { miscCommand, handleHeart };\n\n\n","size_bytes":9656},"commands/mute.js":{"content":"const isAdmin = require('../lib/isAdmin');\n\nasync function muteCommand(sock, chatId, senderId, message, durationInMinutes) {\n    \n\n    const { isSenderAdmin, isBotAdmin } = await isAdmin(sock, chatId, senderId);\n    if (!isBotAdmin) {\n        await sock.sendMessage(chatId, { text: 'Please make the bot an admin first.' }, { quoted: message });\n        return;\n    }\n\n    if (!isSenderAdmin) {\n        await sock.sendMessage(chatId, { text: 'Only group admins can use the mute command.' }, { quoted: message });\n        return;\n    }\n\n    try {\n        // Mute the group\n        await sock.groupSettingUpdate(chatId, 'announcement');\n        \n        if (durationInMinutes !== undefined && durationInMinutes > 0) {\n            const durationInMilliseconds = durationInMinutes * 60 * 1000;\n            await sock.sendMessage(chatId, { text: `The group has been muted for ${durationInMinutes} minutes.` }, { quoted: message });\n            \n            // Set timeout to unmute after duration\n            setTimeout(async () => {\n                try {\n                    await sock.groupSettingUpdate(chatId, 'not_announcement');\n                    await sock.sendMessage(chatId, { text: 'The group has been unmuted.' });\n                } catch (unmuteError) {\n                    console.error('Error unmuting group:', unmuteError);\n                }\n            }, durationInMilliseconds);\n        } else {\n            await sock.sendMessage(chatId, { text: 'The group has been muted.' }, { quoted: message });\n        }\n    } catch (error) {\n        console.error('Error muting/unmuting the group:', error);\n        await sock.sendMessage(chatId, { text: 'An error occurred while muting/unmuting the group. Please try again.' }, { quoted: message });\n    }\n}\n\nmodule.exports = muteCommand;\n","size_bytes":1794},"commands/news.js":{"content":"const axios = require('axios');\n\nmodule.exports = async function (sock, chatId) {\n    try {\n        const apiKey = 'dcd720a6f1914e2d9dba9790c188c08c';  // Replace with your NewsAPI key\n        const response = await axios.get(`https://newsapi.org/v2/top-headlines?country=us&apiKey=${apiKey}`);\n        const articles = response.data.articles.slice(0, 5); // Get top 5 articles\n        let newsMessage = 'üì∞ *Latest News*:\\n\\n';\n        articles.forEach((article, index) => {\n            newsMessage += `${index + 1}. *${article.title}*\\n${article.description}\\n\\n`;\n        });\n        await sock.sendMessage(chatId, { text: newsMessage });\n    } catch (error) {\n        console.error('Error fetching news:', error);\n        await sock.sendMessage(chatId, { text: 'Sorry, I could not fetch news right now.' });\n    }\n};\n","size_bytes":823},"commands/owner.js":{"content":"const settings = require('../settings');\n\nasync function ownerCommand(sock, chatId) {\n    const vcard = `\nBEGIN:VCARD\nVERSION:3.0\nFN:${settings.botOwner}\nTEL;waid=${settings.ownerNumber}:${settings.ownerNumber}\nEND:VCARD\n`;\n\n    await sock.sendMessage(chatId, {\n        contacts: { displayName: settings.botOwner, contacts: [{ vcard }] },\n    });\n}\n\nmodule.exports = ownerCommand;\n","size_bytes":381},"commands/pair.js":{"content":"const axios = require('axios');\nconst { sleep } = require('../lib/myfunc');\n\nasync function pairCommand(sock, chatId, message, q) {\n    try {\n        if (!q) {\n            return await sock.sendMessage(chatId, {\n                text: \"Please provide valid WhatsApp number\\nExample: .pair 91702395XXXX\",\n                contextInfo: {\n                    forwardingScore: 1,\n                    isForwarded: true,\n                }\n            });\n        }\n\n        const numbers = q.split(',')\n            .map((v) => v.replace(/[^0-9]/g, ''))\n            .filter((v) => v.length > 5 && v.length < 20);\n\n        if (numbers.length === 0) {\n            return await sock.sendMessage(chatId, {\n                text: \"Invalid number‚ùåÔ∏è Please use the correct format!\",\n                contextInfo: {\n                    forwardingScore: 1,\n                    isForwarded: true,\n                }\n            });\n        }\n\n        for (const number of numbers) {\n            const whatsappID = number + '@s.whatsapp.net';\n            const result = await sock.onWhatsApp(whatsappID);\n\n            if (!result[0]?.exists) {\n                return await sock.sendMessage(chatId, {\n                    text: `That number is not registered on WhatsApp‚ùóÔ∏è`,\n                    contextInfo: {\n                        forwardingScore: 1,\n                        isForwarded: true,\n                    }\n                });\n            }\n\n            await sock.sendMessage(chatId, {\n                text: \"Wait a moment for the code\",\n                contextInfo: {\n                    forwardingScore: 1,\n                    isForwarded: true,\n                }\n            });\n\n            try {\n                const response = await axios.get(`https://knight-bot-paircode.onrender.com/code?number=${number}`);\n                \n                if (response.data && response.data.code) {\n                    const code = response.data.code;\n                    if (code === \"Service Unavailable\") {\n                        throw new Error('Service Unavailable');\n                    }\n                    \n                    await sleep(5000);\n                    await sock.sendMessage(chatId, {\n                        text: `Your pairing code: ${code}`,\n                        contextInfo: {\n                            forwardingScore: 1,\n                            isForwarded: true,\n                        }\n                    });\n                } else {\n                    throw new Error('Invalid response from server');\n                }\n            } catch (apiError) {\n                console.error('API Error:', apiError);\n                const errorMessage = apiError.message === 'Service Unavailable' \n                    ? \"Service is currently unavailable. Please try again later.\"\n                    : \"Failed to generate pairing code. Please try again later.\";\n                \n                await sock.sendMessage(chatId, {\n                    text: errorMessage,\n                    contextInfo: {\n                        forwardingScore: 1,\n                        isForwarded: true,\n                    }\n                });\n            }\n        }\n    } catch (error) {\n        console.error(error);\n        await sock.sendMessage(chatId, {\n            text: \"An error occurred. Please try again later.\",\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n    }\n}\n\nmodule.exports = pairCommand; ","size_bytes":3502},"commands/pies.js":{"content":"const fetch = require('node-fetch');\n\nconst BASE = 'https://shizoapi.onrender.com/api/pies';\nconst VALID_COUNTRIES = ['china', 'indonesia', 'japan', 'korea', 'hijab'];\n\nasync function fetchPiesImageBuffer(country) {\n\tconst url = `${BASE}/${country}?apikey=shizo`;\n\tconst res = await fetch(url);\n\tif (!res.ok) throw new Error(`HTTP ${res.status}`);\n\tconst contentType = res.headers.get('content-type') || '';\n\tif (!contentType.includes('image')) throw new Error('API did not return an image');\n\treturn res.buffer();\n}\n\nasync function piesCommand(sock, chatId, message, args) {\n\tconst sub = (args && args[0] ? args[0] : '').toLowerCase();\n\tif (!sub) {\n\t\tawait sock.sendMessage(chatId, { text: `Usage: .pies <country>\\nCountries: ${VALID_COUNTRIES.join(', ')}` }, { quoted: message });\n\t\treturn;\n\t}\n\tif (!VALID_COUNTRIES.includes(sub)) {\n\t\tawait sock.sendMessage(chatId, { text: `‚ùå Unsupported country: ${sub}. Try one of: ${VALID_COUNTRIES.join(', ')}` }, { quoted: message });\n\t\treturn;\n\t}\n\ttry {\n\t\tconst imageBuffer = await fetchPiesImageBuffer(sub);\n\t\tawait sock.sendMessage(\n\t\t\tchatId,\n\t\t\t{ image: imageBuffer, caption: `pies: ${sub}` },\n\t\t\t{ quoted: message }\n\t\t);\n\t} catch (err) {\n\t\tconsole.error('Error in pies command:', err);\n\t\tawait sock.sendMessage(chatId, { text: '‚ùå Failed to fetch image. Please try again.' }, { quoted: message });\n\t}\n}\n\nasync function piesAlias(sock, chatId, message, country) {\n\ttry {\n\t\tconst imageBuffer = await fetchPiesImageBuffer(country);\n\t\tawait sock.sendMessage(\n\t\t\tchatId,\n\t\t\t{ image: imageBuffer, caption: `pies: ${country}` },\n\t\t\t{ quoted: message }\n\t\t);\n\t} catch (err) {\n\t\tconsole.error(`Error in pies alias (${country}) command:`, err);\n\t\tawait sock.sendMessage(chatId, { text: '‚ùå Failed to fetch image. Please try again.' }, { quoted: message });\n\t}\n}\n\nmodule.exports = { piesCommand, piesAlias, VALID_COUNTRIES };\n","size_bytes":1865},"commands/ping.js":{"content":"const os = require('os');\nconst settings = require('../settings.js');\n\nfunction formatTime(seconds) {\n    const days = Math.floor(seconds / (24 * 60 * 60));\n    seconds = seconds % (24 * 60 * 60);\n    const hours = Math.floor(seconds / (60 * 60));\n    seconds = seconds % (60 * 60);\n    const minutes = Math.floor(seconds / 60);\n    seconds = Math.floor(seconds % 60);\n\n    let time = '';\n    if (days > 0) time += `${days}d `;\n    if (hours > 0) time += `${hours}h `;\n    if (minutes > 0) time += `${minutes}m `;\n    if (seconds > 0 || time === '') time += `${seconds}s`;\n\n    return time.trim();\n}\n\nasync function pingCommand(sock, chatId, message) {\n    try {\n        const start = Date.now();\n        await sock.sendMessage(chatId, { text: 'Pong!' }, { quoted: message });\n        const end = Date.now();\n        const ping = Math.round((end - start) / 2);\n\n        const uptimeInSeconds = process.uptime();\n        const uptimeFormatted = formatTime(uptimeInSeconds);\n\n        const botInfo = `\n‚îè‚îÅ‚îÅ„Äî ü§ñ ùêäùêßùê¢ùê†ùê°ùê≠ùêÅùê®ùê≠-ùêåùêÉ „Äï‚îÅ‚îÅ‚îì\n‚îÉ üöÄ Ping     : ${ping} ms\n‚îÉ ‚è±Ô∏è Uptime   : ${uptimeFormatted}\n‚îÉ üîñ Version  : v${settings.version}\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`.trim();\n\n        // Reply to the original message with the bot info\n        await sock.sendMessage(chatId, { text: botInfo},{ quoted: message });\n\n    } catch (error) {\n        console.error('Error in ping command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get bot status.' });\n    }\n}\n\nmodule.exports = pingCommand;\n","size_bytes":1602},"commands/play.js":{"content":"const yts = require('yt-search');\nconst axios = require('axios');\n\nasync function playCommand(sock, chatId, message) {\n    try {\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        const searchQuery = text.split(' ').slice(1).join(' ').trim();\n        \n        if (!searchQuery) {\n            return await sock.sendMessage(chatId, { \n                text: \"What song do you want to download?\"\n            });\n        }\n\n        // Search for the song\n        const { videos } = await yts(searchQuery);\n        if (!videos || videos.length === 0) {\n            return await sock.sendMessage(chatId, { \n                text: \"No songs found!\"\n            });\n        }\n\n        // Send loading message\n        await sock.sendMessage(chatId, {\n            text: \"_Please wait your download is in progress_\"\n        });\n\n        // Get the first video result\n        const video = videos[0];\n        const urlYt = video.url;\n\n        // Fetch audio data from API\n        const response = await axios.get(`https://apis-keith.vercel.app/download/dlmp3?url=${urlYt}`);\n        const data = response.data;\n\n        if (!data || !data.status || !data.result || !data.result.downloadUrl) {\n            return await sock.sendMessage(chatId, { \n                text: \"Failed to fetch audio from the API. Please try again later.\"\n            });\n        }\n\n        const audioUrl = data.result.downloadUrl;\n        const title = data.result.title;\n\n        // Send the audio\n        await sock.sendMessage(chatId, {\n            audio: { url: audioUrl },\n            mimetype: \"audio/mpeg\",\n            fileName: `${title}.mp3`\n        }, { quoted: message });\n\n    } catch (error) {\n        console.error('Error in song2 command:', error);\n        await sock.sendMessage(chatId, { \n            text: \"Download failed. Please try again later.\"\n        });\n    }\n}\n\nmodule.exports = playCommand; \n\n/*Powered by KNIGHT-BOT*\n*Credits to Keith MD*`*/","size_bytes":1986},"commands/pmblocker.js":{"content":"const fs = require('fs');\n\nconst PMBLOCKER_PATH = './data/pmblocker.json';\n\nfunction readState() {\n    try {\n        if (!fs.existsSync(PMBLOCKER_PATH)) return { enabled: false, message: '‚ö†Ô∏è Direct messages are blocked!\\nYou cannot DM this bot. Please contact the owner in group chats only.' };\n        const raw = fs.readFileSync(PMBLOCKER_PATH, 'utf8');\n        const data = JSON.parse(raw || '{}');\n        return {\n            enabled: !!data.enabled,\n            message: typeof data.message === 'string' && data.message.trim() ? data.message : '‚ö†Ô∏è Direct messages are blocked!\\nYou cannot DM this bot. Please contact the owner in group chats only.'\n        };\n    } catch {\n        return { enabled: false, message: '‚ö†Ô∏è Direct messages are blocked!\\nYou cannot DM this bot. Please contact the owner in group chats only.' };\n    }\n}\n\nfunction writeState(enabled, message) {\n    try {\n        if (!fs.existsSync('./data')) fs.mkdirSync('./data', { recursive: true });\n        const current = readState();\n        const payload = {\n            enabled: !!enabled,\n            message: typeof message === 'string' && message.trim() ? message : current.message\n        };\n        fs.writeFileSync(PMBLOCKER_PATH, JSON.stringify(payload, null, 2));\n    } catch {}\n}\n\nasync function pmblockerCommand(sock, chatId, message, args) {\n    // Check if sender is the owner or sudo\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudo = require('../lib/isOwner');\n    const hasPermission = await isOwnerOrSudo(senderJid);\n\n    if (!hasPermission) {\n        await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo users!' }, { quoted: message });\n        return;\n    }\n\n    const argStr = (args || '').trim();\n    const [sub, ...rest] = argStr.split(' ');\n    const state = readState();\n\n    if (!sub || !['on', 'off', 'status', 'setmsg'].includes(sub.toLowerCase())) {\n        await sock.sendMessage(chatId, { text: '*PMBLOCKER (Owner only)*\\n\\n.pmblocker on - Enable PM auto-block\\n.pmblocker off - Disable PM blocker\\n.pmblocker status - Show current status\\n.pmblocker setmsg <text> - Set warning message' }, { quoted: message });\n        return;\n    }\n\n    if (sub.toLowerCase() === 'status') {\n        await sock.sendMessage(chatId, { text: `PM Blocker is currently *${state.enabled ? 'ON' : 'OFF'}*\\nMessage: ${state.message}` }, { quoted: message });\n        return;\n    }\n\n    if (sub.toLowerCase() === 'setmsg') {\n        const newMsg = rest.join(' ').trim();\n        if (!newMsg) {\n            await sock.sendMessage(chatId, { text: 'Usage: .pmblocker setmsg <message>' }, { quoted: message });\n            return;\n        }\n        writeState(state.enabled, newMsg);\n        await sock.sendMessage(chatId, { text: 'PM Blocker message updated.' }, { quoted: message });\n        return;\n    }\n\n    const enable = sub.toLowerCase() === 'on';\n    writeState(enable);\n    await sock.sendMessage(chatId, { text: `PM Blocker is now *${enable ? 'ENABLED' : 'DISABLED'}*.` }, { quoted: message });\n}\n\nmodule.exports = { pmblockerCommand, readState };\n\n\n","size_bytes":3143},"commands/promote.js":{"content":"const { isAdmin } = require('../lib/isAdmin');\n\n// Function to handle manual promotions via command\nasync function promoteCommand(sock, chatId, mentionedJids, message) {\n    let userToPromote = [];\n    \n    // Check for mentioned users\n    if (mentionedJids && mentionedJids.length > 0) {\n        userToPromote = mentionedJids;\n    }\n    // Check for replied message\n    else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n        userToPromote = [message.message.extendedTextMessage.contextInfo.participant];\n    }\n    \n    // If no user found through either method\n    if (userToPromote.length === 0) {\n        await sock.sendMessage(chatId, { \n            text: 'Please mention the user or reply to their message to promote!'\n        });\n        return;\n    }\n\n    try {\n        await sock.groupParticipantsUpdate(chatId, userToPromote, \"promote\");\n        \n        // Get usernames for each promoted user\n        const usernames = await Promise.all(userToPromote.map(async jid => {\n            \n            return `@${jid.split('@')[0]}`;\n        }));\n\n        // Get promoter's name (the bot user in this case)\n        const promoterJid = sock.user.id;\n        \n        const promotionMessage = `*„Äé GROUP PROMOTION „Äè*\\n\\n` +\n            `üë• *Promoted User${userToPromote.length > 1 ? 's' : ''}:*\\n` +\n            `${usernames.map(name => `‚Ä¢ ${name}`).join('\\n')}\\n\\n` +\n            `üëë *Promoted By:* @${promoterJid.split('@')[0]}\\n\\n` +\n            `üìÖ *Date:* ${new Date().toLocaleString()}`;\n        await sock.sendMessage(chatId, { \n            text: promotionMessage,\n            mentions: [...userToPromote, promoterJid]\n        });\n    } catch (error) {\n        console.error('Error in promote command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to promote user(s)!'});\n    }\n}\n\n// Function to handle automatic promotion detection\nasync function handlePromotionEvent(sock, groupId, participants, author) {\n    try {\n       /* console.log('Promotion Event Data:', {\n            groupId,\n            participants,\n            author\n        });*/\n\n        // Get usernames for promoted participants\n        const promotedUsernames = await Promise.all(participants.map(async jid => {\n            return `@${jid.split('@')[0]} `;\n        }));\n\n        let promotedBy;\n        let mentionList = [...participants];\n\n        if (author && author.length > 0) {\n            // Ensure author has the correct format\n            const authorJid = author;\n            promotedBy = `@${authorJid.split('@')[0]}`;\n            mentionList.push(authorJid);\n        } else {\n            promotedBy = 'System';\n        }\n\n        const promotionMessage = `*„Äé GROUP PROMOTION „Äè*\\n\\n` +\n            `üë• *Promoted User${participants.length > 1 ? 's' : ''}:*\\n` +\n            `${promotedUsernames.map(name => `‚Ä¢ ${name}`).join('\\n')}\\n\\n` +\n            `üëë *Promoted By:* ${promotedBy}\\n\\n` +\n            `üìÖ *Date:* ${new Date().toLocaleString()}`;\n        \n        await sock.sendMessage(groupId, {\n            text: promotionMessage,\n            mentions: mentionList\n        });\n    } catch (error) {\n        console.error('Error handling promotion event:', error);\n    }\n}\n\nmodule.exports = { promoteCommand, handlePromotionEvent };\n","size_bytes":3296},"commands/quote.js":{"content":"const fetch = require('node-fetch');\n\nmodule.exports = async function quoteCommand(sock, chatId, message) {\n    try {\n        const shizokeys = 'shizo';\n        const res = await fetch(`https://shizoapi.onrender.com/api/texts/quotes?apikey=${shizokeys}`);\n        \n        if (!res.ok) {\n            throw await res.text();\n        }\n        \n        const json = await res.json();\n        const quoteMessage = json.result;\n\n        // Send the quote message\n        await sock.sendMessage(chatId, { text: quoteMessage }, { quoted: message });\n    } catch (error) {\n        console.error('Error in quote command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get quote. Please try again later!' }, { quoted: message });\n    }\n};\n","size_bytes":755},"commands/remini.js":{"content":"const axios = require('axios');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\nconst { uploadImage } = require('../lib/uploadImage');\n\nasync function getQuotedOrOwnImageUrl(sock, message) {\n    // 1) Quoted image (highest priority)\n    const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n    if (quoted?.imageMessage) {\n        const stream = await downloadContentFromMessage(quoted.imageMessage, 'image');\n        const chunks = [];\n        for await (const chunk of stream) chunks.push(chunk);\n        const buffer = Buffer.concat(chunks);\n        return await uploadImage(buffer);\n    }\n\n    // 2) Image in the current message\n    if (message.message?.imageMessage) {\n        const stream = await downloadContentFromMessage(message.message.imageMessage, 'image');\n        const chunks = [];\n        for await (const chunk of stream) chunks.push(chunk);\n        const buffer = Buffer.concat(chunks);\n        return await uploadImage(buffer);\n    }\n\n    return null;\n}\n\nasync function reminiCommand(sock, chatId, message, args) {\n    try {\n        let imageUrl = null;\n        \n        // Check if args contain a URL\n        if (args.length > 0) {\n            const url = args.join(' ');\n            if (isValidUrl(url)) {\n                imageUrl = url;\n            } else {\n                return sock.sendMessage(chatId, { \n                    text: '‚ùå Invalid URL provided.\\n\\nUsage: `.remini https://example.com/image.jpg`' \n                }, { quoted: message });\n            }\n        } else {\n            // Try to get image from message or quoted message\n            imageUrl = await getQuotedOrOwnImageUrl(sock, message);\n            \n            if (!imageUrl) {\n                return sock.sendMessage(chatId, { \n                    text: 'üì∏ *Remini AI Enhancement Command*\\n\\nUsage:\\n‚Ä¢ `.remini <image_url>`\\n‚Ä¢ Reply to an image with `.remini`\\n‚Ä¢ Send image with `.remini`\\n\\nExample: `.remini https://example.com/image.jpg`' \n                }, { quoted: message });\n            }\n        }\n\n        // Call the Remini API\n        const apiUrl = `https://api.princetechn.com/api/tools/remini?apikey=prince_tech_api_azfsbshfb&url=${encodeURIComponent(imageUrl)}`;\n        \n        const response = await axios.get(apiUrl, {\n            timeout: 60000, // 60 second timeout (AI processing takes longer)\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            }\n        });\n\n\n        if (response.data && response.data.success && response.data.result) {\n            const result = response.data.result;\n            \n            if (result.image_url) {\n                // Download the enhanced image\n                const imageResponse = await axios.get(result.image_url, {\n                    responseType: 'arraybuffer',\n                    timeout: 30000\n                });\n                \n                if (imageResponse.status === 200 && imageResponse.data) {\n                    // Send the enhanced image\n                    await sock.sendMessage(chatId, {\n                        image: imageResponse.data,\n                        caption: '‚ú® *Image enhanced successfully!*\\n\\nùóòùó°ùóõùóîùó°ùóñùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß'\n                    }, { quoted: message });\n                } else {\n                    throw new Error('Failed to download enhanced image');\n                }\n            } else {\n                throw new Error(result.message || 'Failed to enhance image');\n            }\n        } else {\n            throw new Error('API returned invalid response');\n        }\n\n    } catch (error) {\n        console.error('Remini Error:', error.message);\n        \n        let errorMessage = '‚ùå Failed to enhance image.';\n        \n        if (error.response?.status === 429) {\n            errorMessage = '‚è∞ Rate limit exceeded. Please try again later.';\n        } else if (error.response?.status === 400) {\n            errorMessage = '‚ùå Invalid image URL or format.';\n        } else if (error.response?.status === 500) {\n            errorMessage = 'üîß Server error. Please try again later.';\n        } else if (error.code === 'ECONNABORTED') {\n            errorMessage = '‚è∞ Request timeout. Please try again.';\n        } else if (error.message.includes('ENOTFOUND') || error.message.includes('ECONNREFUSED')) {\n            errorMessage = 'üåê Network error. Please check your connection.';\n        } else if (error.message.includes('Error processing image')) {\n            errorMessage = '‚ùå Image processing failed. Please try with a different image.';\n        }\n        \n        await sock.sendMessage(chatId, { \n            text: errorMessage \n        }, { quoted: message });\n    }\n}\n\n// Helper function to validate URL\nfunction isValidUrl(string) {\n    try {\n        new URL(string);\n        return true;\n    } catch (_) {\n        return false;\n    }\n}\n\nmodule.exports = { reminiCommand };\n","size_bytes":5018},"commands/removebg.js":{"content":"const axios = require('axios');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\nconst { uploadImage } = require('../lib/uploadImage');\n\nasync function getQuotedOrOwnImageUrl(sock, message) {\n    // 1) Quoted image (highest priority)\n    const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n    if (quoted?.imageMessage) {\n        const stream = await downloadContentFromMessage(quoted.imageMessage, 'image');\n        const chunks = [];\n        for await (const chunk of stream) chunks.push(chunk);\n        const buffer = Buffer.concat(chunks);\n        return await uploadImage(buffer);\n    }\n\n    // 2) Image in the current message\n    if (message.message?.imageMessage) {\n        const stream = await downloadContentFromMessage(message.message.imageMessage, 'image');\n        const chunks = [];\n        for await (const chunk of stream) chunks.push(chunk);\n        const buffer = Buffer.concat(chunks);\n        return await uploadImage(buffer);\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    name: 'removebg',\n    alias: ['rmbg', 'nobg'],\n    category: 'general',\n    desc: 'Remove background from images',\n    async exec(sock, message, args) {\n        try {\n            const chatId = message.key.remoteJid;\n            let imageUrl = null;\n            \n            // Check if args contain a URL\n            if (args.length > 0) {\n                const url = args.join(' ');\n                if (isValidUrl(url)) {\n                    imageUrl = url;\n                } else {\n                    return sock.sendMessage(chatId, { \n                        text: '‚ùå Invalid URL provided.\\n\\nUsage: `.removebg https://example.com/image.jpg`' \n                    }, { quoted: message });\n                }\n            } else {\n                // Try to get image from message or quoted message\n                imageUrl = await getQuotedOrOwnImageUrl(sock, message);\n                \n                if (!imageUrl) {\n                    return sock.sendMessage(chatId, { \n                        text: 'üì∏ *Remove Background Command*\\n\\nUsage:\\n‚Ä¢ `.removebg <image_url>`\\n‚Ä¢ Reply to an image with `.removebg`\\n‚Ä¢ Send image with `.removebg`\\n\\nExample: `.removebg https://example.com/image.jpg`' \n                    }, { quoted: message });\n                }\n            }\n\n        \n            // Call the remove background API\n            const apiUrl = `https://api.siputzx.my.id/api/iloveimg/removebg?image=${encodeURIComponent(imageUrl)}`;\n            \n            const response = await axios.get(apiUrl, {\n                responseType: 'arraybuffer',\n                timeout: 30000, // 30 second timeout\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                }\n            });\n\n            if (response.status === 200 && response.data) {\n                // Send the processed image\n                await sock.sendMessage(chatId, {\n                    image: response.data,\n                    caption: '‚ú® *Background removed successfully!*\\n\\nùó£ùó•ùó¢ùóñùóòùó¶ùó¶ùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß'\n                }, { quoted: message });\n            } else {\n                throw new Error('Failed to process image');\n            }\n\n        } catch (error) {\n            console.error('RemoveBG Error:', error.message);\n            \n            let errorMessage = '‚ùå Failed to remove background.';\n            \n            if (error.response?.status === 429) {\n                errorMessage = '‚è∞ Rate limit exceeded. Please try again later.';\n            } else if (error.response?.status === 400) {\n                errorMessage = '‚ùå Invalid image URL or format.';\n            } else if (error.response?.status === 500) {\n                errorMessage = 'üîß Server error. Please try again later.';\n            } else if (error.code === 'ECONNABORTED') {\n                errorMessage = '‚è∞ Request timeout. Please try again.';\n            } else if (error.message.includes('ENOTFOUND') || error.message.includes('ECONNREFUSED')) {\n                errorMessage = 'üåê Network error. Please check your connection.';\n            }\n            \n            await sock.sendMessage(chatId, { \n                text: errorMessage \n            }, { quoted: message });\n        }\n    }\n};\n\n// Helper function to validate URL\nfunction isValidUrl(string) {\n    try {\n        new URL(string);\n        return true;\n    } catch (_) {\n        return false;\n    }\n}\n","size_bytes":4548},"commands/resetlink.js":{"content":"async function resetlinkCommand(sock, chatId, senderId) {\n    try {\n        // Check if sender is admin\n        const groupMetadata = await sock.groupMetadata(chatId);\n        const isAdmin = groupMetadata.participants\n            .filter(p => p.admin)\n            .map(p => p.id)\n            .includes(senderId);\n\n        // Check if bot is admin\n        const botId = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n        const isBotAdmin = groupMetadata.participants\n            .filter(p => p.admin)\n            .map(p => p.id)\n            .includes(botId);\n\n        if (!isAdmin) {\n            await sock.sendMessage(chatId, { text: '‚ùå Only admins can use this command!' });\n            return;\n        }\n\n        if (!isBotAdmin) {\n            await sock.sendMessage(chatId, { text: '‚ùå Bot must be admin to reset group link!' });\n            return;\n        }\n\n        // Reset the group link\n        const newCode = await sock.groupRevokeInvite(chatId);\n        \n        // Send the new link\n        await sock.sendMessage(chatId, { \n            text: `‚úÖ Group link has been successfully reset\\n\\nüìå New link:\\nhttps://chat.whatsapp.com/${newCode}`\n        });\n\n    } catch (error) {\n        console.error('Error in resetlink command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to reset group link!' });\n    }\n}\n\nmodule.exports = resetlinkCommand; ","size_bytes":1387},"commands/roseday.js":{"content":"const fetch = require('node-fetch');\n\nasync function rosedayCommand(sock, chatId, message) {\n    try {\n        \n        const res = await fetch(`https://api.princetechn.com/api/fun/roseday?apikey=prince`);\n        \n        if (!res.ok) {\n            throw await res.text();\n        }\n        \n        const json = await res.json();\n        const rosedayMessage = json.result;\n\n        // Send the roseday message\n        await sock.sendMessage(chatId, { text: rosedayMessage }, { quoted: message });\n    } catch (error) {\n        console.error('Error in roseday command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get roseday quote. Please try again later!' }, { quoted: message });\n    }\n}\n\nmodule.exports = { rosedayCommand };\n","size_bytes":758},"commands/setpp.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\n\nasync function setProfilePicture(sock, chatId, msg) {\n    try {\n        // Check if user is owner\n        const senderJid = msg.key.participant || msg.key.remoteJid;\n        const isOwnerOrSudoFunc = require('../lib/isOwner');\n        const isOwner = await isOwnerOrSudoFunc(senderJid);\n        \n        if (!isOwner) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå This command is only available for the owner or sudo users!' \n            });\n            return;\n        }\n\n        // Check if message is a reply\n        const quotedMessage = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n        if (!quotedMessage) {\n            await sock.sendMessage(chatId, { \n                text: '‚ö†Ô∏è Please reply to an image with the .setpp command!' \n            });\n            return;\n        }\n\n        // Check if quoted message contains an image\n        const imageMessage = quotedMessage.imageMessage || quotedMessage.stickerMessage;\n        if (!imageMessage) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå The replied message must contain an image!' \n            });\n            return;\n        }\n\n        // Create tmp directory if it doesn't exist\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) {\n            fs.mkdirSync(tmpDir, { recursive: true });\n        }\n\n        // Download the image\n        const stream = await downloadContentFromMessage(imageMessage, 'image');\n        let buffer = Buffer.from([]);\n        \n        for await (const chunk of stream) {\n            buffer = Buffer.concat([buffer, chunk]);\n        }\n\n        const imagePath = path.join(tmpDir, `profile_${Date.now()}.jpg`);\n        \n        // Save the image\n        fs.writeFileSync(imagePath, buffer);\n\n        // Set the profile picture\n        await sock.updateProfilePicture(sock.user.id, { url: imagePath });\n\n        // Clean up the temporary file\n        fs.unlinkSync(imagePath);\n\n        await sock.sendMessage(chatId, { \n            text: '‚úÖ Successfully updated bot profile picture!' \n        });\n\n    } catch (error) {\n        console.error('Error in setpp command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to update profile picture!' \n        });\n    }\n}\n\nmodule.exports = setProfilePicture; ","size_bytes":2482},"commands/settings.js":{"content":"\nconst fs = require('fs');\n\nfunction readJsonSafe(path, fallback) {\n    try {\n        const txt = fs.readFileSync(path, 'utf8');\n        return JSON.parse(txt);\n    } catch (_) {\n        return fallback;\n    }\n}\n\nasync function settingsCommand(sock, chatId, message) {\n    try {\n        // Check if sender is the owner or sudo\n        const senderJid = message.key.participant || message.key.remoteJid;\n        const isOwnerOrSudo = require('../lib/isOwner');\n        const hasPermission = await isOwnerOrSudo(senderJid);\n\n        if (!hasPermission) {\n            await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner or sudo users!' });\n            return;\n        }\n\n        const isGroup = chatId.endsWith('@g.us');\n        const dataDir = './data';\n\n        const mode = readJsonSafe(`${dataDir}/messageCount.json`, { isPublic: true });\n        const autoStatus = readJsonSafe(`${dataDir}/autoStatus.json`, { enabled: false });\n        const autoread = readJsonSafe(`${dataDir}/autoread.json`, { enabled: false });\n        const autotyping = readJsonSafe(`${dataDir}/autotyping.json`, { enabled: false });\n        const pmblocker = readJsonSafe(`${dataDir}/pmblocker.json`, { enabled: false });\n        const userGroupData = readJsonSafe(`${dataDir}/userGroupData.json`, {\n            antilink: {}, antibadword: {}, welcome: {}, goodbye: {}, chatbot: {}, antitag: {}\n        });\n        const autoReaction = Boolean(userGroupData.autoReaction);\n\n        // Per-group features\n        const groupId = isGroup ? chatId : null;\n        const antilinkOn = groupId ? Boolean(userGroupData.antilink && userGroupData.antilink[groupId]) : false;\n        const antibadwordOn = groupId ? Boolean(userGroupData.antibadword && userGroupData.antibadword[groupId]) : false;\n        const welcomeOn = groupId ? Boolean(userGroupData.welcome && userGroupData.welcome[groupId]) : false;\n        const goodbyeOn = groupId ? Boolean(userGroupData.goodbye && userGroupData.goodbye[groupId]) : false;\n        const chatbotOn = groupId ? Boolean(userGroupData.chatbot && userGroupData.chatbot[groupId]) : false;\n        const antitagCfg = groupId ? (userGroupData.antitag && userGroupData.antitag[groupId]) : null;\n\n        const lines = [];\n        lines.push('*BOT SETTINGS*');\n        lines.push('');\n        lines.push(`‚Ä¢ Mode: ${mode.isPublic ? 'Public' : 'Private'}`);\n        lines.push(`‚Ä¢ Auto Status: ${autoStatus.enabled ? 'ON' : 'OFF'}`);\n        lines.push(`‚Ä¢ Autoread: ${autoread.enabled ? 'ON' : 'OFF'}`);\n        lines.push(`‚Ä¢ Autotyping: ${autotyping.enabled ? 'ON' : 'OFF'}`);\n        lines.push(`‚Ä¢ PM Blocker: ${pmblocker.enabled ? 'ON' : 'OFF'}`);\n        lines.push(`‚Ä¢ Auto Reaction: ${autoReaction ? 'ON' : 'OFF'}`);\n        if (groupId) {\n            lines.push('');\n            lines.push(`Group: ${groupId}`);\n            if (antilinkOn) {\n                const al = userGroupData.antilink[groupId];\n                lines.push(`‚Ä¢ Antilink: ON (action: ${al.action || 'delete'})`);\n            } else {\n                lines.push('‚Ä¢ Antilink: OFF');\n            }\n            if (antibadwordOn) {\n                const ab = userGroupData.antibadword[groupId];\n                lines.push(`‚Ä¢ Antibadword: ON (action: ${ab.action || 'delete'})`);\n            } else {\n                lines.push('‚Ä¢ Antibadword: OFF');\n            }\n            lines.push(`‚Ä¢ Welcome: ${welcomeOn ? 'ON' : 'OFF'}`);\n            lines.push(`‚Ä¢ Goodbye: ${goodbyeOn ? 'ON' : 'OFF'}`);\n            lines.push(`‚Ä¢ Chatbot: ${chatbotOn ? 'ON' : 'OFF'}`);\n            if (antitagCfg && antitagCfg.enabled) {\n                lines.push(`‚Ä¢ Antitag: ON (action: ${antitagCfg.action || 'delete'})`);\n            } else {\n                lines.push('‚Ä¢ Antitag: OFF');\n            }\n        } else {\n            lines.push('');\n            lines.push('Note: Per-group settings will be shown when used inside a group.');\n        }\n\n        await sock.sendMessage(chatId, { text: lines.join('\\n') }, { quoted: message });\n    } catch (error) {\n        console.error('Error in settings command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to read settings.' }, { quoted: message });\n    }\n}\n\nmodule.exports = settingsCommand;\n","size_bytes":4280},"commands/shayari.js":{"content":"const fetch = require('node-fetch');\n\nasync function shayariCommand(sock, chatId, message) {\n    try {\n        const response = await fetch('https://shizoapi.onrender.com/api/texts/shayari?apikey=shizo');\n        const data = await response.json();\n        \n        if (!data || !data.result) {\n            throw new Error('Invalid response from API');\n        }\n\n        const buttons = [\n            { buttonId: '.shayari', buttonText: { displayText: 'Shayari ü™Ñ' }, type: 1 },\n            { buttonId: '.roseday', buttonText: { displayText: 'üåπ RoseDay' }, type: 1 }\n        ];\n\n        await sock.sendMessage(chatId, { \n            text: data.result,\n            buttons: buttons,\n            headerType: 1\n        }, { quoted: message });\n    } catch (error) {\n        console.error('Error in shayari command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to fetch shayari. Please try again later.',\n        }, { quoted: message });\n    }\n}\n\nmodule.exports = { shayariCommand }; ","size_bytes":1023},"commands/ship.js":{"content":"async function shipCommand(sock, chatId, msg, groupMetadata) {\n    try {\n        // Get all participants from the group\n        const participants = await sock.groupMetadata(chatId);\n        const ps = participants.participants.map(v => v.id);\n        \n        // Get two random participants\n        let firstUser, secondUser;\n        \n        // Select first random user\n        firstUser = ps[Math.floor(Math.random() * ps.length)];\n        \n        // Select second random user (different from first)\n        do {\n            secondUser = ps[Math.floor(Math.random() * ps.length)];\n        } while (secondUser === firstUser);\n\n        // Format the mentions\n        const formatMention = id => '@' + id.split('@')[0];\n\n        // Create and send the ship message\n        await sock.sendMessage(chatId, {\n            text: `${formatMention(firstUser)} ‚ù§Ô∏è ${formatMention(secondUser)}\\nCongratulations üíñüçª`,\n            mentions: [firstUser, secondUser]\n        });\n\n    } catch (error) {\n        console.error('Error in ship command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to ship! Make sure this is a group.' });\n    }\n}\n\nmodule.exports = shipCommand; ","size_bytes":1194},"commands/simage.js":{"content":"const sharp = require('sharp');\nconst fs = require('fs');\nconst fsPromises = require('fs/promises');\nconst fse = require('fs-extra');\nconst path = require('path');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\n\nconst tempDir = './temp';\nif (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);\n\nconst scheduleFileDeletion = (filePath) => {\n    setTimeout(async () => {\n        try {\n            await fse.remove(filePath);\n            console.log(`File deleted: ${filePath}`);\n        } catch (error) {\n            console.error(`Failed to delete file:`, error);\n        }\n    }, 10000); // 5 minutes\n};\n\nconst convertStickerToImage = async (sock, quotedMessage, chatId) => {\n    try {\n        const stickerMessage = quotedMessage.stickerMessage;\n        if (!stickerMessage) {\n            await sock.sendMessage(chatId, { text: 'Reply to a sticker with .simage to convert it.' });\n            return;\n        }\n\n        const stickerFilePath = path.join(tempDir, `sticker_${Date.now()}.webp`);\n        const outputImagePath = path.join(tempDir, `converted_image_${Date.now()}.png`);\n\n        const stream = await downloadContentFromMessage(stickerMessage, 'sticker');\n        let buffer = Buffer.from([]);\n        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);\n\n        await fsPromises.writeFile(stickerFilePath, buffer);\n        await sharp(stickerFilePath).toFormat('png').toFile(outputImagePath);\n\n        const imageBuffer = await fsPromises.readFile(outputImagePath);\n        await sock.sendMessage(chatId, { image: imageBuffer, caption: 'Here is the converted image!' });\n\n        scheduleFileDeletion(stickerFilePath);\n        scheduleFileDeletion(outputImagePath);\n    } catch (error) {\n        console.error('Error converting sticker to image:', error);\n        await sock.sendMessage(chatId, { text: 'An error occurred while converting the sticker.' });\n    }\n};\n\nmodule.exports = convertStickerToImage;\n","size_bytes":1968},"commands/simp.js":{"content":"const fetch = require('node-fetch');\n\nasync function simpCommand(sock, chatId, quotedMsg, mentionedJid, sender) {\n    try {\n        // Determine the target user\n        let who = quotedMsg \n            ? quotedMsg.sender \n            : mentionedJid && mentionedJid[0] \n                ? mentionedJid[0] \n                : sender;\n\n        // Get the profile picture URL\n        let avatarUrl;\n        try {\n            avatarUrl = await sock.profilePictureUrl(who, 'image');\n        } catch (error) {\n            console.error('Error fetching profile picture:', error);\n            avatarUrl = 'https://telegra.ph/file/24fa902ead26340f3df2c.png'; // Default avatar\n        }\n\n        // Fetch the simp card from the API\n        const apiUrl = `https://some-random-api.com/canvas/misc/simpcard?avatar=${encodeURIComponent(avatarUrl)}`;\n        const response = await fetch(apiUrl);\n        \n        if (!response.ok) {\n            throw new Error(`API responded with status: ${response.status}`);\n        }\n\n        // Get the image buffer\n        const imageBuffer = await response.buffer();\n\n        // Send the image with caption\n        await sock.sendMessage(chatId, {\n            image: imageBuffer,\n            caption: '*your religion is simping*',\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n\n    } catch (error) {\n        console.error('Error in simp command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Sorry, I couldn\\'t generate the simp card. Please try again later!',\n            contextInfo: {\n                forwardingScore: 1,\n                isForwarded: true,\n            }\n        });\n    }\n}\n\nmodule.exports = { simpCommand }; ","size_bytes":1760},"commands/song.js":{"content":"/*Cr√©ditos A Quien Correspondan \nPlay Traido y Editado \nPor Cuervo-Team-Supreme*/\nconst axios = require('axios');\nconst crypto = require('crypto');\nconst yts = require('yt-search');\nconst fs = require('fs');\nconst path = require('path');\nconst { exec } = require('child_process');\nconst util = require('util');\nconst execPromise = util.promisify(exec);\nconst ytdl = require('@distube/ytdl-core');\nlet ytdlp;\ntry { ytdlp = require('yt-dlp-exec'); } catch (_) { ytdlp = null; }\n\n// Helper: richer diagnostics for axios/network errors\nfunction logAxiosError(prefix, error) {\n\ttry {\n\t\tconst status = error?.response?.status;\n\t\tconst statusText = error?.response?.statusText;\n\t\tconst url = error?.config?.url;\n\t\tconst method = error?.config?.method;\n\t\tconst headers = error?.response?.headers;\n\t\tconst dataPreview = (() => {\n\t\t\tif (!error?.response?.data) return undefined;\n\t\t\tif (Buffer.isBuffer(error.response.data)) return `<buffer ${error.response.data.length} bytes>`;\n\t\t\tconst str = typeof error.response.data === 'string' ? error.response.data : JSON.stringify(error.response.data);\n\t\t\treturn str.slice(0, 500);\n\t\t})();\n\t\tconsole.error(`[${prefix}] AxiosError:`, {\n\t\t\tmessage: error?.message,\n\t\t\tcode: error?.code,\n\t\t\turl,\n\t\t\tmethod,\n\t\t\tstatus,\n\t\t\tstatusText,\n\t\t\theaders,\n\t\t\tdataPreview\n\t\t});\n\t} catch (e) {\n\t\tconsole.error(`[${prefix}] Failed to log axios error`, e);\n\t}\n}\n\n// PrinceTech YT-MP3 API client\nconst princeApi = {\n    base: 'https://api.princetechn.com/api/download/ytmp3',\n    apikey: process.env.PRINCE_API_KEY || 'prince_tech_api_azfsbshfb',\n    async fetchMeta(videoUrl) {\n        const params = new URLSearchParams({ apikey: this.apikey, url: videoUrl });\n        const url = `${this.base}?${params.toString()}`;\n        \n        const { data } = await axios.get(url, {\n            timeout: 20000,\n            headers: { 'user-agent': 'Mozilla/5.0', accept: 'application/json' }\n        });\n        return data;\n    }\n};\n\nconst savetube = {\n   api: {\n      base: \"https://media.savetube.me/api\",\n      cdn: \"/random-cdn\",\n      info: \"/v2/info\",\n      download: \"/download\"\n   },\n   headers: {\n      'accept': '*/*',\n      'content-type': 'application/json',\n      'origin': 'https://yt.savetube.me',\n      'referer': 'https://yt.savetube.me/',\n      'accept-language': 'en-US,en;q=0.9',\n      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36'\n   },\n   formats: ['144', '240', '360', '480', '720', '1080', 'mp3'],\n   crypto: {\n      hexToBuffer: (hexString) => {\n         const matches = hexString.match(/.{1,2}/g);\n         return Buffer.from(matches.join(''), 'hex');\n      },\n      decrypt: async (enc) => {\n         try {\n            const secretKey = 'C5D58EF67A7584E4A29F6C35BBC4EB12';\n            const data = Buffer.from(enc, 'base64');\n            const iv = data.slice(0, 16);\n            const content = data.slice(16);\n            const key = savetube.crypto.hexToBuffer(secretKey);\n            const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);\n            let decrypted = decipher.update(content);\n            decrypted = Buffer.concat([decrypted, decipher.final()]);\n            return JSON.parse(decrypted.toString());\n         } catch (error) {\n            throw new Error(error)\n         }\n      }\n   },\n   youtube: url => {\n      if (!url) return null;\n      const a = [\n         /youtube\\.com\\/watch\\?v=([a-zA-Z0-9_-]{11})/,\n         /youtube\\.com\\/embed\\/([a-zA-Z0-9_-]{11})/,\n         /youtube\\.com\\/v\\/([a-zA-Z0-9_-]{11})/,\n         /youtube\\.com\\/shorts\\/([a-zA-Z0-9_-]{11})/,\n         /youtu\\.be\\/([a-zA-Z0-9_-]{11})/\n      ];\n      for (let b of a) {\n         if (b.test(url)) return url.match(b)[1];\n      }\n      return null\n   },\n   request: async (endpoint, data = {}, method = 'post') => {\n      try {\n         const {\n            data: response\n         } = await axios({\n            method,\n            url: `${endpoint.startsWith('http') ? '' : savetube.api.base}${endpoint}`,\n            data: method === 'post' ? data : undefined,\n            params: method === 'get' ? data : undefined,\n            headers: savetube.headers,\n            timeout: 20000,\n            maxRedirects: 3,\n         })\n         return {\n            status: true,\n            code: 200,\n            data: response\n         }\n      } catch (error) {\n         logAxiosError('SAVETUBE.request', error);\n         throw error;\n      }\n   },\n   getCDN: async () => {\n      console.log(`[SAVETUBE] Fetching CDN host...`);\n      const response = await savetube.request(savetube.api.cdn, {}, 'get');\n      if (!response.status) throw new Error(response)\n      return {\n         status: true,\n         code: 200,\n         data: response.data.cdn\n      }\n   },\n   download: async (link, format) => {\n      console.log(`[SAVETUBE] Starting download for: ${link}, format: ${format}`);\n      \n      if (!link) {\n         console.log(`[SAVETUBE] No link provided`);\n         return {\n            status: false,\n            code: 400,\n            error: \"No link provided. Please provide a valid YouTube link.\"\n         }\n      }\n      if (!format || !savetube.formats.includes(format)) {\n         console.log(`[SAVETUBE] Invalid format: ${format}`);\n         return {\n            status: false,\n            code: 400,\n            error: \"Invalid format. Please choose one of the available formats: 144, 240, 360, 480, 720, 1080, mp3.\",\n            available_fmt: savetube.formats\n         }\n      }\n      const id = savetube.youtube(link);\n      console.log(`[SAVETUBE] Extracted YouTube ID: ${id}`);\n      \n      if (!id) {\n         console.log(`[SAVETUBE] Invalid YouTube link - no ID extracted`);\n         throw new Error('Invalid YouTube link.');\n      }\n      \n      try {\n         console.log(`[SAVETUBE] Getting CDN...`);\n         const cdnx = await savetube.getCDN();\n         if (!cdnx.status) {\n            console.log(`[SAVETUBE] CDN request failed:`, cdnx);\n            return cdnx;\n         }\n         const cdn = cdnx.data;\n         console.log(`[SAVETUBE] Got CDN: ${cdn}`);\n         \n         console.log(`[SAVETUBE] Requesting video info...`);\n         const result = await savetube.request(`https://${cdn}${savetube.api.info}`, {\n            url: `https://www.youtube.com/watch?v=${id}`\n         });\n         if (!result.status) {\n            console.log(`[SAVETUBE] Info request failed:`, result);\n            return result;\n         }\n         console.log(`[SAVETUBE] Got video info, attempting decryption...`);\n         \n         const decrypted = await savetube.crypto.decrypt(result.data.data);\n         console.log(`[SAVETUBE] Decryption successful, title: ${decrypted.title}`);\n         \n         var dl;\n         try {\n            console.log(`[SAVETUBE] Requesting download link...`);\n            dl = await savetube.request(`https://${cdn}${savetube.api.download}`, {\n               id: id,\n               downloadType: format === 'mp3' ? 'audio' : 'video',\n               quality: format === 'mp3' ? '128' : format,\n               key: decrypted.key\n            });\n            console.log(`[SAVETUBE] Download request successful`);\n         } catch (error) {\n            logAxiosError('SAVETUBE.downloadLink', error);\n            throw new Error('Failed to get download link. Please try again later.');\n         };\n         \n         console.log(`[SAVETUBE] Download URL: ${dl.data.data.downloadUrl}`);\n         \n         return {\n            status: true,\n            code: 200,\n            result: {\n               title: decrypted.title || \"Unknown Title\",\n               type: format === 'mp3' ? 'audio' : 'video',\n               format: format,\n               thumbnail: decrypted.thumbnail || `https://i.ytimg.com/vi/${id}/0.jpg`,\n               download: dl.data.data.downloadUrl,\n               id: id,\n               key: decrypted.key,\n               duration: decrypted.duration,\n               quality: format === 'mp3' ? '128' : format,\n               downloaded: dl.data.data.downloaded\n            }\n         }\n      } catch (error) {\n         console.error(`[SAVETUBE] Error in download function:`, error);\n         throw new Error('An error occurred while processing your request. Please try again later.');\n      }\n   }\n};\n\n// Fallback via Piped API (public YouTube proxy instances)\nconst piped = {\n   instances: [\n      'https://piped.video',\n      'https://piped.lunar.icu',\n      'https://piped.projectsegfau.lt',\n      'https://piped.privacy.com.de',\n      'https://piped.privacydev.net',\n      'https://watch.leptons.xyz',\n      'https://piped.us.projectsegfau.lt',\n      'https://piped.seitan-ayoub.lol',\n      'https://piped.smnz.de',\n      'https://piped.syncpundit.io',\n      'https://piped.tokhmi.xyz'\n   ],\n   getStreams: async (videoId) => {\n      for (const base of piped.instances) {\n         try {\n            console.log(`[PIPED] Trying instance: ${base}`);\n            const { data } = await axios.get(`${base}/api/v1/streams/${videoId}`, {\n               headers: { 'user-agent': 'Mozilla/5.0', 'accept': 'application/json' },\n               timeout: 15000\n            });\n            if (data && Array.isArray(data.audioStreams) && data.audioStreams.length > 0) {\n               console.log(`[PIPED] Found ${data.audioStreams.length} audio streams on ${base}`);\n               return { ok: true, base, streams: data.audioStreams };\n            }\n            console.warn(`[PIPED] No audioStreams on ${base}`);\n         } catch (e) {\n            console.warn(`[PIPED] Instance failed: ${base} -> ${e?.message || e}`);\n         }\n      }\n      return { ok: false };\n   }\n}\n\nasync function songCommand(sock, chatId, message) {\n    try {\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        const searchQuery = text.split(' ').slice(1).join(' ').trim();\n        \n        if (!searchQuery) {\n            return await sock.sendMessage(chatId, { text: \"What song do you want to download?\" }, { quoted: message });\n        }\n\n        // Determine if input is a YouTube link or search query\n        let videoUrl = '';\n        if (searchQuery.startsWith('http://') || searchQuery.startsWith('https://')) {\n            videoUrl = searchQuery;\n        } else {\n            const { videos } = await yts(searchQuery);\n            if (!videos || videos.length === 0) {\n                return await sock.sendMessage(chatId, { text: \"No songs found!\" }, { quoted: message });\n            }\n            videoUrl = videos[0].url;\n            var selectedTitle = videos[0].title || searchQuery;\n        }\n\n        // Send thumbnail immediately\n        try {\n            const ytId = (savetube.youtube(videoUrl) || '').trim();\n            const thumbUrl = ytId ? `https://i.ytimg.com/vi/${ytId}/sddefault.jpg` : undefined;\n            const captionTitle = typeof selectedTitle === 'string' && selectedTitle.length > 0 ? selectedTitle : searchQuery || 'Song';\n            if (thumbUrl) {\n                await sock.sendMessage(chatId, {\n                    image: { url: thumbUrl },\n                    caption: `*${captionTitle}*\\nDownloading...`\n                }, { quoted: message });\n            }\n        } catch (e) {\n            console.error('[SONG] Error sending thumbnail:', e?.message || e);\n        }\n\n        // Primary: PrinceTech API\n        let result;\n        try {\n            const meta = await princeApi.fetchMeta(videoUrl);\n            if (meta?.success && meta?.result?.download_url) {\n                result = {\n                    status: true,\n                    code: 200,\n                    result: {\n                        title: meta.result.title,\n                        type: 'audio',\n                        format: 'm4a',\n                        thumbnail: meta.result.thumbnail,\n                        download: meta.result.download_url,\n                        id: meta.result.id,\n                        quality: meta.result.quality\n                    }\n                };\n            } else {\n                throw new Error('PrinceTech API did not return a download_url');\n            }\n        } catch (err) {\n            console.error(`[SONG] PrinceTech API failed:`);\n            if (err?.isAxiosError) logAxiosError('SONG.prince', err); else console.error(err);\n            // Fallback to ytdl-core\n            try {\n                const tempDir = path.join(__dirname, '../temp');\n                if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);\n                const tempFile = path.join(tempDir, `${Date.now()}.mp3`);\n\n                const ytHeaders = {\n                    'cookie': 'VISITOR_INFO1_LIVE=; PREF=f1=50000000&tz=UTC; YSC=',\n                    'user-agent': 'Mozilla/5.0'\n                };\n                const info = await ytdl.getInfo(videoUrl, { requestOptions: { headers: ytHeaders } });\n                await new Promise((resolve, reject) => {\n                    const ffmpeg = require('fluent-ffmpeg');\n                    const stream = ytdl(videoUrl, {\n                        quality: 'highestaudio',\n                        filter: 'audioonly',\n                        highWaterMark: 1 << 25,\n                        requestOptions: { headers: ytHeaders }\n                    });\n                    stream.on('error', (e) => {\n                        console.error('[SONG] ytdl stream error:', e?.message || e);\n                    });\n                    ffmpeg(stream)\n                        .audioBitrate(128)\n                        .toFormat('mp3')\n                        .save(tempFile)\n                        .on('end', resolve)\n                        .on('error', (e) => {\n                            console.error('[SONG] ffmpeg error:', e?.message || e);\n                            reject(e);\n                        });\n                });\n\n                await sock.sendMessage(chatId, {\n                    audio: { url: tempFile },\n                    mimetype: \"audio/mpeg\",\n                    fileName: `${(info?.videoDetails?.title || 'song')}.mp3`,\n                    ptt: false\n                }, { quoted: message });\n\n                setTimeout(() => {\n                    try { if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile); } catch {}\n                }, 2000);\n\n                return;\n            } catch (fbErr) {\n                console.error('[SONG] ytdl-core fallback failed:', fbErr?.message || fbErr);\n                // Next fallback: yt-dlp\n                try {\n                    if (!ytdlp) throw new Error('yt-dlp-exec not installed');\n                    const tempDir = path.join(__dirname, '../temp');\n                    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);\n                    const outBase = path.join(tempDir, `${Date.now()}`);\n                    const output = `${outBase}.%(ext)s`;\n\n                    await ytdlp(videoUrl, {\n                        output,\n                        extractAudio: true,\n                        audioFormat: 'mp3',\n                        audioQuality: '0',\n                        noProgress: true,\n                        noPart: true,\n                        addHeader: [\n                            'user-agent: Mozilla/5.0',\n                            'referer: https://www.youtube.com/'\n                        ]\n                    });\n\n                    const outFile = `${outBase}.mp3`;\n                    await sock.sendMessage(chatId, {\n                        audio: { url: outFile },\n                        mimetype: 'audio/mpeg',\n                        fileName: `${(searchQuery || 'song')}.mp3`,\n                        ptt: false\n                    }, { quoted: message });\n\n                    setTimeout(() => {\n                        try { if (fs.existsSync(outFile)) fs.unlinkSync(outFile); } catch {}\n                    }, 2000);\n\n                    return;\n                } catch (dlpErr) {\n                    console.error('[SONG] yt-dlp fallback failed:', dlpErr?.message || dlpErr);\n                }\n\n                // Final fallback: Piped API\n                try {\n                    const id = savetube.youtube(videoUrl);\n                    if (!id) throw new Error('Unable to extract video ID for Piped fallback');\n                    const resp = await piped.getStreams(id);\n                    if (!resp.ok) throw new Error('No audio streams available via Piped');\n\n                    const sorted = resp.streams\n                        .slice()\n                        .sort((a, b) => (parseInt(b.bitrate || '0') || 0) - (parseInt(a.bitrate || '0') || 0));\n                    const preferred = sorted.find(s => (s.mimeType || '').includes('audio/mp4')) || sorted[0];\n                    const mime = preferred.mimeType || 'audio/mp4';\n                    const ext = mime.includes('webm') ? 'webm' : (mime.includes('mp4') ? 'm4a' : 'audio');\n\n                    const tempIn = path.join(tempDir, `${Date.now()}.${ext}`);\n                    const tempOut = path.join(tempDir, `${Date.now()}-conv.mp3`);\n\n                    const dlResp = await axios({ url: preferred.url, method: 'GET', responseType: 'stream', timeout: 30000, maxRedirects: 5 });\n                    await new Promise((resolve, reject) => {\n                        const w = fs.createWriteStream(tempIn);\n                        dlResp.data.pipe(w);\n                        w.on('finish', resolve);\n                        w.on('error', reject);\n                    });\n\n                    let converted = false;\n                    try {\n                        const ffmpeg = require('fluent-ffmpeg');\n                        await new Promise((resolve, reject) => {\n                            ffmpeg(tempIn)\n                                .audioBitrate(128)\n                                .toFormat('mp3')\n                                .save(tempOut)\n                                .on('end', resolve)\n                                .on('error', reject);\n                        });\n                        converted = true;\n                    } catch (convErr) {\n                        console.warn('[SONG] Conversion failed, sending original file:', convErr?.message || convErr);\n                    }\n\n                    await sock.sendMessage(chatId, {\n                        audio: { url: converted ? tempOut : tempIn },\n                        mimetype: converted ? 'audio/mpeg' : mime,\n                        fileName: `${(searchQuery || 'song')}.${converted ? 'mp3' : ext}`,\n                        ptt: false\n                    }, { quoted: message });\n\n                    setTimeout(() => {\n                        try { if (fs.existsSync(tempIn)) fs.unlinkSync(tempIn); } catch {}\n                        try { if (fs.existsSync(tempOut)) fs.unlinkSync(tempOut); } catch {}\n                    }, 2000);\n\n                    return;\n                } catch (pErr) {\n                    console.error('[SONG] Piped fallback failed:', pErr?.message || pErr);\n            return await sock.sendMessage(chatId, { text: \"Failed to fetch download link. Try again later.\" });\n                }\n            }\n        }\n        \n        if (!result || !result.status || !result.result || !result.result.download) {\n            console.error(`[SONG] Invalid result structure:`, JSON.stringify(result, null, 2));\n            return await sock.sendMessage(chatId, { text: \"Failed to get a valid download link from the API.\" }, { quoted: message });\n        }\n\n        // Minimal logs: only errors, so do not log the download URL\n\n        // Download the audio file\n        const tempDir = path.join(__dirname, '../temp');\n        if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);\n        // Minimal logs\n\n        let response;\n        try {\n            response = await axios({\n                url: result.result.download,\n                method: 'GET',\n                responseType: 'stream',\n                timeout: 30000,\n                maxRedirects: 5,\n                headers: { 'user-agent': 'Mozilla/5.0' },\n                validateStatus: () => true\n            });\n        } catch (err) {\n            logAxiosError('SONG.fileDownload', err);\n            return await sock.sendMessage(chatId, { text: \"Failed to download the song (network error).\" }, { quoted: message });\n        }\n        const ctHeader = response.headers?.['content-type'];\n        const ct = Array.isArray(ctHeader) ? (ctHeader[0] || '') : (ctHeader || '');\n        const ctLower = ct.toLowerCase();\n        const guessedExt = ctLower.includes('audio/mp4') || ctLower.includes('mp4') ? 'm4a'\n            : ctLower.includes('audio/webm') ? 'webm'\n            : ctLower.includes('mpeg') ? 'mp3'\n            : 'm4a';\n        const isAudioCT = ctLower.startsWith('audio/') || ctLower.includes('mpeg') || ctLower.includes('mp4') || ctLower.includes('webm');\n        const chosenMime = isAudioCT ? ctLower : (guessedExt === 'mp3' ? 'audio/mpeg' : guessedExt === 'webm' ? 'audio/webm' : 'audio/mp4');\n        const tempFile = path.join(tempDir, `${Date.now()}.${guessedExt}`);\n        // Minimal logs\n        if (response.status < 200 || response.status >= 300) {\n            console.error(`[SONG] HTTP error downloading file: ${response.status} ${response.statusText}`);\n            return await sock.sendMessage(chatId, { text: \"Failed to download the song file from the server (bad status).\" }, { quoted: message });\n        }\n\n        await new Promise((resolve, reject) => {\n            const writer = fs.createWriteStream(tempFile);\n            response.data.on('error', (e) => {\n                console.error('[SONG] Stream error from server:', e?.message || e);\n                reject(e);\n            });\n            writer.on('finish', resolve);\n            writer.on('close', resolve);\n            writer.on('error', (e) => {\n                console.error('[SONG] File write error:', e?.message || e);\n                reject(e);\n            });\n            response.data.pipe(writer);\n        });\n\n        let fileSize = 0;\n        try {\n            const stats = fs.statSync(tempFile);\n            fileSize = stats.size;\n            // Minimal logs\n        } catch {}\n        if (!fileSize || fileSize < 10240) { // <10KB indicates failure\n            return await sock.sendMessage(chatId, { text: \"Song file seems invalid (too small). Please try again.\" }, { quoted: message });\n        }\n\n        // Convert to MP3 for maximum compatibility if needed\n        let sendPath = tempFile;\n        let sendMime = chosenMime;\n        let sendName = `${result.result.title}.${guessedExt}`;\n        let convPath = '';\n        if (guessedExt !== 'mp3') {\n            try {\n                const ffmpeg = require('fluent-ffmpeg');\n                convPath = path.join(tempDir, `${Date.now()}-conv.mp3`);\n                // Minimal logs\n                await new Promise((resolve, reject) => {\n                    ffmpeg(tempFile)\n                        .audioCodec('libmp3lame')\n                        .audioBitrate(128)\n                        .toFormat('mp3')\n                        .save(convPath)\n                        .on('end', resolve)\n                        .on('error', reject);\n                });\n                sendPath = convPath;\n                sendMime = 'audio/mpeg';\n                sendName = `${result.result.title}.mp3`;\n            } catch (e) {\n                console.warn('[SONG] Conversion to MP3 failed, sending original file:', e?.message || e);\n            }\n        }\n\n        await sock.sendMessage(chatId, {\n            audio: { url: sendPath },\n            mimetype: sendMime,\n            fileName: sendName,\n            ptt: false\n        }, { quoted: message });\n\n        // Minimal logs\n\n        // Clean up temp file\n        // Do not delete immediately; keep file around a bit longer for debugging\n        setTimeout(() => {\n            try {\n                if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);\n                if (convPath && fs.existsSync(convPath)) fs.unlinkSync(convPath);\n                // Minimal logs\n            } catch {}\n        }, 2000);\n    } catch (error) {\n        console.error(`[SONG] General error:`);\n        if (error?.isAxiosError) logAxiosError('SONG.general', error); else console.error(error);\n        await sock.sendMessage(chatId, { text: \"Download failed. Please try again later.\" }, { quoted: message });\n    }\n}\n\nmodule.exports = songCommand; ","size_bytes":24450},"commands/ss.js":{"content":"const fetch = require('node-fetch');\n\nasync function handleSsCommand(sock, chatId, message, match) {\n    if (!match) {\n        await sock.sendMessage(chatId, {\n            text: `*SCREENSHOT TOOL*\\n\\n*.ss <url>*\\n*.ssweb <url>*\\n*.screenshot <url>*\\n\\nTake a screenshot of any website\\n\\nExample:\\n.ss https://google.com\\n.ssweb https://google.com\\n.screenshot https://google.com`,\n            quoted: message\n        });\n        return;\n    }\n\n    try {\n        // Show typing indicator\n        await sock.presenceSubscribe(chatId);\n        await sock.sendPresenceUpdate('composing', chatId);\n\n        // Extract URL from command\n        const url = match.trim();\n        \n        // Validate URL\n        if (!url.startsWith('http://') && !url.startsWith('https://')) {\n            return sock.sendMessage(chatId, {\n                text: '‚ùå Please provide a valid URL starting with http:// or https://',\n                quoted: message\n            });\n        }\n\n        // Call the API\n        const apiUrl = `https://api.siputzx.my.id/api/tools/ssweb?url=${encodeURIComponent(url)}&theme=light&device=desktop`;\n        const response = await fetch(apiUrl, { headers: { 'accept': '*/*' } });\n        \n        if (!response.ok) {\n            throw new Error(`API responded with status: ${response.status}`);\n        }\n\n        // Get the image buffer\n        const imageBuffer = await response.buffer();\n\n        // Send the screenshot\n        await sock.sendMessage(chatId, {\n            image: imageBuffer,\n        }, {\n            quoted: message\n        });\n\n    } catch (error) {\n        console.error('‚ùå Error in ss command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Failed to take screenshot. Please try again in a few minutes.\\n\\nPossible reasons:\\n‚Ä¢ Invalid URL\\n‚Ä¢ Website is blocking screenshots\\n‚Ä¢ Website is down\\n‚Ä¢ API service is temporarily unavailable',\n            quoted: message\n        });\n    }\n}\n\nmodule.exports = {\n    handleSsCommand\n}; ","size_bytes":2005},"commands/staff.js":{"content":"async function staffCommand(sock, chatId, msg) {\n    try {\n        // Get group metadata\n        const groupMetadata = await sock.groupMetadata(chatId);\n        \n        // Get group profile picture\n        let pp;\n        try {\n            pp = await sock.profilePictureUrl(chatId, 'image');\n        } catch {\n            pp = 'https://i.imgur.com/2wzGhpF.jpeg'; // Default image\n        }\n\n        // Get admins from participants\n        const participants = groupMetadata.participants;\n        const groupAdmins = participants.filter(p => p.admin);\n        const listAdmin = groupAdmins.map((v, i) => `${i + 1}. @${v.id.split('@')[0]}`).join('\\n‚ñ¢ ');\n        \n        // Get group owner\n        const owner = groupMetadata.owner || groupAdmins.find(p => p.admin === 'superadmin')?.id || chatId.split('-')[0] + '@s.whatsapp.net';\n\n        // Create staff text\n        const text = `\n‚â° *GROUP ADMINS* _${groupMetadata.subject}_\n\n‚îå‚îÄ‚ä∑ *ADMINS*\n‚ñ¢ ${listAdmin}\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`.trim();\n\n        // Send the message with image and mentions\n        await sock.sendMessage(chatId, {\n            image: { url: pp },\n            caption: text,\n            mentions: [...groupAdmins.map(v => v.id), owner]\n        });\n\n    } catch (error) {\n        console.error('Error in staff command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to get admin list!' });\n    }\n}\n\nmodule.exports = staffCommand; ","size_bytes":1442},"commands/sticker-alt.js":{"content":"const { downloadContentFromMessage } = require('@whiskeysockets/baileys');\nconst { exec } = require('child_process');\nconst fs = require('fs');\n\nasync function stickerCommand(sock, chatId, message) {\n    try {\n        const quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n        if (!quotedMsg) {\n            await sock.sendMessage(chatId, { text: 'Please reply to an image or video!' });\n            return;\n        }\n\n        const type = Object.keys(quotedMsg)[0];\n        if (!['imageMessage', 'videoMessage'].includes(type)) {\n            await sock.sendMessage(chatId, { text: 'Please reply to an image or video!' });\n            return;\n        }\n\n        const stream = await downloadContentFromMessage(quotedMsg[type], type.split('Message')[0]);\n        let buffer = Buffer.from([]);\n        for await (const chunk of stream) {\n            buffer = Buffer.concat([buffer, chunk]);\n        }\n\n        const tempInput = `./temp/temp_${Date.now()}.${type === 'imageMessage' ? 'jpg' : 'mp4'}`;\n        const tempOutput = `./temp/sticker_${Date.now()}.webp`;\n\n        // Create temp directory if it doesn't exist\n        if (!fs.existsSync('./temp')) {\n            fs.mkdirSync('./temp', { recursive: true });\n        }\n\n        fs.writeFileSync(tempInput, buffer);\n\n        // Convert to WebP using ffmpeg\n        await new Promise((resolve, reject) => {\n            const cmd = type === 'imageMessage' \n                ? `ffmpeg -i \"${tempInput}\" -vf \"scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease\" \"${tempOutput}\"`\n                : `ffmpeg -i \"${tempInput}\" -vf \"scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease\" -c:v libwebp -preset default -loop 0 -vsync 0 -t 6 \"${tempOutput}\"`;\n            \n            exec(cmd, (error) => {\n                if (error) reject(error);\n                else resolve();\n            });\n        });\n\n        await sock.sendMessage(chatId, { \n            sticker: fs.readFileSync(tempOutput) \n        });\n\n        // Cleanup\n        fs.unlinkSync(tempInput);\n        fs.unlinkSync(tempOutput);\n\n    } catch (error) {\n        console.error('Error in sticker command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to create sticker!' });\n    }\n}\n\nmodule.exports = stickerCommand;","size_bytes":2313},"commands/sticker.js":{"content":"const { downloadMediaMessage } = require('@whiskeysockets/baileys');\nconst { exec } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst settings = require('../settings');\nconst webp = require('node-webpmux');\nconst crypto = require('crypto');\n\nasync function stickerCommand(sock, chatId, message) {\n    // The message that will be quoted in the reply.\n    const messageToQuote = message;\n    \n    // The message object that contains the media to be downloaded.\n    let targetMessage = message;\n\n    // If the message is a reply, the target media is in the quoted message.\n    if (message.message?.extendedTextMessage?.contextInfo?.quotedMessage) {\n        // We need to build a new message object for downloadMediaMessage to work correctly.\n        const quotedInfo = message.message.extendedTextMessage.contextInfo;\n        targetMessage = {\n            key: {\n                remoteJid: chatId,\n                id: quotedInfo.stanzaId,\n                participant: quotedInfo.participant\n            },\n            message: quotedInfo.quotedMessage\n        };\n    }\n\n    const mediaMessage = targetMessage.message?.imageMessage || targetMessage.message?.videoMessage || targetMessage.message?.documentMessage;\n\n    if (!mediaMessage) {\n        await sock.sendMessage(chatId, { \n            text: 'Please reply to an image/video with .sticker, or send an image/video with .sticker as the caption.',\n            contextInfo: {\n                forwardingScore: 999,\n                isForwarded: true,\n            }\n        },{ quoted: messageToQuote });\n        return;\n    }\n\n    try {\n        const mediaBuffer = await downloadMediaMessage(targetMessage, 'buffer', {}, { \n            logger: undefined, \n            reuploadRequest: sock.updateMediaMessage \n        });\n\n        if (!mediaBuffer) {\n            await sock.sendMessage(chatId, { \n                text: 'Failed to download media. Please try again.',\n                contextInfo: {\n                    forwardingScore: 999,\n                    isForwarded: true,\n                }\n            });\n            return;\n        }\n\n        // Create temp directory if it doesn't exist\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) {\n            fs.mkdirSync(tmpDir, { recursive: true });\n        }\n\n        // Generate temp file paths\n        const tempInput = path.join(tmpDir, `temp_${Date.now()}`);\n        const tempOutput = path.join(tmpDir, `sticker_${Date.now()}.webp`);\n\n        // Write media to temp file\n        fs.writeFileSync(tempInput, mediaBuffer);\n\n        // Check if media is animated (GIF or video)\n        const isAnimated = mediaMessage.mimetype?.includes('gif') || \n                          mediaMessage.mimetype?.includes('video') || \n                          mediaMessage.seconds > 0;\n\n        // Convert to WebP using ffmpeg with optimized settings for animated/non-animated\n        const ffmpegCommand = isAnimated\n            ? `ffmpeg -i \"${tempInput}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,fps=15,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`\n            : `ffmpeg -i \"${tempInput}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`;\n\n        await new Promise((resolve, reject) => {\n            exec(ffmpegCommand, (error) => {\n                if (error) {\n                    console.error('FFmpeg error:', error);\n                    reject(error);\n                } else resolve();\n            });\n        });\n\n        // Read the WebP file\n        let webpBuffer = fs.readFileSync(tempOutput);\n\n        // If animated and output is too large, re-encode with harsher settings similar to stickercrop\n        if (isAnimated && webpBuffer.length > 1000 * 1024) {\n            try {\n                const tempOutput2 = path.join(tmpDir, `sticker_fallback_${Date.now()}.webp`);\n                // Detect large source to decide compression level\n                const fileSizeKB = mediaBuffer.length / 1024;\n                const isLargeFile = fileSizeKB > 5000; // 5MB\n                const fallbackCmd = isLargeFile\n                    ? `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"scale=512:512:force_original_aspect_ratio=decrease,fps=8,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput2}\"`\n                    : `ffmpeg -y -i \"${tempInput}\" -t 3 -vf \"scale=512:512:force_original_aspect_ratio=decrease,fps=12,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 45 -compression_level 6 -b:v 150k -max_muxing_queue_size 1024 \"${tempOutput2}\"`;\n                await new Promise((resolve, reject) => {\n                    exec(fallbackCmd, (error) => error ? reject(error) : resolve());\n                });\n                if (fs.existsSync(tempOutput2)) {\n                    webpBuffer = fs.readFileSync(tempOutput2);\n                    try { fs.unlinkSync(tempOutput2); } catch {}\n                }\n            } catch {}\n        }\n        // Read the WebP file\n        webpBuffer = fs.readFileSync(tempOutput);\n\n        // If animated and output is too large, re-encode with harsher settings similar to stickercrop\n        if (isAnimated && webpBuffer.length > 1000 * 1024) {\n            try {\n                const tempOutput2 = path.join(tmpDir, `sticker_fallback_${Date.now()}.webp`);\n                // Detect large source to decide compression level\n                const fileSizeKB = mediaBuffer.length / 1024;\n                const isLargeFile = fileSizeKB > 5000; // 5MB\n                const fallbackCmd = isLargeFile\n                    ? `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"scale=512:512:force_original_aspect_ratio=decrease,fps=8,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput2}\"`\n                    : `ffmpeg -y -i \"${tempInput}\" -t 3 -vf \"scale=512:512:force_original_aspect_ratio=decrease,fps=12,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 45 -compression_level 6 -b:v 150k -max_muxing_queue_size 1024 \"${tempOutput2}\"`;\n                await new Promise((resolve, reject) => {\n                    exec(fallbackCmd, (error) => error ? reject(error) : resolve());\n                });\n                if (fs.existsSync(tempOutput2)) {\n                    webpBuffer = fs.readFileSync(tempOutput2);\n                    try { fs.unlinkSync(tempOutput2); } catch {}\n                }\n            } catch {}\n        }\n\n        // Add metadata using webpmux\n        const img = new webp.Image();\n        await img.load(webpBuffer);\n\n        // Create metadata\n        const json = {\n            'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n            'sticker-pack-name': settings.packname || 'KnightBot',\n            'emojis': ['ü§ñ']\n        };\n\n        // Create exif buffer\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n        const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n        const exif = Buffer.concat([exifAttr, jsonBuffer]);\n        exif.writeUIntLE(jsonBuffer.length, 14, 4);\n\n        // Set the exif data\n        img.exif = exif;\n\n        // Get the final buffer with metadata\n        let finalBuffer = await img.save(null);\n\n        // Final safety: if still too large, make a tiny 320/256px pass\n        if (isAnimated && finalBuffer.length > 900 * 1024) {\n            try {\n                const tempOutput3 = path.join(tmpDir, `sticker_small_${Date.now()}.webp`);\n                const smallCmd = `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"scale=320:320:force_original_aspect_ratio=decrease,fps=8,pad=320:320:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 80k -max_muxing_queue_size 1024 \"${tempOutput3}\"`;\n                await new Promise((resolve, reject) => {\n                    exec(smallCmd, (error) => error ? reject(error) : resolve());\n                });\n                if (fs.existsSync(tempOutput3)) {\n                    const smallWebp = fs.readFileSync(tempOutput3);\n                    const img2 = new webp.Image();\n                    await img2.load(smallWebp);\n                    const json2 = {\n                        'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n                        'sticker-pack-name': settings.packname || 'KnightBot',\n                        'emojis': ['ü§ñ']\n                    };\n                    const exifAttr2 = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n                    const jsonBuffer2 = Buffer.from(JSON.stringify(json2), 'utf8');\n                    const exif2 = Buffer.concat([exifAttr2, jsonBuffer2]);\n                    exif2.writeUIntLE(jsonBuffer2.length, 14, 4);\n                    img2.exif = exif2;\n                    finalBuffer = await img2.save(null);\n                    try { fs.unlinkSync(tempOutput3); } catch {}\n                }\n            } catch {}\n        }\n\n        // Send the sticker\n        await sock.sendMessage(chatId, { \n            sticker: finalBuffer\n        },{ quoted: messageToQuote });\n\n        // Cleanup temp files\n        try {\n            fs.unlinkSync(tempInput);\n            fs.unlinkSync(tempOutput);\n        } catch (err) {\n            console.error('Error cleaning up temp files:', err);\n        }\n\n    } catch (error) {\n        console.error('Error in sticker command:', error);\n        await sock.sendMessage(chatId, { \n            text: 'Failed to create sticker! Try again later.',\n            contextInfo: {\n                forwardingScore: 999,\n                isForwarded: true,\n            }\n        });\n    }\n}\n\nmodule.exports = stickerCommand;\n","size_bytes":10504},"commands/stickercrop.js":{"content":"const { downloadMediaMessage } = require('@whiskeysockets/baileys');\nconst { exec } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst settings = require('../settings');\nconst webp = require('node-webpmux');\nconst crypto = require('crypto');\n\nasync function stickercropCommand(sock, chatId, message) {\n    // The message that will be quoted in the reply.\n    const messageToQuote = message;\n    \n    // The message object that contains the media to be downloaded.\n    let targetMessage = message;\n\n    // If the message is a reply, the target media is in the quoted message.\n    if (message.message?.extendedTextMessage?.contextInfo?.quotedMessage) {\n        // We need to build a new message object for downloadMediaMessage to work correctly.\n        const quotedInfo = message.message.extendedTextMessage.contextInfo;\n        targetMessage = {\n            key: {\n                remoteJid: chatId,\n                id: quotedInfo.stanzaId,\n                participant: quotedInfo.participant\n            },\n            message: quotedInfo.quotedMessage\n        };\n    }\n\n    const mediaMessage = targetMessage.message?.imageMessage || targetMessage.message?.videoMessage || targetMessage.message?.documentMessage || targetMessage.message?.stickerMessage;\n\n    if (!mediaMessage) {\n        await sock.sendMessage(chatId, { \n            text: 'Please reply to an image/video/sticker with .crop, or send an image/video/sticker with .crop as the caption.',\n            contextInfo: {\n                forwardingScore: 999,\n                isForwarded: true,\n            }\n        },{ quoted: messageToQuote });\n        return;\n    }\n\n    try {\n        const mediaBuffer = await downloadMediaMessage(targetMessage, 'buffer', {}, { \n            logger: undefined, \n            reuploadRequest: sock.updateMediaMessage \n        });\n\n        if (!mediaBuffer) {\n            await sock.sendMessage(chatId, { \n                text: 'Failed to download media. Please try again.',\n                contextInfo: {\n                    forwardingScore: 999,\n                    isForwarded: true,\n                }\n            });\n            return;\n        }\n\n        // Create temp directory if it doesn't exist\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) {\n            fs.mkdirSync(tmpDir, { recursive: true });\n        }\n\n        // Generate temp file paths\n        const tempInput = path.join(tmpDir, `temp_${Date.now()}`);\n        const tempOutput = path.join(tmpDir, `crop_${Date.now()}.webp`);\n\n        // Write media to temp file\n        fs.writeFileSync(tempInput, mediaBuffer);\n\n        // Check if media is animated (GIF or video)\n        const isAnimated = mediaMessage.mimetype?.includes('gif') || \n                          mediaMessage.mimetype?.includes('video') || \n                          mediaMessage.seconds > 0;\n\n        // Get file size to determine compression level\n        const fileSizeKB = mediaBuffer.length / 1024;\n        const isLargeFile = fileSizeKB > 5000; // 5MB threshold\n\n        // Convert to WebP using ffmpeg with crop to square\n        // For videos: more aggressive compression, lower quality, shorter duration\n        // For images: standard compression\n        let ffmpegCommand;\n        \n        if (isAnimated) {\n            if (isLargeFile) {\n                // Large video: very aggressive compression, max 2 seconds, very low quality\n                ffmpegCommand = `ffmpeg -i \"${tempInput}\" -t 2 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=8\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n            } else {\n                // Normal video: aggressive compression, max 3 seconds, lower quality\n                ffmpegCommand = `ffmpeg -i \"${tempInput}\" -t 3 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=12\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 50 -compression_level 6 -b:v 150k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n            }\n        } else {\n            // Image: standard compression\n            ffmpegCommand = `ffmpeg -i \"${tempInput}\" -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,format=rgba\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`;\n        }\n\n        await new Promise((resolve, reject) => {\n            exec(ffmpegCommand, (error, stdout, stderr) => {\n                if (error) {\n                    console.error('FFmpeg error:', error);\n                    console.error('FFmpeg stderr:', stderr);\n                    reject(error);\n                } else {\n                    console.log('FFmpeg stdout:', stdout);\n                    resolve();\n                }\n            });\n        });\n\n        // Check if output file exists and has content\n        if (!fs.existsSync(tempOutput)) {\n            throw new Error('FFmpeg failed to create output file');\n        }\n\n        const outputStats = fs.statSync(tempOutput);\n        if (outputStats.size === 0) {\n            throw new Error('FFmpeg created empty output file');\n        }\n\n        // Read the WebP file\n        let webpBuffer = fs.readFileSync(tempOutput);\n        \n        // Check final file size\n        const finalSizeKB = webpBuffer.length / 1024;\n        console.log(`Final sticker size: ${Math.round(finalSizeKB)} KB`);\n        \n        // If still too large, we'll send it anyway but log a warning\n        if (finalSizeKB > 1000) { // 1MB limit for WhatsApp stickers\n            console.log(`‚ö†Ô∏è Warning: Sticker size (${Math.round(finalSizeKB)} KB) exceeds recommended limit but will be sent anyway`);\n        }\n\n        // Add metadata using webpmux\n        const img = new webp.Image();\n        await img.load(webpBuffer);\n\n        // Create metadata\n        const json = {\n            'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n            'sticker-pack-name': settings.packname || 'KnightBot',\n            'emojis': ['‚úÇÔ∏è']\n        };\n\n        // Create exif buffer\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n        const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n        const exif = Buffer.concat([exifAttr, jsonBuffer]);\n        exif.writeUIntLE(jsonBuffer.length, 14, 4);\n\n        // Set the exif data\n        img.exif = exif;\n\n        // Get the final buffer with metadata\n        const finalBuffer = await img.save(null);\n\n        // Send the sticker\n        await sock.sendMessage(chatId, { \n            sticker: finalBuffer\n        },{ quoted: messageToQuote });\n\n        // Cleanup temp files\n        try {\n            fs.unlinkSync(tempInput);\n            fs.unlinkSync(tempOutput);\n        } catch (err) {\n            console.error('Error cleaning up temp files:', err);\n        }\n\n    } catch (error) {\n        console.error('Error in stickercrop command:', error);\n        await sock.sendMessage(chatId, { \n            text: 'Failed to crop sticker! Try with an image.',\n            contextInfo: {\n                forwardingScore: 999,\n                isForwarded: true,\n            }\n        });\n    }\n}\n\nmodule.exports = stickercropCommand;\n\n// Helper: convert a raw media buffer to a cropped sticker using same pipeline\nasync function stickercropFromBuffer(inputBuffer, isAnimated) {\n    const tmpDir = path.join(process.cwd(), 'tmp');\n    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });\n\n    const tempInput = path.join(tmpDir, `cropbuf_${Date.now()}`);\n    const tempOutput = path.join(tmpDir, `cropbuf_out_${Date.now()}.webp`);\n\n    fs.writeFileSync(tempInput, inputBuffer);\n\n    // Size-based trim like stickercrop\n    const fileSizeKB = inputBuffer.length / 1024;\n    const isLargeFile = fileSizeKB > 5000;\n\n    let ffmpegCommand;\n    if (isAnimated) {\n        if (isLargeFile) {\n            ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -t 2 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=8\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 30 -compression_level 6 -b:v 100k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n        } else {\n            ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -t 3 -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,fps=12\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 50 -compression_level 6 -b:v 150k -max_muxing_queue_size 1024 \"${tempOutput}\"`;\n        }\n    } else {\n        ffmpegCommand = `ffmpeg -y -i \"${tempInput}\" -vf \"crop=min(iw\\\\,ih):min(iw\\\\,ih),scale=512:512,format=rgba\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`;\n    }\n\n    await new Promise((resolve, reject) => {\n        exec(ffmpegCommand, (error) => {\n            if (error) return reject(error);\n            resolve();\n        });\n    });\n\n    const webpBuffer = fs.readFileSync(tempOutput);\n\n    const img = new webp.Image();\n    await img.load(webpBuffer);\n    const json = {\n        'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n        'sticker-pack-name': settings.packname || 'KnightBot',\n        'emojis': ['‚úÇÔ∏è']\n    };\n    const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n    const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n    const exif = Buffer.concat([exifAttr, jsonBuffer]);\n    exif.writeUIntLE(jsonBuffer.length, 14, 4);\n    img.exif = exif;\n    const finalBuffer = await img.save(null);\n\n    try {\n        fs.unlinkSync(tempInput);\n        fs.unlinkSync(tempOutput);\n    } catch {}\n\n    return finalBuffer;\n}\n\nmodule.exports.stickercropFromBuffer = stickercropFromBuffer;","size_bytes":9949},"commands/stickertelegram.js":{"content":"const fetch = require('node-fetch');\nconst { writeExifImg } = require('../lib/exif');\nconst delay = time => new Promise(res => setTimeout(res, time));\nconst fs = require('fs');\nconst path = require('path');\nconst sharp = require('sharp');\nconst webp = require('node-webpmux');\nconst crypto = require('crypto');\nconst { exec } = require('child_process');\nconst settings = require('../settings');\n\nasync function stickerTelegramCommand(sock, chatId, msg) {\n    try {\n        // Get the URL from message\n        const text = msg.message?.conversation?.trim() || \n                    msg.message?.extendedTextMessage?.text?.trim() || '';\n        \n        const args = text.split(' ').slice(1);\n        \n        if (!args[0]) {\n            await sock.sendMessage(chatId, { \n                text: '‚ö†Ô∏è Please enter the Telegram sticker URL!\\n\\nExample: .tg https://t.me/addstickers/Porcientoreal' \n            });\n            return;\n        }\n\n        // Validate URL format\n        if (!args[0].match(/(https:\\/\\/t.me\\/addstickers\\/)/gi)) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Invalid URL! Make sure it\\'s a Telegram sticker URL.' \n            });\n            return;\n        }\n\n        // Get pack name from URL\n        const packName = args[0].replace(\"https://t.me/addstickers/\", \"\");\n\n        // Using working bot token\n        const botToken = '7801479976:AAGuPL0a7kXXBYz6XUSR_ll2SR5V_W6oHl4';\n        \n        try {\n            // Fetch sticker pack info\n            const response = await fetch(\n                `https://api.telegram.org/bot${botToken}/getStickerSet?name=${encodeURIComponent(packName)}`,\n                { \n                    method: \"GET\",\n                    headers: {\n                        \"Accept\": \"application/json\",\n                        \"User-Agent\": \"Mozilla/5.0\"\n                    }\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const stickerSet = await response.json();\n            \n            if (!stickerSet.ok || !stickerSet.result) {\n                throw new Error('Invalid sticker pack or API response');\n            }\n\n            // Send initial message with sticker count\n            await sock.sendMessage(chatId, { \n                text: `üì¶ Found ${stickerSet.result.stickers.length} stickers\\n‚è≥ Starting download...` \n            });\n\n            // Create temp directory if it doesn't exist\n            const tmpDir = path.join(process.cwd(), 'tmp');\n            if (!fs.existsSync(tmpDir)) {\n                fs.mkdirSync(tmpDir, { recursive: true });\n            }\n\n            // Process each sticker\n            let successCount = 0;\n            for (let i = 0; i < stickerSet.result.stickers.length; i++) {\n                try {\n                    const sticker = stickerSet.result.stickers[i];\n                    const fileId = sticker.file_id;\n                    \n                    // Get file path\n                    const fileInfo = await fetch(\n                        `https://api.telegram.org/bot${botToken}/getFile?file_id=${fileId}`\n                    );\n                    \n                    if (!fileInfo.ok) continue;\n                    \n                    const fileData = await fileInfo.json();\n                    if (!fileData.ok || !fileData.result.file_path) continue;\n\n                    // Download sticker\n                    const fileUrl = `https://api.telegram.org/file/bot${botToken}/${fileData.result.file_path}`;\n                    const imageResponse = await fetch(fileUrl);\n                    const imageBuffer = await imageResponse.buffer();\n\n                    // Generate temp file paths\n                    const tempInput = path.join(tmpDir, `temp_${Date.now()}_${i}`);\n                    const tempOutput = path.join(tmpDir, `sticker_${Date.now()}_${i}.webp`);\n\n                    // Write media to temp file\n                    fs.writeFileSync(tempInput, imageBuffer);\n\n                    // Check if sticker is animated or video\n                    const isAnimated = sticker.is_animated || sticker.is_video;\n                    \n                    // Convert to WebP using ffmpeg with optimized settings\n                    const ffmpegCommand = isAnimated\n                        ? `ffmpeg -i \"${tempInput}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,fps=15,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`\n                        : `ffmpeg -i \"${tempInput}\" -vf \"scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000\" -c:v libwebp -preset default -loop 0 -vsync 0 -pix_fmt yuva420p -quality 75 -compression_level 6 \"${tempOutput}\"`;\n\n                    await new Promise((resolve, reject) => {\n                        exec(ffmpegCommand, (error) => {\n                            if (error) {\n                                console.error('FFmpeg error:', error);\n                                reject(error);\n                            } else resolve();\n                        });\n                    });\n\n                    // Read the WebP file\n                    const webpBuffer = fs.readFileSync(tempOutput);\n\n                    // Add metadata using webpmux\n                    const img = new webp.Image();\n                    await img.load(webpBuffer);\n\n                    // Create metadata\n                    const metadata = {\n                        'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n                        'sticker-pack-name': settings.packname,\n                        'emojis': sticker.emoji ? [sticker.emoji] : ['ü§ñ']\n                    };\n\n                    // Create exif buffer\n                    const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n                    const jsonBuffer = Buffer.from(JSON.stringify(metadata), 'utf8');\n                    const exif = Buffer.concat([exifAttr, jsonBuffer]);\n                    exif.writeUIntLE(jsonBuffer.length, 14, 4);\n\n                    // Set the exif data\n                    img.exif = exif;\n\n                    // Get the final buffer\n                    const finalBuffer = await img.save(null);\n\n                    // Send sticker only once\n                    await sock.sendMessage(chatId, { \n                        sticker: finalBuffer \n                    });\n\n                    successCount++;\n                    await delay(1000); // Reduced delay\n\n                    // Cleanup temp files\n                    try {\n                        fs.unlinkSync(tempInput);\n                        fs.unlinkSync(tempOutput);\n                    } catch (err) {\n                        console.error('Error cleaning up temp files:', err);\n                    }\n\n                } catch (err) {\n                    console.error(`Error processing sticker ${i}:`, err);\n                    continue;\n                }\n            }\n\n            // Only send completion message at the end\n            await sock.sendMessage(chatId, { \n                text: `‚úÖ Successfully downloaded ${successCount}/${stickerSet.result.stickers.length} stickers!` \n            });\n\n        } catch (error) {\n            throw new Error(`Failed to process sticker pack: ${error.message}`);\n        }\n\n    } catch (error) {\n        console.error('Error in stickertelegram command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Failed to process Telegram stickers!\\nMake sure:\\n1. The URL is correct\\n2. The sticker pack exists\\n3. The sticker pack is public' \n        });\n    }\n}\n\nmodule.exports = stickerTelegramCommand; ","size_bytes":7940},"commands/stupid.js":{"content":"const fetch = require('node-fetch');\n\nasync function stupidCommand(sock, chatId, quotedMsg, mentionedJid, sender, args) {\n    try {\n        // Determine the target user\n        let who = quotedMsg \n            ? quotedMsg.sender \n            : mentionedJid && mentionedJid[0] \n                ? mentionedJid[0] \n                : sender;\n\n        // Get the text for the stupid card (default to \"im+stupid\" if not provided)\n        let text = args && args.length > 0 ? args.join(' ') : 'im+stupid';\n        \n        // Get the profile picture URL\n        let avatarUrl;\n        try {\n            avatarUrl = await sock.profilePictureUrl(who, 'image');\n        } catch (error) {\n            console.error('Error fetching profile picture:', error);\n            avatarUrl = 'https://telegra.ph/file/24fa902ead26340f3df2c.png'; // Default avatar\n        }\n\n        // Fetch the stupid card from the API\n        const apiUrl = `https://some-random-api.com/canvas/misc/its-so-stupid?avatar=${encodeURIComponent(avatarUrl)}&dog=${encodeURIComponent(text)}`;\n        const response = await fetch(apiUrl);\n        \n        if (!response.ok) {\n            throw new Error(`API responded with status: ${response.status}`);\n        }\n\n        // Get the image buffer\n        const imageBuffer = await response.buffer();\n\n        // Send the image with caption\n        await sock.sendMessage(chatId, {\n            image: imageBuffer,\n            caption: `*@${who.split('@')[0]}*`,\n            mentions: [who]\n        });\n\n    } catch (error) {\n        console.error('Error in stupid command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Sorry, I couldn\\'t generate the stupid card. Please try again later!'\n        });\n    }\n}\n\nmodule.exports = { stupidCommand }; ","size_bytes":1782},"commands/sudo.js":{"content":"\nconst settings = require('../settings');\nconst { addSudo, removeSudo, getSudoList } = require('../lib/index');\n\nfunction extractMentionedJid(message) {\n    const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];\n    if (mentioned.length > 0) return mentioned[0];\n    const text = message.message?.conversation || message.message?.extendedTextMessage?.text || '';\n    const match = text.match(/\\b(\\d{7,15})\\b/);\n    if (match) return match[1] + '@s.whatsapp.net';\n    return null;\n}\n\nasync function sudoCommand(sock, chatId, message) {\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const { isMainOwner } = require('../lib/isOwner');\n    const isOwner = isMainOwner(senderJid);\n\n    const rawText = message.message?.conversation || message.message?.extendedTextMessage?.text || '';\n    const args = rawText.trim().split(' ').slice(1);\n    const sub = (args[0] || '').toLowerCase();\n\n    if (!sub || !['add', 'del', 'remove', 'list'].includes(sub)) {\n        await sock.sendMessage(chatId, { text: 'Usage:\\n.sudo add <@user|number>\\n.sudo del <@user|number>\\n.sudo list' }, { quoted: message });\n        return;\n    }\n\n    if (sub === 'list') {\n        const list = await getSudoList();\n        if (list.length === 0) {\n            await sock.sendMessage(chatId, { text: 'No sudo users set.' }, { quoted: message });\n            return;\n        }\n        const text = list.map((j, i) => `${i + 1}. ${j}`).join('\\n');\n        await sock.sendMessage(chatId, { text: `Sudo users:\\n${text}` }, { quoted: message });\n        return;\n    }\n\n    if (!isOwner) {\n        await sock.sendMessage(chatId, { text: '‚ùå Only the main owner can add/remove sudo users. Use .sudo list to view current sudo users.' }, { quoted: message });\n        return;\n    }\n\n    const targetJid = extractMentionedJid(message);\n    if (!targetJid) {\n        await sock.sendMessage(chatId, { text: 'Please mention a user or provide a number.' }, { quoted: message });\n        return;\n    }\n\n    if (sub === 'add') {\n        const ok = await addSudo(targetJid);\n        await sock.sendMessage(chatId, { text: ok ? `‚úÖ Added sudo: ${targetJid}` : '‚ùå Failed to add sudo' }, { quoted: message });\n        return;\n    }\n\n    if (sub === 'del' || sub === 'remove') {\n        const ownerJid = settings.ownerNumber + '@s.whatsapp.net';\n        if (targetJid === ownerJid) {\n            await sock.sendMessage(chatId, { text: 'Owner cannot be removed.' }, { quoted: message });\n            return;\n        }\n        const ok = await removeSudo(targetJid);\n        await sock.sendMessage(chatId, { text: ok ? `‚úÖ Removed sudo: ${targetJid}` : '‚ùå Failed to remove sudo' }, { quoted: message });\n        return;\n    }\n}\n\nmodule.exports = sudoCommand;\n","size_bytes":2775},"commands/tag.js":{"content":"const isAdmin = require('../lib/isAdmin');\nconst { downloadContentFromMessage } = require('@whiskeysockets/baileys');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadMediaMessage(message, mediaType) {\n    const stream = await downloadContentFromMessage(message, mediaType);\n    let buffer = Buffer.from([]);\n    for await (const chunk of stream) {\n        buffer = Buffer.concat([buffer, chunk]);\n    }\n    const filePath = path.join(__dirname, '../temp/', `${Date.now()}.${mediaType}`);\n    fs.writeFileSync(filePath, buffer);\n    return filePath;\n}\n\nasync function tagCommand(sock, chatId, senderId, messageText, replyMessage, message) {\n    const { isSenderAdmin, isBotAdmin } = await isAdmin(sock, chatId, senderId);\n\n    if (!isBotAdmin) {\n        await sock.sendMessage(chatId, { text: 'Please make the bot an admin first.' }, { quoted: message });\n        return;\n    }\n\n    if (!isSenderAdmin) {\n        const stickerPath = './assets/sticktag.webp';  // Path to your sticker\n        if (fs.existsSync(stickerPath)) {\n            const stickerBuffer = fs.readFileSync(stickerPath);\n            await sock.sendMessage(chatId, { sticker: stickerBuffer }, { quoted: message });\n        }\n        return;\n    }\n\n    const groupMetadata = await sock.groupMetadata(chatId);\n    const participants = groupMetadata.participants;\n    const mentionedJidList = participants.map(p => p.id);\n\n    if (replyMessage) {\n        let messageContent = {};\n\n        // Handle image messages\n        if (replyMessage.imageMessage) {\n            const filePath = await downloadMediaMessage(replyMessage.imageMessage, 'image');\n            messageContent = {\n                image: { url: filePath },\n                caption: messageText || replyMessage.imageMessage.caption || '',\n                mentions: mentionedJidList\n            };\n        }\n        // Handle video messages\n        else if (replyMessage.videoMessage) {\n            const filePath = await downloadMediaMessage(replyMessage.videoMessage, 'video');\n            messageContent = {\n                video: { url: filePath },\n                caption: messageText || replyMessage.videoMessage.caption || '',\n                mentions: mentionedJidList\n            };\n        }\n        // Handle text messages\n        else if (replyMessage.conversation || replyMessage.extendedTextMessage) {\n            messageContent = {\n                text: replyMessage.conversation || replyMessage.extendedTextMessage.text,\n                mentions: mentionedJidList\n            };\n        }\n        // Handle document messages\n        else if (replyMessage.documentMessage) {\n            const filePath = await downloadMediaMessage(replyMessage.documentMessage, 'document');\n            messageContent = {\n                document: { url: filePath },\n                fileName: replyMessage.documentMessage.fileName,\n                caption: messageText || '',\n                mentions: mentionedJidList\n            };\n        }\n\n        if (Object.keys(messageContent).length > 0) {\n            await sock.sendMessage(chatId, messageContent);\n        }\n    } else {\n        await sock.sendMessage(chatId, {\n            text: messageText || \"Tagged message\",\n            mentions: mentionedJidList\n        });\n    }\n}\n\nmodule.exports = tagCommand;\n","size_bytes":3319},"commands/tagall.js":{"content":"const isAdmin = require('../lib/isAdmin');  // Move isAdmin to helpers\n\nasync function tagAllCommand(sock, chatId, senderId) {\n    try {\n        const { isSenderAdmin, isBotAdmin } = await isAdmin(sock, chatId, senderId);\n        \n        if (!isSenderAdmin && !isBotAdmin) {\n            await sock.sendMessage(chatId, {\n                text: 'Only admins can use the .tagall command.'\n            });\n            return;\n        }\n\n        // Get group metadata\n        const groupMetadata = await sock.groupMetadata(chatId);\n        const participants = groupMetadata.participants;\n\n        if (!participants || participants.length === 0) {\n            await sock.sendMessage(chatId, { text: 'No participants found in the group.' });\n            return;\n        }\n\n        // Create message with each member on a new line\n        let message = 'üîä *Hello Everyone:*\\n\\n';\n        participants.forEach(participant => {\n            message += `@${participant.id.split('@')[0]}\\n`; // Add \\n for new line\n        });\n\n        // Send message with mentions\n        await sock.sendMessage(chatId, {\n            text: message,\n            mentions: participants.map(p => p.id)\n        });\n\n    } catch (error) {\n        console.error('Error in tagall command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to tag all members.' });\n    }\n}\n\nmodule.exports = tagAllCommand;  // Export directly\n","size_bytes":1409},"commands/take.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { downloadMediaMessage } = require('@whiskeysockets/baileys');\nconst webp = require('node-webpmux');\nconst crypto = require('crypto');\n\nasync function takeCommand(sock, chatId, message, args) {\n    try {\n        // Check if message is a reply to a sticker\n        const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n        if (!quotedMessage?.stickerMessage) {\n            await sock.sendMessage(chatId, { text: '‚ùå Reply to a sticker with .take <packname>' });\n            return;\n        }\n\n        // Get the packname from args or use default\n        const packname = args.join(' ') || 'Knight Bot';\n\n        try {\n            // Download the sticker\n            const stickerBuffer = await downloadMediaMessage(\n                {\n                    key: message.message.extendedTextMessage.contextInfo.stanzaId,\n                    message: quotedMessage,\n                    messageType: 'stickerMessage'\n                },\n                'buffer',\n                {},\n                {\n                    logger: console,\n                    reuploadRequest: sock.updateMediaMessage\n                }\n            );\n\n            if (!stickerBuffer) {\n                await sock.sendMessage(chatId, { text: '‚ùå Failed to download sticker' });\n                return;\n            }\n\n            // Add metadata using webpmux\n            const img = new webp.Image();\n            await img.load(stickerBuffer);\n\n            // Create metadata\n            const json = {\n                'sticker-pack-id': crypto.randomBytes(32).toString('hex'),\n                'sticker-pack-name': packname,\n                'emojis': ['ü§ñ']\n            };\n\n            // Create exif buffer\n            const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n            const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n            const exif = Buffer.concat([exifAttr, jsonBuffer]);\n            exif.writeUIntLE(jsonBuffer.length, 14, 4);\n\n            // Set the exif data\n            img.exif = exif;\n\n            // Get the final buffer with metadata\n            const finalBuffer = await img.save(null);\n\n            // Send the sticker\n            await sock.sendMessage(chatId, {\n                sticker: finalBuffer\n            }, {\n                quoted: message\n            });\n\n        } catch (error) {\n            console.error('Sticker processing error:', error);\n            await sock.sendMessage(chatId, { text: '‚ùå Error processing sticker' });\n        }\n\n    } catch (error) {\n        console.error('Error in take command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Error processing command' });\n    }\n}\n\nmodule.exports = takeCommand; ","size_bytes":2888},"commands/textmaker.js":{"content":"const axios = require('axios');\nconst mumaker = require('mumaker');\n\n// Base channel info template\nconst channelInfo = {\n    forwardingScore: 1,\n    isForwarded: true,\n};\n\n// Reusable message templates\nconst messageTemplates = {\n    error: (message) => ({\n        text: message,\n        contextInfo: channelInfo\n    }),\n    success: (text, imageUrl) => ({\n        image: { url: imageUrl },\n        caption: \"GENERATED BY KNIGHT-BOT\",\n        contextInfo: channelInfo\n    })\n};\n\nasync function textmakerCommand(sock, chatId, message, q, type) {\n    try {\n        if (!q) {\n            return await sock.sendMessage(chatId, messageTemplates.error(\"Please provide text to generate\\nExample: .metallic Nick\"));\n        }\n\n        // Extract text\n        const text = q.split(' ').slice(1).join(' ');\n\n        if (!text) {\n            return await sock.sendMessage(chatId, messageTemplates.error(\"Please provide text to generate\\nExample: .metallic Nick\"));\n        }\n\n        try {\n            let result;\n            switch (type) {\n                case 'metallic':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/impressive-decorative-3d-metal-text-effect-798.html\", text);\n                    break;\n                case 'ice':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/ice-text-effect-online-101.html\", text);\n                    break;\n                case 'snow':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-a-snow-3d-text-effect-free-online-621.html\", text);\n                    break;\n                case 'impressive':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-3d-colorful-paint-text-effect-online-801.html\", text);\n                    break;\n                case 'matrix':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/matrix-text-effect-154.html\", text);\n                    break;\n                case 'light':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/light-text-effect-futuristic-technology-style-648.html\", text);\n                    break;\n                case 'neon':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-colorful-neon-light-text-effects-online-797.html\", text);\n                    break;\n                case 'devil':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/neon-devil-wings-text-effect-online-683.html\", text);\n                    break;\n                case 'purple':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/purple-text-effect-online-100.html\", text);\n                    break;\n                case 'thunder':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/thunder-text-effect-online-97.html\", text);\n                    break;\n                case 'leaves':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/green-brush-text-effect-typography-maker-online-153.html\", text);\n                    break;\n                case '1917':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/1917-style-text-effect-523.html\", text);\n                    break;\n                case 'arena':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-cover-arena-of-valor-by-mastering-360.html\", text);\n                    break;\n                case 'hacker':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-anonymous-hacker-avatars-cyan-neon-677.html\", text);\n                    break;\n                case 'sand':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/write-names-and-messages-on-the-sand-online-582.html\", text);\n                    break;\n                case 'blackpink':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-a-blackpink-style-logo-with-members-signatures-810.html\", text);\n                    break;\n                case 'glitch':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/create-digital-glitch-text-effects-online-767.html\", text);\n                    break;\n                case 'fire':\n                    result = await mumaker.ephoto(\"https://en.ephoto360.com/flame-lettering-effect-372.html\", text);\n                    break;\n                default:\n                    return await sock.sendMessage(chatId, messageTemplates.error(\"Invalid text generator type\"));\n            }\n\n            if (!result || !result.image) {\n                throw new Error('No image URL received from the API');\n            }\n\n            await sock.sendMessage(chatId, messageTemplates.success(text, result.image));\n        } catch (error) {\n            console.error('Error in text generator:', error);\n            await sock.sendMessage(chatId, messageTemplates.error(`Error: ${error.message}`));\n        }\n    } catch (error) {\n        console.error('Error in textmaker command:', error);\n        await sock.sendMessage(chatId, messageTemplates.error(\"An error occurred. Please try again later.\"));\n    }\n}\n\nmodule.exports = textmakerCommand; ","size_bytes":5232},"commands/tictactoe.js":{"content":"const TicTacToe = require('../lib/tictactoe');\n\n// Store games globally\nconst games = {};\n\nasync function tictactoeCommand(sock, chatId, senderId, text) {\n    try {\n        // Check if player is already in a game\n        if (Object.values(games).find(room => \n            room.id.startsWith('tictactoe') && \n            [room.game.playerX, room.game.playerO].includes(senderId)\n        )) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå You are still in a game. Type *surrender* to quit.' \n            });\n            return;\n        }\n\n        // Look for existing room\n        let room = Object.values(games).find(room => \n            room.state === 'WAITING' && \n            (text ? room.name === text : true)\n        );\n\n        if (room) {\n            // Join existing room\n            room.o = chatId;\n            room.game.playerO = senderId;\n            room.state = 'PLAYING';\n\n            const arr = room.game.render().map(v => ({\n                'X': '‚ùé',\n                'O': '‚≠ï',\n                '1': '1Ô∏è‚É£',\n                '2': '2Ô∏è‚É£',\n                '3': '3Ô∏è‚É£',\n                '4': '4Ô∏è‚É£',\n                '5': '5Ô∏è‚É£',\n                '6': '6Ô∏è‚É£',\n                '7': '7Ô∏è‚É£',\n                '8': '8Ô∏è‚É£',\n                '9': '9Ô∏è‚É£',\n            }[v]));\n\n            const str = `\nüéÆ *TicTacToe Game Started!*\n\nWaiting for @${room.game.currentTurn.split('@')[0]} to play...\n\n${arr.slice(0, 3).join('')}\n${arr.slice(3, 6).join('')}\n${arr.slice(6).join('')}\n\n‚ñ¢ *Room ID:* ${room.id}\n‚ñ¢ *Rules:*\n‚Ä¢ Make 3 rows of symbols vertically, horizontally or diagonally to win\n‚Ä¢ Type a number (1-9) to place your symbol\n‚Ä¢ Type *surrender* to give up\n`;\n\n            // Send message only once to the group\n            await sock.sendMessage(chatId, { \n                text: str,\n                mentions: [room.game.currentTurn, room.game.playerX, room.game.playerO]\n            });\n\n        } else {\n            // Create new room\n            room = {\n                id: 'tictactoe-' + (+new Date),\n                x: chatId,\n                o: '',\n                game: new TicTacToe(senderId, 'o'),\n                state: 'WAITING'\n            };\n\n            if (text) room.name = text;\n\n            await sock.sendMessage(chatId, { \n                text: `‚è≥ *Waiting for opponent*\\nType *.ttt ${text || ''}* to join!`\n            });\n\n            games[room.id] = room;\n        }\n\n    } catch (error) {\n        console.error('Error in tictactoe command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Error starting game. Please try again.' \n        });\n    }\n}\n\nasync function handleTicTacToeMove(sock, chatId, senderId, text) {\n    try {\n        // Find player's game\n        const room = Object.values(games).find(room => \n            room.id.startsWith('tictactoe') && \n            [room.game.playerX, room.game.playerO].includes(senderId) && \n            room.state === 'PLAYING'\n        );\n\n        if (!room) return;\n\n        const isSurrender = /^(surrender|give up)$/i.test(text);\n        \n        if (!isSurrender && !/^[1-9]$/.test(text)) return;\n\n        // Allow surrender at any time, not just during player's turn\n        if (senderId !== room.game.currentTurn && !isSurrender) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Not your turn!' \n            });\n            return;\n        }\n\n        let ok = isSurrender ? true : room.game.turn(\n            senderId === room.game.playerO,\n            parseInt(text) - 1\n        );\n\n        if (!ok) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Invalid move! That position is already taken.' \n            });\n            return;\n        }\n\n        let winner = room.game.winner;\n        let isTie = room.game.turns === 9;\n\n        const arr = room.game.render().map(v => ({\n            'X': '‚ùé',\n            'O': '‚≠ï',\n            '1': '1Ô∏è‚É£',\n            '2': '2Ô∏è‚É£',\n            '3': '3Ô∏è‚É£',\n            '4': '4Ô∏è‚É£',\n            '5': '5Ô∏è‚É£',\n            '6': '6Ô∏è‚É£',\n            '7': '7Ô∏è‚É£',\n            '8': '8Ô∏è‚É£',\n            '9': '9Ô∏è‚É£',\n        }[v]));\n\n        if (isSurrender) {\n            // Set the winner to the opponent of the surrendering player\n            winner = senderId === room.game.playerX ? room.game.playerO : room.game.playerX;\n            \n            // Send a surrender message\n            await sock.sendMessage(chatId, { \n                text: `üè≥Ô∏è @${senderId.split('@')[0]} has surrendered! @${winner.split('@')[0]} wins the game!`,\n                mentions: [senderId, winner]\n            });\n            \n            // Delete the game immediately after surrender\n            delete games[room.id];\n            return;\n        }\n\n        let gameStatus;\n        if (winner) {\n            gameStatus = `üéâ @${winner.split('@')[0]} wins the game!`;\n        } else if (isTie) {\n            gameStatus = `ü§ù Game ended in a draw!`;\n        } else {\n            gameStatus = `üé≤ Turn: @${room.game.currentTurn.split('@')[0]} (${senderId === room.game.playerX ? '‚ùé' : '‚≠ï'})`;\n        }\n\n        const str = `\nüéÆ *TicTacToe Game*\n\n${gameStatus}\n\n${arr.slice(0, 3).join('')}\n${arr.slice(3, 6).join('')}\n${arr.slice(6).join('')}\n\n‚ñ¢ Player ‚ùé: @${room.game.playerX.split('@')[0]}\n‚ñ¢ Player ‚≠ï: @${room.game.playerO.split('@')[0]}\n\n${!winner && !isTie ? '‚Ä¢ Type a number (1-9) to make your move\\n‚Ä¢ Type *surrender* to give up' : ''}\n`;\n\n        const mentions = [\n            room.game.playerX, \n            room.game.playerO,\n            ...(winner ? [winner] : [room.game.currentTurn])\n        ];\n\n        await sock.sendMessage(room.x, { \n            text: str,\n            mentions: mentions\n        });\n\n        if (room.x !== room.o) {\n            await sock.sendMessage(room.o, { \n                text: str,\n                mentions: mentions\n            });\n        }\n\n        if (winner || isTie) {\n            delete games[room.id];\n        }\n\n    } catch (error) {\n        console.error('Error in tictactoe move:', error);\n    }\n}\n\nmodule.exports = {\n    tictactoeCommand,\n    handleTicTacToeMove\n};\n","size_bytes":6222},"commands/tiktok.js":{"content":"const { ttdl } = require(\"ruhend-scraper\");\nconst axios = require('axios');\n\n// Store processed message IDs to prevent duplicates\nconst processedMessages = new Set();\n\nasync function tiktokCommand(sock, chatId, message) {\n    try {\n        // Check if message has already been processed\n        if (processedMessages.has(message.key.id)) {\n            return;\n        }\n        \n        // Add message ID to processed set\n        processedMessages.add(message.key.id);\n        \n        // Clean up old message IDs after 5 minutes\n        setTimeout(() => {\n            processedMessages.delete(message.key.id);\n        }, 5 * 60 * 1000);\n\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        \n        if (!text) {\n            return await sock.sendMessage(chatId, { \n                text: \"Please provide a TikTok link for the video.\"\n            });\n        }\n\n        // Extract URL from command\n        const url = text.split(' ').slice(1).join(' ').trim();\n        \n        if (!url) {\n            return await sock.sendMessage(chatId, { \n                text: \"Please provide a TikTok link for the video.\"\n            });\n        }\n\n        // Check for various TikTok URL formats\n        const tiktokPatterns = [\n            /https?:\\/\\/(?:www\\.)?tiktok\\.com\\//,\n            /https?:\\/\\/(?:vm\\.)?tiktok\\.com\\//,\n            /https?:\\/\\/(?:vt\\.)?tiktok\\.com\\//,\n            /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@/,\n            /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/t\\//\n        ];\n\n        const isValidUrl = tiktokPatterns.some(pattern => pattern.test(url));\n        \n        if (!isValidUrl) {\n            return await sock.sendMessage(chatId, { \n                text: \"That is not a valid TikTok link. Please provide a valid TikTok video link.\"\n            });\n        }\n\n        await sock.sendMessage(chatId, {\n            react: { text: 'üîÑ', key: message.key }\n        });\n\n        try {\n            // Try multiple APIs in sequence\n            const apis = [\n                `https://api.princetechn.com/api/download/tiktok?apikey=prince_tech_api_azfsbshfb&url=${encodeURIComponent(url)}`,\n                `https://api.princetechn.com/api/download/tiktokdlv2?apikey=prince_tech_api_azfsbshfb&url=${encodeURIComponent(url)}`,\n                `https://api.princetechn.com/api/download/tiktokdlv3?apikey=prince_tech_api_azfsbshfb&url=${encodeURIComponent(url)}`,\n                `https://api.princetechn.com/api/download/tiktokdlv4?apikey=prince_tech_api_azfsbshfb&url=${encodeURIComponent(url)}`,\n                `https://api.dreaded.site/api/tiktok?url=${encodeURIComponent(url)}`\n            ];\n\n\n\n            let videoUrl = null;\n            let audioUrl = null;\n            let title = null;\n\n            // Try each API until one works\n            for (const apiUrl of apis) {\n                try {\n                    const response = await axios.get(apiUrl, { timeout: 10000 });\n                    \n                    if (response.data) {\n                        // Handle different API response formats\n                        if (response.data.result && response.data.result.videoUrl) {\n                            // PrinceTech API format\n                            videoUrl = response.data.result.videoUrl;\n                            audioUrl = response.data.result.audioUrl;\n                            title = response.data.result.title;\n                            break;\n                        } else if (response.data.tiktok && response.data.tiktok.video) {\n                            // Dreaded API format\n                            videoUrl = response.data.tiktok.video;\n                            break;\n                        } else if (response.data.video) {\n                            // Alternative format\n                            videoUrl = response.data.video;\n                            break;\n                        }\n                    }\n                } catch (apiError) {\n                    console.error(`TikTok API failed: ${apiError.message}`);\n                    continue;\n                }\n            }\n\n            // If no API worked, try the original ttdl method\n            if (!videoUrl) {\n                let downloadData = await ttdl(url);\n                if (downloadData && downloadData.data && downloadData.data.length > 0) {\n                    const mediaData = downloadData.data;\n                    for (let i = 0; i < Math.min(20, mediaData.length); i++) {\n                        const media = mediaData[i];\n                        const mediaUrl = media.url;\n\n                        // Check if URL ends with common video extensions\n                        const isVideo = /\\.(mp4|mov|avi|mkv|webm)$/i.test(mediaUrl) || \n                                      media.type === 'video';\n\n                        if (isVideo) {\n                            await sock.sendMessage(chatId, {\n                                video: { url: mediaUrl },\n                                mimetype: \"video/mp4\",\n                                caption: \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\"\n                            }, { quoted: message });\n                        } else {\n                            await sock.sendMessage(chatId, {\n                                image: { url: mediaUrl },\n                                caption: \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\"\n                            }, { quoted: message });\n                        }\n                    }\n                    return;\n                }\n            }\n\n            // Send the video if we got a URL from the APIs\n            if (videoUrl) {\n                try {\n                    // Download video as buffer\n                    const videoResponse = await axios.get(videoUrl, {\n                        responseType: 'arraybuffer',\n                        timeout: 30000,\n                        headers: {\n                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n                        }\n                    });\n                    \n                    const videoBuffer = Buffer.from(videoResponse.data);\n                    \n                    const caption = title ? `ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\\n\\nüìù Title: ${title}` : \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\";\n                    \n                    await sock.sendMessage(chatId, {\n                        video: videoBuffer,\n                        mimetype: \"video/mp4\",\n                        caption: caption\n                    }, { quoted: message });\n\n                    // If we have audio URL, download and send it as well\n                    if (audioUrl) {\n                        try {\n                            const audioResponse = await axios.get(audioUrl, {\n                                responseType: 'arraybuffer',\n                                timeout: 30000,\n                                headers: {\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n                                }\n                            });\n                            \n                            const audioBuffer = Buffer.from(audioResponse.data);\n                            \n                            await sock.sendMessage(chatId, {\n                                audio: audioBuffer,\n                                mimetype: \"audio/mp3\",\n                                caption: \"üéµ Audio from TikTok\"\n                            }, { quoted: message });\n                        } catch (audioError) {\n                            console.error(`Failed to download audio: ${audioError.message}`);\n                        }\n                    }\n                    return;\n                } catch (downloadError) {\n                    console.error(`Failed to download video: ${downloadError.message}`);\n                    // Fallback to URL method\n                    try {\n                        const caption = title ? `ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\\n\\nüìù Title: ${title}` : \"ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùóó ùóïùó¨ ùóûùó°ùóúùóöùóõùóß-ùóïùó¢ùóß\";\n                        \n                        await sock.sendMessage(chatId, {\n                            video: { url: videoUrl },\n                            mimetype: \"video/mp4\",\n                            caption: caption\n                        }, { quoted: message });\n                        return;\n                    } catch (urlError) {\n                        console.error(`URL method also failed: ${urlError.message}`);\n                    }\n                }\n            }\n\n            // If we reach here, no method worked\n            return await sock.sendMessage(chatId, { \n                text: \"‚ùå Failed to download TikTok video. All download methods failed. Please try again with a different link or check if the video is available.\"\n            });\n        } catch (error) {\n            console.error('Error in TikTok download:', error);\n            await sock.sendMessage(chatId, { \n                text: \"Failed to download the TikTok video. Please try again with a different link.\"\n            });\n        }\n    } catch (error) {\n        console.error('Error in TikTok command:', error);\n        await sock.sendMessage(chatId, { \n            text: \"An error occurred while processing the request. Please try again later.\"\n        });\n    }\n}\n\nmodule.exports = tiktokCommand; ","size_bytes":9857},"commands/topmembers.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst dataFilePath = path.join(__dirname, '..', 'data', 'messageCount.json');\n\nfunction loadMessageCounts() {\n    if (fs.existsSync(dataFilePath)) {\n        const data = fs.readFileSync(dataFilePath);\n        return JSON.parse(data);\n    }\n    return {};\n}\n\nfunction saveMessageCounts(messageCounts) {\n    fs.writeFileSync(dataFilePath, JSON.stringify(messageCounts, null, 2));\n}\n\nfunction incrementMessageCount(groupId, userId) {\n    const messageCounts = loadMessageCounts();\n\n    if (!messageCounts[groupId]) {\n        messageCounts[groupId] = {};\n    }\n\n    if (!messageCounts[groupId][userId]) {\n        messageCounts[groupId][userId] = 0;\n    }\n\n    messageCounts[groupId][userId] += 1;\n\n    saveMessageCounts(messageCounts);\n}\n\nfunction topMembers(sock, chatId, isGroup) {\n    if (!isGroup) {\n        sock.sendMessage(chatId, { text: 'This command is only available in group chats.' });\n        return;\n    }\n\n    const messageCounts = loadMessageCounts();\n    const groupCounts = messageCounts[chatId] || {};\n\n    const sortedMembers = Object.entries(groupCounts)\n        .sort(([, a], [, b]) => b - a)\n        .slice(0, 5); // Get top 5 members\n\n    if (sortedMembers.length === 0) {\n        sock.sendMessage(chatId, { text: 'No message activity recorded yet.' });\n        return;\n    }\n\n    let message = 'üèÜ Top Members Based on Message Count:\\n\\n';\n    sortedMembers.forEach(([userId, count], index) => {\n        message += `${index + 1}. @${userId.split('@')[0]} - ${count} messages\\n`;\n    });\n\n    sock.sendMessage(chatId, { text: message, mentions: sortedMembers.map(([userId]) => userId) });\n}\n\nmodule.exports = { incrementMessageCount, topMembers };\n","size_bytes":1727},"commands/translate.js":{"content":"const fetch = require('node-fetch');\n\nasync function handleTranslateCommand(sock, chatId, message, match) {\n    try {\n        // Show typing indicator\n        await sock.presenceSubscribe(chatId);\n        await sock.sendPresenceUpdate('composing', chatId);\n\n        let textToTranslate = '';\n        let lang = '';\n\n        // Check if it's a reply\n        const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n        if (quotedMessage) {\n            // Get text from quoted message\n            textToTranslate = quotedMessage.conversation || \n                            quotedMessage.extendedTextMessage?.text || \n                            quotedMessage.imageMessage?.caption || \n                            quotedMessage.videoMessage?.caption || \n                            '';\n\n            // Get language from command\n            lang = match.trim();\n        } else {\n            // Parse command arguments for direct message\n            const args = match.trim().split(' ');\n            if (args.length < 2) {\n                return sock.sendMessage(chatId, {\n                    text: `*TRANSLATOR*\\n\\nUsage:\\n1. Reply to a message with: .translate <lang> or .trt <lang>\\n2. Or type: .translate <text> <lang> or .trt <text> <lang>\\n\\nExample:\\n.translate hello fr\\n.trt hello fr\\n\\nLanguage codes:\\nfr - French\\nes - Spanish\\nde - German\\nit - Italian\\npt - Portuguese\\nru - Russian\\nja - Japanese\\nko - Korean\\nzh - Chinese\\nar - Arabic\\nhi - Hindi`,\n                    quoted: message\n                });\n            }\n\n            lang = args.pop(); // Get language code\n            textToTranslate = args.join(' '); // Get text to translate\n        }\n\n        if (!textToTranslate) {\n            return sock.sendMessage(chatId, {\n                text: '‚ùå No text found to translate. Please provide text or reply to a message.',\n                quoted: message\n            });\n        }\n\n        // Try multiple translation APIs in sequence\n        let translatedText = null;\n        let error = null;\n\n        // Try API 1 (Google Translate API)\n        try {\n            const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=${lang}&dt=t&q=${encodeURIComponent(textToTranslate)}`);\n            if (response.ok) {\n                const data = await response.json();\n                if (data && data[0] && data[0][0] && data[0][0][0]) {\n                    translatedText = data[0][0][0];\n                }\n            }\n        } catch (e) {\n            error = e;\n        }\n\n        // If API 1 fails, try API 2\n        if (!translatedText) {\n            try {\n                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=auto|${lang}`);\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data && data.responseData && data.responseData.translatedText) {\n                        translatedText = data.responseData.translatedText;\n                    }\n                }\n            } catch (e) {\n                error = e;\n            }\n        }\n\n        // If API 2 fails, try API 3\n        if (!translatedText) {\n            try {\n                const response = await fetch(`https://api.dreaded.site/api/translate?text=${encodeURIComponent(textToTranslate)}&lang=${lang}`);\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data && data.translated) {\n                        translatedText = data.translated;\n                    }\n                }\n            } catch (e) {\n                error = e;\n            }\n        }\n\n        if (!translatedText) {\n            throw new Error('All translation APIs failed');\n        }\n\n        // Send translation\n        await sock.sendMessage(chatId, {\n            text: `${translatedText}`,\n        }, {\n            quoted: message\n        });\n\n    } catch (error) {\n        console.error('‚ùå Error in translate command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Failed to translate text. Please try again later.\\n\\nUsage:\\n1. Reply to a message with: .translate <lang> or .trt <lang>\\n2. Or type: .translate <text> <lang> or .trt <text> <lang>',\n            quoted: message\n        });\n    }\n}\n\nmodule.exports = {\n    handleTranslateCommand\n}; ","size_bytes":4435},"commands/trivia.js":{"content":"const axios = require('axios');\n\nlet triviaGames = {};\n\nasync function startTrivia(sock, chatId) {\n    if (triviaGames[chatId]) {\n        sock.sendMessage(chatId, { text: 'A trivia game is already in progress!' });\n        return;\n    }\n\n    try {\n        const response = await axios.get('https://opentdb.com/api.php?amount=1&type=multiple');\n        const questionData = response.data.results[0];\n\n        triviaGames[chatId] = {\n            question: questionData.question,\n            correctAnswer: questionData.correct_answer,\n            options: [...questionData.incorrect_answers, questionData.correct_answer].sort(),\n        };\n\n        sock.sendMessage(chatId, {\n            text: `Trivia Time!\\n\\nQuestion: ${triviaGames[chatId].question}\\nOptions:\\n${triviaGames[chatId].options.join('\\n')}`\n        });\n    } catch (error) {\n        sock.sendMessage(chatId, { text: 'Error fetching trivia question. Try again later.' });\n    }\n}\n\nfunction answerTrivia(sock, chatId, answer) {\n    if (!triviaGames[chatId]) {\n        sock.sendMessage(chatId, { text: 'No trivia game is in progress.' });\n        return;\n    }\n\n    const game = triviaGames[chatId];\n\n    if (answer.toLowerCase() === game.correctAnswer.toLowerCase()) {\n        sock.sendMessage(chatId, { text: `Correct! The answer is ${game.correctAnswer}` });\n    } else {\n        sock.sendMessage(chatId, { text: `Wrong! The correct answer was ${game.correctAnswer}` });\n    }\n\n    delete triviaGames[chatId];\n}\n\nmodule.exports = { startTrivia, answerTrivia };\n","size_bytes":1525},"commands/truth.js":{"content":"const fetch = require('node-fetch');\n\nasync function truthCommand(sock, chatId, message) {\n    try {\n        const shizokeys = 'shizo';\n        const res = await fetch(`https://shizoapi.onrender.com/api/texts/truth?apikey=${shizokeys}`);\n        \n        if (!res.ok) {\n            throw await res.text();\n        }\n        \n        const json = await res.json();\n        const truthMessage = json.result;\n\n        // Send the truth message\n        await sock.sendMessage(chatId, { text: truthMessage }, { quoted: message });\n    } catch (error) {\n        console.error('Error in truth command:', error);\n        await sock.sendMessage(chatId, { text: '‚ùå Failed to get truth. Please try again later!' }, { quoted: message });\n    }\n}\n\nmodule.exports = { truthCommand };\n","size_bytes":772},"commands/tts.js":{"content":"const gTTS = require('gtts');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function ttsCommand(sock, chatId, text, message, language = 'en') {\n    if (!text) {\n        await sock.sendMessage(chatId, { text: 'Please provide the text for TTS conversion.' });\n        return;\n    }\n\n    const fileName = `tts-${Date.now()}.mp3`;\n    const filePath = path.join(__dirname, '..', 'assets', fileName);\n\n    const gtts = new gTTS(text, language);\n    gtts.save(filePath, async function (err) {\n        if (err) {\n            await sock.sendMessage(chatId, { text: 'Error generating TTS audio.' });\n            return;\n        }\n\n        await sock.sendMessage(chatId, {\n            audio: { url: filePath },\n            mimetype: 'audio/mpeg'\n        }, { quoted: message });\n\n        fs.unlinkSync(filePath);\n    });\n}\n\nmodule.exports = ttsCommand;\n","size_bytes":860},"commands/unban.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { channelInfo } = require('../lib/messageConfig');\n\nasync function unbanCommand(sock, chatId, message) {\n    let userToUnban;\n    \n    // Check for mentioned users\n    if (message.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n        userToUnban = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n    }\n    // Check for replied message\n    else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n        userToUnban = message.message.extendedTextMessage.contextInfo.participant;\n    }\n    \n    if (!userToUnban) {\n        await sock.sendMessage(chatId, { \n            text: 'Please mention the user or reply to their message to unban!', \n            ...channelInfo \n        }, { quoted: message });\n        return;\n    }\n\n    try {\n        const bannedUsers = JSON.parse(fs.readFileSync('./data/banned.json'));\n        const index = bannedUsers.indexOf(userToUnban);\n        if (index > -1) {\n            bannedUsers.splice(index, 1);\n            fs.writeFileSync('./data/banned.json', JSON.stringify(bannedUsers, null, 2));\n            \n            await sock.sendMessage(chatId, { \n                text: `Successfully unbanned ${userToUnban.split('@')[0]}!`,\n                mentions: [userToUnban],\n                ...channelInfo \n            });\n        } else {\n            await sock.sendMessage(chatId, { \n                text: `${userToUnban.split('@')[0]} is not banned!`,\n                mentions: [userToUnban],\n                ...channelInfo \n            });\n        }\n    } catch (error) {\n        console.error('Error in unban command:', error);\n        await sock.sendMessage(chatId, { text: 'Failed to unban user!', ...channelInfo }, { quoted: message });\n    }\n}\n\nmodule.exports = unbanCommand; ","size_bytes":1834},"commands/unmute.js":{"content":"async function unmuteCommand(sock, chatId) {\n    await sock.groupSettingUpdate(chatId, 'not_announcement'); // Unmute the group\n    await sock.sendMessage(chatId, { text: 'The group has been unmuted.' });\n}\n\nmodule.exports = unmuteCommand;\n","size_bytes":240},"commands/update.js":{"content":"const { exec } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst https = require('https');\nconst settings = require('../settings');\n\nfunction run(cmd) {\n    return new Promise((resolve, reject) => {\n        exec(cmd, { windowsHide: true }, (err, stdout, stderr) => {\n            if (err) return reject(new Error((stderr || stdout || err.message || '').toString()));\n            resolve((stdout || '').toString());\n        });\n    });\n}\n\nasync function hasGitRepo() {\n    const gitDir = path.join(process.cwd(), '.git');\n    if (!fs.existsSync(gitDir)) return false;\n    try {\n        await run('git --version');\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nasync function updateViaGit() {\n    const oldRev = (await run('git rev-parse HEAD').catch(() => 'unknown')).trim();\n    await run('git fetch --all --prune');\n    const newRev = (await run('git rev-parse origin/main')).trim();\n    const alreadyUpToDate = oldRev === newRev;\n    const commits = alreadyUpToDate ? '' : await run(`git log --pretty=format:\"%h %s (%an)\" ${oldRev}..${newRev}`).catch(() => '');\n    const files = alreadyUpToDate ? '' : await run(`git diff --name-status ${oldRev} ${newRev}`).catch(() => '');\n    await run(`git reset --hard ${newRev}`);\n    await run('git clean -fd');\n    return { oldRev, newRev, alreadyUpToDate, commits, files };\n}\n\nfunction downloadFile(url, dest, visited = new Set()) {\n    return new Promise((resolve, reject) => {\n        try {\n            // Avoid infinite redirect loops\n            if (visited.has(url) || visited.size > 5) {\n                return reject(new Error('Too many redirects'));\n            }\n            visited.add(url);\n\n            const useHttps = url.startsWith('https://');\n            const client = useHttps ? require('https') : require('http');\n            const req = client.get(url, {\n                headers: {\n                    'User-Agent': 'KnightBot-Updater/1.0',\n                    'Accept': '*/*'\n                }\n            }, res => {\n                // Handle redirects\n                if ([301, 302, 303, 307, 308].includes(res.statusCode)) {\n                    const location = res.headers.location;\n                    if (!location) return reject(new Error(`HTTP ${res.statusCode} without Location`));\n                    const nextUrl = new URL(location, url).toString();\n                    res.resume();\n                    return downloadFile(nextUrl, dest, visited).then(resolve).catch(reject);\n                }\n\n                if (res.statusCode !== 200) {\n                    return reject(new Error(`HTTP ${res.statusCode}`));\n                }\n\n                const file = fs.createWriteStream(dest);\n                res.pipe(file);\n                file.on('finish', () => file.close(resolve));\n                file.on('error', err => {\n                    try { file.close(() => {}); } catch {}\n                    fs.unlink(dest, () => reject(err));\n                });\n            });\n            req.on('error', err => {\n                fs.unlink(dest, () => reject(err));\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function extractZip(zipPath, outDir) {\n    // Try to use platform tools; no extra npm modules required\n    if (process.platform === 'win32') {\n        const cmd = `powershell -NoProfile -Command \"Expand-Archive -Path '${zipPath}' -DestinationPath '${outDir.replace(/\\\\/g, '/')}' -Force\"`;\n        await run(cmd);\n        return;\n    }\n    // Linux/mac: try unzip, else 7z, else busybox unzip\n    try {\n        await run('command -v unzip');\n        await run(`unzip -o '${zipPath}' -d '${outDir}'`);\n        return;\n    } catch {}\n    try {\n        await run('command -v 7z');\n        await run(`7z x -y '${zipPath}' -o'${outDir}'`);\n        return;\n    } catch {}\n    try {\n        await run('busybox unzip -h');\n        await run(`busybox unzip -o '${zipPath}' -d '${outDir}'`);\n        return;\n    } catch {}\n    throw new Error(\"No system unzip tool found (unzip/7z/busybox). Git mode is recommended on this panel.\");\n}\n\nfunction copyRecursive(src, dest, ignore = [], relative = '', outList = []) {\n    if (!fs.existsSync(dest)) fs.mkdirSync(dest, { recursive: true });\n    for (const entry of fs.readdirSync(src)) {\n        if (ignore.includes(entry)) continue;\n        const s = path.join(src, entry);\n        const d = path.join(dest, entry);\n        const stat = fs.lstatSync(s);\n        if (stat.isDirectory()) {\n            copyRecursive(s, d, ignore, path.join(relative, entry), outList);\n        } else {\n            fs.copyFileSync(s, d);\n            if (outList) outList.push(path.join(relative, entry).replace(/\\\\/g, '/'));\n        }\n    }\n}\n\nasync function updateViaZip(sock, chatId, message, zipOverride) {\n    const zipUrl = (zipOverride || settings.updateZipUrl || process.env.UPDATE_ZIP_URL || '').trim();\n    if (!zipUrl) {\n        throw new Error('No ZIP URL configured. Set settings.updateZipUrl or UPDATE_ZIP_URL env.');\n    }\n    const tmpDir = path.join(process.cwd(), 'tmp');\n    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });\n    const zipPath = path.join(tmpDir, 'update.zip');\n    await downloadFile(zipUrl, zipPath);\n    const extractTo = path.join(tmpDir, 'update_extract');\n    if (fs.existsSync(extractTo)) fs.rmSync(extractTo, { recursive: true, force: true });\n    await extractZip(zipPath, extractTo);\n\n    // Find the top-level extracted folder (GitHub zips create REPO-branch folder)\n    const [root] = fs.readdirSync(extractTo).map(n => path.join(extractTo, n));\n    const srcRoot = fs.existsSync(root) && fs.lstatSync(root).isDirectory() ? root : extractTo;\n\n    // Copy over while preserving runtime dirs/files\n    const ignore = ['node_modules', '.git', 'session', 'tmp', 'tmp/', 'temp', 'data', 'baileys_store.json'];\n    const copied = [];\n    // Preserve ownerNumber from existing settings.js if present\n    let preservedOwner = null;\n    let preservedBotOwner = null;\n    try {\n        const currentSettings = require('../settings');\n        preservedOwner = currentSettings && currentSettings.ownerNumber ? String(currentSettings.ownerNumber) : null;\n        preservedBotOwner = currentSettings && currentSettings.botOwner ? String(currentSettings.botOwner) : null;\n    } catch {}\n    copyRecursive(srcRoot, process.cwd(), ignore, '', copied);\n    if (preservedOwner) {\n        try {\n            const settingsPath = path.join(process.cwd(), 'settings.js');\n            if (fs.existsSync(settingsPath)) {\n                let text = fs.readFileSync(settingsPath, 'utf8');\n                text = text.replace(/ownerNumber:\\s*'[^']*'/, `ownerNumber: '${preservedOwner}'`);\n                if (preservedBotOwner) {\n                    text = text.replace(/botOwner:\\s*'[^']*'/, `botOwner: '${preservedBotOwner}'`);\n                }\n                fs.writeFileSync(settingsPath, text);\n            }\n        } catch {}\n    }\n    // Cleanup extracted directory\n    try { fs.rmSync(extractTo, { recursive: true, force: true }); } catch {}\n    try { fs.rmSync(zipPath, { force: true }); } catch {}\n    return { copiedFiles: copied };\n}\n\nasync function restartProcess(sock, chatId, message) {\n    try {\n        await sock.sendMessage(chatId, { text: '‚úÖ Update complete! Restarting‚Ä¶' }, { quoted: message });\n    } catch {}\n    try {\n        // Preferred: PM2\n        await run('pm2 restart all');\n        return;\n    } catch {}\n    // Panels usually auto-restart when the process exits.\n    // Exit after a short delay to allow the above message to flush.\n    setTimeout(() => {\n        process.exit(0);\n    }, 500);\n}\n\nasync function updateCommand(sock, chatId, message, senderIsSudo, zipOverride) {\n    // Check if sender is the owner\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudoFunc = require('../lib/isOwner');\n    const isOwner = await isOwnerOrSudoFunc(senderJid);\n\n    if (!isOwner) {\n        await sock.sendMessage(chatId, { text: '‚ùå This command is only available for the owner!' });\n        return;\n    }\n    try {\n        // Minimal UX\n        await sock.sendMessage(chatId, { text: 'üîÑ Updating the bot, please wait‚Ä¶' }, { quoted: message });\n        if (await hasGitRepo()) {\n            // silent\n            const { oldRev, newRev, alreadyUpToDate, commits, files } = await updateViaGit();\n            // Short message only: version info\n            const summary = alreadyUpToDate ? `‚úÖ Already up to date: ${newRev}` : `‚úÖ Updated to ${newRev}`;\n            console.log('[update] summary generated');\n            // silent\n            await run('npm install --no-audit --no-fund');\n        } else {\n            const { copiedFiles } = await updateViaZip(sock, chatId, message, zipOverride);\n            // silent\n        }\n        try {\n            const v = require('../settings').version || '';\n            await sock.sendMessage(chatId, { text: `‚úÖ Update done. Restarting‚Ä¶` }, { quoted: message });\n        } catch {\n            await sock.sendMessage(chatId, { text: '‚úÖ Restared Successfully\\n Type .ping to check latest version.' }, { quoted: message });\n        }\n        await restartProcess(sock, chatId, message);\n    } catch (err) {\n        console.error('Update failed:', err);\n        await sock.sendMessage(chatId, { text: `‚ùå Update failed:\\n${String(err.message || err)}` }, { quoted: message });\n    }\n}\n\nmodule.exports = updateCommand;","size_bytes":9496},"commands/video.js":{"content":"const axios = require('axios');\nconst yts = require('yt-search');\nconst fs = require('fs');\nconst path = require('path');\nconst { exec } = require('child_process');\nconst util = require('util');\nconst execPromise = util.promisify(exec);\n\nconst princeVideoApi = {\n    base: 'https://api.princetechn.com/api/download/ytmp4',\n    apikey: process.env.PRINCE_API_KEY || 'prince_tech_api_azfsbshfb',\n    async fetchMeta(videoUrl) {\n        const params = new URLSearchParams({ apikey: this.apikey, url: videoUrl });\n        const url = `${this.base}?${params.toString()}`;\n        const { data } = await axios.get(url, { timeout: 20000, headers: { 'user-agent': 'Mozilla/5.0', accept: 'application/json' } });\n        return data;\n    }\n};\n\nasync function videoCommand(sock, chatId, message) {\n    try {\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;\n        const searchQuery = text.split(' ').slice(1).join(' ').trim();\n        \n        \n        if (!searchQuery) {\n            await sock.sendMessage(chatId, { text: 'What video do you want to download?' }, { quoted: message });\n            return;\n        }\n\n        // Determine if input is a YouTube link\n        let videoUrl = '';\n        let videoTitle = '';\n        let videoThumbnail = '';\n        if (searchQuery.startsWith('http://') || searchQuery.startsWith('https://')) {\n            videoUrl = searchQuery;\n        } else {\n            // Search YouTube for the video\n            const { videos } = await yts(searchQuery);\n            if (!videos || videos.length === 0) {\n                await sock.sendMessage(chatId, { text: 'No videos found!' }, { quoted: message });\n                return;\n            }\n            videoUrl = videos[0].url;\n            videoTitle = videos[0].title;\n            videoThumbnail = videos[0].thumbnail;\n        }\n\n        // Send thumbnail immediately\n        try {\n            const ytId = (videoUrl.match(/(?:youtu\\.be\\/|v=)([a-zA-Z0-9_-]{11})/) || [])[1];\n            const thumb = videoThumbnail || (ytId ? `https://i.ytimg.com/vi/${ytId}/sddefault.jpg` : undefined);\n            const captionTitle = videoTitle || searchQuery;\n            if (thumb) {\n                await sock.sendMessage(chatId, {\n                    image: { url: thumb },\n                    caption: `*${captionTitle}*\\nDownloading...`\n                }, { quoted: message });\n            }\n        } catch (e) { console.error('[VIDEO] thumb error:', e?.message || e); }\n        \n\n        // Validate YouTube URL\n        let urls = videoUrl.match(/(?:https?:\\/\\/)?(?:youtu\\.be\\/|(?:www\\.|m\\.)?youtube\\.com\\/(?:watch\\?v=|v\\/|embed\\/|shorts\\/|playlist\\?list=)?)([a-zA-Z0-9_-]{11})/gi);\n        if (!urls) {\n            await sock.sendMessage(chatId, { text: 'This is not a valid YouTube link!' }, { quoted: message });\n            return;\n        }\n\n        // PrinceTech video API\n        let videoDownloadUrl = '';\n        let title = '';\n        try {\n            const meta = await princeVideoApi.fetchMeta(videoUrl);\n            if (meta?.success && meta?.result?.download_url) {\n                videoDownloadUrl = meta.result.download_url;\n                title = meta.result.title || 'video';\n            } else {\n                await sock.sendMessage(chatId, { text: 'Failed to fetch video from the API.' }, { quoted: message });\n                return;\n            }\n        } catch (e) {\n            console.error('[VIDEO] prince api error:', e?.message || e);\n            await sock.sendMessage(chatId, { text: 'Failed to fetch video from the API.' }, { quoted: message });\n            return;\n        }\n        const filename = `${title}.mp4`;\n\n        // Try sending the video directly from the remote URL (like play.js)\n        try {\n            await sock.sendMessage(chatId, {\n                video: { url: videoDownloadUrl },\n                mimetype: 'video/mp4',\n                fileName: filename,\n                caption: `*${title}*\\n\\n> *_Downloaded by Knight Bot MD_*`\n            }, { quoted: message });\n            return;\n        } catch (directSendErr) {\n            console.log('[video.js] Direct send from URL failed:', directSendErr.message);\n        }\n\n        // If direct send fails, fallback to downloading and converting\n        // Download the video file first\n        const tempDir = path.join(__dirname, '../temp');\n        if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);\n        const tempFile = path.join(tempDir, `${Date.now()}.mp4`);\n        const convertedFile = path.join(tempDir, `converted_${Date.now()}.mp4`);\n        \n        let buffer;\n        let download403 = false;\n        try {\n            const videoRes = await axios.get(videoDownloadUrl, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',\n                    'Referer': 'https://youtube.com/'\n                },\n                responseType: 'arraybuffer'\n            });\n            buffer = Buffer.from(videoRes.data);\n        } catch (err) {\n            if (err.response && err.response.status === 403) {\n                // try alternate URL pattern as best-effort\n                download403 = true;\n            } else {\n                await sock.sendMessage(chatId, { text: 'Failed to download the video file.' }, { quoted: message });\n                return;\n            }\n        }\n        // Fallback: try another URL if 403\n        if (download403) {\n            let altUrl = videoDownloadUrl.replace(/(cdn|s)\\d+/, 's5');\n            try {\n                const videoRes = await axios.get(altUrl, {\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',\n                        'Referer': 'https://youtube.com/'\n                    },\n                    responseType: 'arraybuffer'\n                });\n                buffer = Buffer.from(videoRes.data);\n            } catch (err2) {\n                await sock.sendMessage(chatId, { text: 'Failed to download the video file from alternate CDN.' }, { quoted: message });\n                return;\n            }\n        }\n        if (!buffer || buffer.length < 1024) {\n            await sock.sendMessage(chatId, { text: 'Downloaded file is empty or too small.' }, { quoted: message });\n            return;\n        }\n        \n        fs.writeFileSync(tempFile, buffer);\n\n        try {\n            await execPromise(`ffmpeg -i \"${tempFile}\" -c:v libx264 -c:a aac -preset veryfast -crf 26 -movflags +faststart \"${convertedFile}\"`);\n            // Check if conversion was successful\n            if (!fs.existsSync(convertedFile)) {\n                await sock.sendMessage(chatId, { text: 'Converted file missing.' }, { quoted: message });\n                return;\n            }\n            const stats = fs.statSync(convertedFile);\n            const maxSize = 62 * 1024 * 1024; // 62MB\n            if (stats.size > maxSize) {\n                await sock.sendMessage(chatId, { text: 'Video is too large to send on WhatsApp.' }, { quoted: message });\n                return;\n            }\n            // Try sending the converted video\n            try {\n                await sock.sendMessage(chatId, {\n                    video: { url: convertedFile },\n                    mimetype: 'video/mp4',\n                    fileName: filename,\n                    caption: `*${title}*`\n                }, { quoted: message });\n            } catch (sendErr) {\n                console.error('[VIDEO] send url failed, trying buffer:', sendErr?.message || sendErr);\n                const videoBuffer = fs.readFileSync(convertedFile);\n                await sock.sendMessage(chatId, {\n                    video: videoBuffer,\n                    mimetype: 'video/mp4',\n                    fileName: filename,\n                    caption: `*${title}*`\n                }, { quoted: message });\n            }\n            \n        } catch (conversionError) {\n            console.error('[VIDEO] conversion failed, trying original file:', conversionError?.message || conversionError);\n            try {\n                if (!fs.existsSync(tempFile)) {\n                    await sock.sendMessage(chatId, { text: 'Temp file missing.' }, { quoted: message });\n                    return;\n                }\n                const origStats = fs.statSync(tempFile);\n                const maxSize = 62 * 1024 * 1024; // 62MB\n                if (origStats.size > maxSize) {\n                    await sock.sendMessage(chatId, { text: 'Video is too large to send on WhatsApp.' }, { quoted: message });\n                    return;\n                }\n            } catch {}\n            // Try sending the original file\n            try {\n                await sock.sendMessage(chatId, {\n                    video: { url: tempFile },\n                    mimetype: 'video/mp4',\n                    fileName: filename,\n                    caption: `*${title}*`\n                }, { quoted: message });\n            } catch (sendErr2) {\n                console.error('[VIDEO] send original url failed, trying buffer:', sendErr2?.message || sendErr2);\n                const videoBuffer = fs.readFileSync(tempFile);\n                await sock.sendMessage(chatId, {\n                    video: videoBuffer,\n                    mimetype: 'video/mp4',\n                    fileName: filename,\n                    caption: `*${title}*`\n                }, { quoted: message });\n            }\n        }\n\n        // Clean up temp files\n        setTimeout(() => {\n            try {\n                if (fs.existsSync(tempFile)) {\n                    fs.unlinkSync(tempFile);\n                }\n                if (fs.existsSync(convertedFile)) {\n                    fs.unlinkSync(convertedFile);\n                }\n            } catch (cleanupErr) {\n                console.error('[VIDEO] cleanup error:', cleanupErr?.message || cleanupErr);\n            }\n        }, 3000);\n\n\n    } catch (error) {\n        console.error('[VIDEO] Command Error:', error?.message || error);\n        await sock.sendMessage(chatId, { text: 'Download failed: ' + (error?.message || 'Unknown error') }, { quoted: message });\n    }\n}\n\nmodule.exports = videoCommand; ","size_bytes":10190},"commands/viewonce.js":{"content":"const { downloadContentFromMessage } = require('@whiskeysockets/baileys');\n\nasync function viewonceCommand(sock, chatId, message) {\n    // Extract quoted imageMessage or videoMessage from your structure\n    const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n    const quotedImage = quoted?.imageMessage;\n    const quotedVideo = quoted?.videoMessage;\n\n    if (quotedImage && quotedImage.viewOnce) {\n        // Download and send the image\n        const stream = await downloadContentFromMessage(quotedImage, 'image');\n        let buffer = Buffer.from([]);\n        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);\n        await sock.sendMessage(chatId, { image: buffer, fileName: 'media.jpg', caption: quotedImage.caption || '' }, { quoted: message });\n    } else if (quotedVideo && quotedVideo.viewOnce) {\n        // Download and send the video\n        const stream = await downloadContentFromMessage(quotedVideo, 'video');\n        let buffer = Buffer.from([]);\n        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);\n        await sock.sendMessage(chatId, { video: buffer, fileName: 'media.mp4', caption: quotedVideo.caption || '' }, { quoted: message });\n    } else {\n        await sock.sendMessage(chatId, { text: '‚ùå Please reply to a view-once image or video.' }, { quoted: message });\n    }\n}\n\nmodule.exports = viewonceCommand; ","size_bytes":1416},"commands/warn.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst isAdmin = require('../lib/isAdmin');\n\n// Define paths\nconst databaseDir = path.join(process.cwd(), 'data');\nconst warningsPath = path.join(databaseDir, 'warnings.json');\n\n// Initialize warnings file if it doesn't exist\nfunction initializeWarningsFile() {\n    // Create database directory if it doesn't exist\n    if (!fs.existsSync(databaseDir)) {\n        fs.mkdirSync(databaseDir, { recursive: true });\n    }\n    \n    // Create warnings.json if it doesn't exist\n    if (!fs.existsSync(warningsPath)) {\n        fs.writeFileSync(warningsPath, JSON.stringify({}), 'utf8');\n    }\n}\n\nasync function warnCommand(sock, chatId, senderId, mentionedJids, message) {\n    try {\n        // Initialize files first\n        initializeWarningsFile();\n\n        // First check if it's a group\n        if (!chatId.endsWith('@g.us')) {\n            await sock.sendMessage(chatId, { \n                text: 'This command can only be used in groups!'\n            });\n            return;\n        }\n\n        // Check admin status first\n        try {\n            const { isSenderAdmin, isBotAdmin } = await isAdmin(sock, chatId, senderId);\n            \n            if (!isBotAdmin) {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Error: Please make the bot an admin first to use this command.'\n                });\n                return;\n            }\n\n            if (!isSenderAdmin) {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Error: Only group admins can use the warn command.'\n                });\n                return;\n            }\n        } catch (adminError) {\n            console.error('Error checking admin status:', adminError);\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Error: Please make sure the bot is an admin of this group.'\n            });\n            return;\n        }\n\n        let userToWarn;\n        \n        // Check for mentioned users\n        if (mentionedJids && mentionedJids.length > 0) {\n            userToWarn = mentionedJids[0];\n        }\n        // Check for replied message\n        else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n            userToWarn = message.message.extendedTextMessage.contextInfo.participant;\n        }\n        \n        if (!userToWarn) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Error: Please mention the user or reply to their message to warn!'\n            });\n            return;\n        }\n\n        // Add delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        try {\n            // Read warnings, create empty object if file is empty\n            let warnings = {};\n            try {\n                warnings = JSON.parse(fs.readFileSync(warningsPath, 'utf8'));\n            } catch (error) {\n                warnings = {};\n            }\n\n            // Initialize nested objects if they don't exist\n            if (!warnings[chatId]) warnings[chatId] = {};\n            if (!warnings[chatId][userToWarn]) warnings[chatId][userToWarn] = 0;\n            \n            warnings[chatId][userToWarn]++;\n            fs.writeFileSync(warningsPath, JSON.stringify(warnings, null, 2));\n\n            const warningMessage = `*„Äé WARNING ALERT „Äè*\\n\\n` +\n                `üë§ *Warned User:* @${userToWarn.split('@')[0]}\\n` +\n                `‚ö†Ô∏è *Warning Count:* ${warnings[chatId][userToWarn]}/3\\n` +\n                `üëë *Warned By:* @${senderId.split('@')[0]}\\n\\n` +\n                `üìÖ *Date:* ${new Date().toLocaleString()}`;\n\n            await sock.sendMessage(chatId, { \n                text: warningMessage,\n                mentions: [userToWarn, senderId]\n            });\n\n            // Auto-kick after 3 warnings\n            if (warnings[chatId][userToWarn] >= 3) {\n                // Add delay to avoid rate limiting\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                await sock.groupParticipantsUpdate(chatId, [userToWarn], \"remove\");\n                delete warnings[chatId][userToWarn];\n                fs.writeFileSync(warningsPath, JSON.stringify(warnings, null, 2));\n                \n                const kickMessage = `*„Äé AUTO-KICK „Äè*\\n\\n` +\n                    `@${userToWarn.split('@')[0]} has been removed from the group after receiving 3 warnings! ‚ö†Ô∏è`;\n\n                await sock.sendMessage(chatId, { \n                    text: kickMessage,\n                    mentions: [userToWarn]\n                });\n            }\n        } catch (error) {\n            console.error('Error in warn command:', error);\n            await sock.sendMessage(chatId, { \n                text: '‚ùå Failed to warn user!'\n            });\n        }\n    } catch (error) {\n        console.error('Error in warn command:', error);\n        if (error.data === 429) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            try {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Rate limit reached. Please try again in a few seconds.'\n                });\n            } catch (retryError) {\n                console.error('Error sending retry message:', retryError);\n            }\n        } else {\n            try {\n                await sock.sendMessage(chatId, { \n                    text: '‚ùå Failed to warn user. Make sure the bot is admin and has sufficient permissions.'\n                });\n            } catch (sendError) {\n                console.error('Error sending error message:', sendError);\n            }\n        }\n    }\n}\n\nmodule.exports = warnCommand;\n","size_bytes":5663},"commands/warnings.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst warningsFilePath = path.join(__dirname, '../data/warnings.json');\n\nfunction loadWarnings() {\n    if (!fs.existsSync(warningsFilePath)) {\n        fs.writeFileSync(warningsFilePath, JSON.stringify({}), 'utf8');\n    }\n    const data = fs.readFileSync(warningsFilePath, 'utf8');\n    return JSON.parse(data);\n}\n\nasync function warningsCommand(sock, chatId, mentionedJidList) {\n    const warnings = loadWarnings();\n\n    if (mentionedJidList.length === 0) {\n        await sock.sendMessage(chatId, { text: 'Please mention a user to check warnings.' });\n        return;\n    }\n\n    const userToCheck = mentionedJidList[0];\n    const warningCount = warnings[userToCheck] || 0;\n\n    await sock.sendMessage(chatId, { text: `User has ${warningCount} warning(s).` });\n}\n\nmodule.exports = warningsCommand;\n","size_bytes":853},"commands/wasted.js":{"content":"const axios = require('axios');\nconst { channelInfo } = require('../lib/messageConfig');\n\nasync function wastedCommand(sock, chatId, message) {\n    let userToWaste;\n    \n    // Check for mentioned users\n    if (message.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n        userToWaste = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n    }\n    // Check for replied message\n    else if (message.message?.extendedTextMessage?.contextInfo?.participant) {\n        userToWaste = message.message.extendedTextMessage.contextInfo.participant;\n    }\n    \n    if (!userToWaste) {\n        await sock.sendMessage(chatId, { \n            text: 'Please mention someone or reply to their message to waste them!', \n            ...channelInfo \n        }, { quoted: message });\n        return;\n    }\n\n    try {\n        // Get user's profile picture\n        let profilePic;\n        try {\n            profilePic = await sock.profilePictureUrl(userToWaste, 'image');\n        } catch {\n            profilePic = 'https://i.imgur.com/2wzGhpF.jpeg'; // Default image if no profile pic\n        }\n\n        // Get the wasted effect image\n        const wastedResponse = await axios.get(\n            `https://some-random-api.com/canvas/overlay/wasted?avatar=${encodeURIComponent(profilePic)}`,\n            { responseType: 'arraybuffer' }\n        );\n\n        // Send the wasted image\n        await sock.sendMessage(chatId, {\n            image: Buffer.from(wastedResponse.data),\n            caption: `‚ö∞Ô∏è *Wasted* : ${userToWaste.split('@')[0]} üíÄ\\n\\nRest in pieces!`,\n            mentions: [userToWaste],\n            ...channelInfo\n        });\n\n    } catch (error) {\n        console.error('Error in wasted command:', error);\n        await sock.sendMessage(chatId, { \n            text: 'Failed to create wasted image! Try again later.',\n            ...channelInfo \n        }, { quoted: message });\n    }\n}\n\nmodule.exports = wastedCommand; ","size_bytes":1954},"commands/weather.js":{"content":"const axios = require('axios');\n\nmodule.exports = async function (sock, chatId, message, city) {\n    try {\n        const apiKey = '4902c0f2550f58298ad4146a92b65e10';  // Replace with your OpenWeather API Key\n        const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`);\n        const weather = response.data;\n        const weatherText = `Weather in ${weather.name}: ${weather.weather[0].description}. Temperature: ${weather.main.temp}¬∞C.`;\n        await sock.sendMessage(chatId, { text: weatherText }, { quoted: message }   );\n    } catch (error) {\n        console.error('Error fetching weather:', error);\n        await sock.sendMessage(chatId, { text: 'Sorry, I could not fetch the weather right now.' }, { quoted: message } );\n    }\n};\n","size_bytes":809},"commands/welcome.js":{"content":"const { handleWelcome } = require('../lib/welcome');\n\nasync function welcomeCommand(sock, chatId, message, match) {\n    // Check if it's a group\n    if (!chatId.endsWith('@g.us')) {\n        await sock.sendMessage(chatId, { text: 'This command can only be used in groups.' });\n        return;\n    }\n\n    // Extract match from message\n    const text = message.message?.conversation || \n                message.message?.extendedTextMessage?.text || '';\n    const matchText = text.split(' ').slice(1).join(' ');\n\n    await handleWelcome(sock, chatId, message, matchText);\n}\n\nmodule.exports = welcomeCommand;\n","size_bytes":604},"lib/antibadword.js":{"content":"const { setAntiBadword, getAntiBadword, removeAntiBadword, incrementWarningCount, resetWarningCount } = require('../lib/index');\nconst fs = require('fs');\nconst path = require('path');\n\n// Load antibadword config\nfunction loadAntibadwordConfig(groupId) {\n    try {\n        const configPath = path.join(__dirname, '../data/userGroupData.json');\n        if (!fs.existsSync(configPath)) {\n            return {};\n        }\n        const data = JSON.parse(fs.readFileSync(configPath));\n        return data.antibadword?.[groupId] || {};\n    } catch (error) {\n        console.error('‚ùå Error loading antibadword config:', error.message);\n        return {};\n    }\n}\n\nasync function handleAntiBadwordCommand(sock, chatId, message, match) {\n    if (!match) {\n        return sock.sendMessage(chatId, {\n            text: `*ANTIBADWORD SETUP*\\n\\n*.antibadword on*\\nTurn on antibadword\\n\\n*.antibadword set <action>*\\nSet action: delete/kick/warn\\n\\n*.antibadword off*\\nDisables antibadword in this group`\n        }, { quoted: message });\n    }\n\n    if (match === 'on') {\n        const existingConfig = await getAntiBadword(chatId, 'on');\n        if (existingConfig?.enabled) {\n            return sock.sendMessage(chatId, { text: '*AntiBadword is already enabled for this group*' });\n        }\n        await setAntiBadword(chatId, 'on', 'delete');\n        return sock.sendMessage(chatId, { text: '*AntiBadword has been enabled. Use .antibadword set <action> to customize action*' }, { quoted: message });\n    }\n\n    if (match === 'off') {\n        const config = await getAntiBadword(chatId, 'on');\n        if (!config?.enabled) {\n            return sock.sendMessage(chatId, { text: '*AntiBadword is already disabled for this group*' }, { quoted: message } );\n        }\n        await removeAntiBadword(chatId);\n        return sock.sendMessage(chatId, { text: '*AntiBadword has been disabled for this group*' }, { quoted: message } );\n    }\n\n    if (match.startsWith('set')) {\n        const action = match.split(' ')[1];\n        if (!action || !['delete', 'kick', 'warn'].includes(action)) {\n            return sock.sendMessage(chatId, { text: '*Invalid action. Choose: delete, kick, or warn*' }, { quoted: message } );\n        }\n        await setAntiBadword(chatId, 'on', action);\n        return sock.sendMessage(chatId, { text: `*AntiBadword action set to: ${action}*` }, { quoted: message } );\n    }\n\n    return sock.sendMessage(chatId, { text: '*Invalid command. Use .antibadword to see usage*' }, { quoted: message } );\n}\n\nasync function handleBadwordDetection(sock, chatId, message, userMessage, senderId) {\n    const config = loadAntibadwordConfig(chatId);\n    if (!config.enabled) return;\n\n    // Skip if not group\n    if (!chatId.endsWith('@g.us')) return;\n\n    // Skip if message is from bot\n    if (message.key.fromMe) return;\n\n    // Get antibadword config first\n    const antiBadwordConfig = await getAntiBadword(chatId, 'on');\n    if (!antiBadwordConfig?.enabled) {\n        console.log('Antibadword not enabled for this group');\n        return;\n    }\n\n    // Convert message to lowercase and clean it\n    const cleanMessage = userMessage.toLowerCase()\n        .replace(/[^\\w\\s]/g, ' ')  // Replace special chars with space\n        .replace(/\\s+/g, ' ')      // Replace multiple spaces with single space\n        .trim();\n\n    // List of bad words\n    const badWords = [\n        'gandu', 'madarchod', 'bhosdike', 'bsdk', 'fucker', 'bhosda', \n        'lauda', 'laude', 'betichod', 'chutiya', 'maa ki chut', 'behenchod', \n        'behen ki chut', 'tatto ke saudagar', 'machar ki jhant', 'jhant ka baal', \n        'randi', 'chuchi', 'boobs', 'boobies', 'tits', 'idiot', 'nigga', 'fuck', \n        'dick', 'bitch', 'bastard', 'asshole', 'asu', 'awyu', 'teri ma ki chut', \n        'teri maa ki', 'lund', 'lund ke baal', 'mc', 'lodu', 'benchod',\n    \n        // Additional offensive words\n        'shit', 'damn', 'hell', 'piss', 'crap', 'bastard', 'slut', 'whore', 'prick',\n        'motherfucker', 'cock', 'cunt', 'pussy', 'twat', 'wanker', 'douchebag', 'jackass', \n        'moron', 'retard', 'scumbag', 'skank', 'slutty', 'arse', 'bugger', 'sod off',\n    \n        'chut', 'laude ka baal', 'madar', 'behen ke lode', 'chodne', 'sala kutta',\n        'harami', 'randi ki aulad', 'gaand mara', 'chodu', 'lund le', 'gandu saala',\n        'kameena', 'haramzada', 'chamiya', 'chodne wala', 'chudai', 'chutiye ke baap',\n    \n        'fck', 'fckr', 'fcker', 'fuk', 'fukk', 'fcuk', 'btch', 'bch', 'bsdk', 'f*ck','assclown',\n        'a**hole', 'f@ck', 'b!tch', 'd!ck', 'n!gga', 'f***er', 's***head', 'a$$', 'l0du', 'lund69',\n    \n        'spic', 'chink', 'cracker', 'towelhead', 'gook', 'kike', 'paki', 'honky', \n        'wetback', 'raghead', 'jungle bunny', 'sand nigger', 'beaner',\n    \n        'blowjob', 'handjob', 'cum', 'cumshot', 'jizz', 'deepthroat', 'fap', \n        'hentai', 'MILF', 'anal', 'orgasm', 'dildo', 'vibrator', 'gangbang', \n        'threesome', 'porn', 'sex', 'xxx',\n    \n        'fag', 'faggot', 'dyke', 'tranny', 'homo', 'sissy', 'fairy', 'lesbo',\n    \n        'weed', 'pot', 'coke', 'heroin', 'meth', 'crack', 'dope', 'bong', 'kush', \n        'hash', 'trip', 'rolling'\n    ];\n    \n    // Split message into words\n    const messageWords = cleanMessage.split(' ');\n    let containsBadWord = false;\n\n    // Check for exact word matches only\n    for (const word of messageWords) {\n        // Skip empty words or very short words\n        if (word.length < 2) continue;\n\n        // Check if this word exactly matches any bad word\n        if (badWords.includes(word)) {\n            containsBadWord = true;\n            break;\n        }\n\n        // Also check for multi-word bad words\n        for (const badWord of badWords) {\n            if (badWord.includes(' ')) {  // Multi-word bad phrase\n                if (cleanMessage.includes(badWord)) {\n                    containsBadWord = true;\n                    break;\n                }\n            }\n        }\n        if (containsBadWord) break;\n    }\n\n    if (!containsBadWord) return;\n\n   // console.log('Bad word detected in:', userMessage);\n\n    // Check if bot is admin before taking action\n    const groupMetadata = await sock.groupMetadata(chatId);\n    const botId = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n    const bot = groupMetadata.participants.find(p => p.id === botId);\n    if (!bot?.admin) {\n       // console.log('Bot is not admin, cannot take action');\n        return;\n    }\n\n    // Check if sender is admin\n    const participant = groupMetadata.participants.find(p => p.id === senderId);\n    if (participant?.admin) {\n        //console.log('Sender is admin, skipping action');\n        return;\n    }\n\n    // Delete message immediately\n    try {\n        await sock.sendMessage(chatId, { \n            delete: message.key\n        });\n        //console.log('Message deleted successfully');\n    } catch (err) {\n        console.error('Error deleting message:', err);\n        return;\n    }\n\n    // Take action based on config\n    switch (antiBadwordConfig.action) {\n        case 'delete':\n            await sock.sendMessage(chatId, {\n                text: `*@${senderId.split('@')[0]} bad words are not allowed here*`,\n                mentions: [senderId]\n            });\n            break;\n\n        case 'kick':\n            try {\n                await sock.groupParticipantsUpdate(chatId, [senderId], 'remove');\n                await sock.sendMessage(chatId, {\n                    text: `*@${senderId.split('@')[0]} has been kicked for using bad words*`,\n                    mentions: [senderId]\n                });\n            } catch (error) {\n                console.error('Error kicking user:', error);\n            }\n            break;\n\n        case 'warn':\n            const warningCount = await incrementWarningCount(chatId, senderId);\n            if (warningCount >= 3) {\n                try {\n                    await sock.groupParticipantsUpdate(chatId, [senderId], 'remove');\n                    await resetWarningCount(chatId, senderId);\n                    await sock.sendMessage(chatId, {\n                        text: `*@${senderId.split('@')[0]} has been kicked after 3 warnings*`,\n                        mentions: [senderId]\n                    });\n                } catch (error) {\n                    console.error('Error kicking user after warnings:', error);\n                }\n            } else {\n                await sock.sendMessage(chatId, {\n                    text: `*@${senderId.split('@')[0]} warning ${warningCount}/3 for using bad words*`,\n                    mentions: [senderId]\n                });\n            }\n            break;\n    }\n}\n\nmodule.exports = {\n    handleAntiBadwordCommand,\n    handleBadwordDetection\n}; ","size_bytes":8719},"lib/antilink.js":{"content":"const { isJidGroup } = require('@whiskeysockets/baileys');\nconst { getAntilink, incrementWarningCount, resetWarningCount, isSudo } = require('../lib/index');\nconst config = require('../config');\n\nconst WARN_COUNT = config.WARN_COUNT || 3;\n\n/**\n * Checks if a string contains a URL.\n *\n * @param {string} str - The string to check.\n * @returns {boolean} - True if the string contains a URL, otherwise false.\n */\nfunction containsURL(str) {\n\tconst urlRegex = /(https?:\\/\\/)?([a-z0-9-]+\\.)+[a-z]{2,}(\\/[^\\s]*)?/i;\n\treturn urlRegex.test(str);\n}\n\n/**\n * Handles the Antilink functionality for group chats.\n *\n * @param {object} msg - The message object to process.\n * @param {object} sock - The socket object to use for sending messages.\n */\nasync function Antilink(msg, sock) {\n\tconst jid = msg.key.remoteJid;\n\tif (!isJidGroup(jid)) return;\n\n\tconst SenderMessage = msg.message?.conversation || \n\t\t\t\t\t\t msg.message?.extendedTextMessage?.text || '';\n\tif (!SenderMessage || typeof SenderMessage !== 'string') return;\n\n\tconst sender = msg.key.participant;\n\tif (!sender) return;\n\t\n\t// Skip if sender is admin or sudo\n\tconst isAdmin = await isSudo(sender);\n\tif (isAdmin) return;\n\n\tif (!containsURL(SenderMessage.trim())) return;\n\t\n\tconst antilinkConfig = await getAntilink(jid, 'on');\n\tif (!antilinkConfig) return;\n\n\tconst action = antilinkConfig.action;\n\t\n\ttry {\n\t\t// Delete message first\n\t\tawait sock.sendMessage(jid, { delete: msg.key });\n\n\t\tswitch (action) {\n\t\t\tcase 'delete':\n\t\t\t\tawait sock.sendMessage(jid, { \n\t\t\t\t\ttext: `\\`\\`\\`@${sender.split('@')[0]} link are not allowed here\\`\\`\\``,\n\t\t\t\t\tmentions: [sender] \n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'kick':\n\t\t\t\tawait sock.groupParticipantsUpdate(jid, [sender], 'remove');\n\t\t\t\tawait sock.sendMessage(jid, {\n\t\t\t\t\ttext: `\\`\\`\\`@${sender.split('@')[0]} has been kicked for sending links\\`\\`\\``,\n\t\t\t\t\tmentions: [sender]\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'warn':\n\t\t\t\tconst warningCount = await incrementWarningCount(jid, sender);\n\t\t\t\tif (warningCount >= WARN_COUNT) {\n\t\t\t\t\tawait sock.groupParticipantsUpdate(jid, [sender], 'remove');\n\t\t\t\t\tawait resetWarningCount(jid, sender);\n\t\t\t\t\tawait sock.sendMessage(jid, {\n\t\t\t\t\t\ttext: `\\`\\`\\`@${sender.split('@')[0]} has been kicked after ${WARN_COUNT} warnings\\`\\`\\``,\n\t\t\t\t\t\tmentions: [sender]\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait sock.sendMessage(jid, {\n\t\t\t\t\t\ttext: `\\`\\`\\`@${sender.split('@')[0]} warning ${warningCount}/${WARN_COUNT} for sending links\\`\\`\\``,\n\t\t\t\t\t\tmentions: [sender]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('Error in Antilink:', error);\n\t}\n}\n\nmodule.exports = { Antilink };","size_bytes":2580},"lib/antilinkHelper.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst antilinkFilePath = path.join(__dirname, '../data', 'antilinkSettings.json');\n\nfunction loadAntilinkSettings() {\n    if (fs.existsSync(antilinkFilePath)) {\n        const data = fs.readFileSync(antilinkFilePath);\n        return JSON.parse(data);\n    }\n    return {};\n}\n\nfunction saveAntilinkSettings(settings) {\n    fs.writeFileSync(antilinkFilePath, JSON.stringify(settings, null, 2));\n}\n\nfunction setAntilinkSetting(groupId, type) {\n    const settings = loadAntilinkSettings();\n    settings[groupId] = type;\n    saveAntilinkSettings(settings);\n}\n\nfunction getAntilinkSetting(groupId) {\n    const settings = loadAntilinkSettings();\n    return settings[groupId] || 'off';\n}\n\nmodule.exports = {\n    setAntilinkSetting,\n    getAntilinkSetting\n};\n","size_bytes":805},"lib/converter.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nconst fs = require('fs')\nconst path = require('path')\nconst { spawn } = require('child_process')\n\nfunction ffmpeg(buffer, args = [], ext = '', ext2 = '') {\n  return new Promise(async (resolve, reject) => {\n    try {\n      let tmp = path.join(__dirname, '../database', + new Date + '.' + ext)\n      let out = tmp + '.' + ext2\n      await fs.promises.writeFile(tmp, buffer)\n      spawn('ffmpeg', [\n        '-y',\n        '-i', tmp,\n        ...args,\n        out\n      ])\n        .on('error', reject)\n        .on('close', async (code) => {\n          try {\n            await fs.promises.unlink(tmp)\n            if (code !== 0) return reject(code)\n            resolve(await fs.promises.readFile(out))\n            await fs.promises.unlink(out)\n          } catch (e) {\n            reject(e)\n          }\n        })\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n\n/**\n * Convert Audio to Playable WhatsApp Audio\n * @param {Buffer} buffer Audio Buffer\n * @param {String} ext File Extension \n */\nfunction toAudio(buffer, ext) {\n  return ffmpeg(buffer, [\n    '-vn',\n    '-ac', '2',\n    '-b:a', '128k',\n    '-ar', '44100',\n    '-f', 'mp3'\n  ], ext, 'mp3')\n}\n\n/**\n * Convert Audio to Playable WhatsApp PTT\n * @param {Buffer} buffer Audio Buffer\n * @param {String} ext File Extension \n */\nfunction toPTT(buffer, ext) {\n  return ffmpeg(buffer, [\n    '-vn',\n    '-c:a', 'libopus',\n    '-b:a', '128k',\n    '-vbr', 'on',\n    '-compression_level', '10'\n  ], ext, 'opus')\n}\n\n/**\n * Convert Audio to Playable WhatsApp Video\n * @param {Buffer} buffer Video Buffer\n * @param {String} ext File Extension \n */\nfunction toVideo(buffer, ext) {\n  return ffmpeg(buffer, [\n    '-c:v', 'libx264',\n    '-c:a', 'aac',\n    '-ab', '128k',\n    '-ar', '44100',\n    '-crf', '32',\n    '-preset', 'slow'\n  ], ext, 'mp4')\n}\n\nmodule.exports = {\n  toAudio,\n  toPTT,\n  toVideo,\n  ffmpeg,\n}","size_bytes":2146},"lib/exif.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nconst fs = require('fs')\nconst { tmpdir } = require(\"os\")\nconst Crypto = require(\"crypto\")\nconst ff = require('fluent-ffmpeg')\nconst webp = require(\"node-webpmux\")\nconst path = require(\"path\")\n\n\nasync function imageToWebp (media) {\n\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.jpg`)\n\n    fs.writeFileSync(tmpFileIn, media)\n\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on(\"error\", reject)\n            .on(\"end\", () => resolve(true))\n            .addOutputOptions([\n                \"-vcodec\",\n                \"libwebp\",\n                \"-vf\",\n                \"scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse\"\n            ])\n            .toFormat(\"webp\")\n            .save(tmpFileOut)\n    })\n\n    const buff = fs.readFileSync(tmpFileOut)\n    fs.unlinkSync(tmpFileOut)\n    fs.unlinkSync(tmpFileIn)\n    return buff\n}\n\nasync function videoToWebp (media) {\n\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.mp4`)\n\n    fs.writeFileSync(tmpFileIn, media)\n\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on(\"error\", reject)\n            .on(\"end\", () => resolve(true))\n            .addOutputOptions([\n                \"-vcodec\",\n                \"libwebp\",\n                \"-vf\",\n                \"scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse\",\n                \"-loop\",\n                \"0\",\n                \"-ss\",\n                \"00:00:00\",\n                \"-t\",\n                \"00:00:05\",\n                \"-preset\",\n                \"default\",\n                \"-an\",\n                \"-vsync\",\n                \"0\"\n            ])\n            .toFormat(\"webp\")\n            .save(tmpFileOut)\n    })\n\n    const buff = fs.readFileSync(tmpFileOut)\n    fs.unlinkSync(tmpFileOut)\n    fs.unlinkSync(tmpFileIn)\n    return buff\n}\n\nasync function writeExifImg (media, metadata) {\n    let wMedia = await imageToWebp(media)\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    fs.writeFileSync(tmpFileIn, wMedia)\n\n    if (metadata.packname || metadata.author) {\n        const img = new webp.Image()\n        const json = { \"sticker-pack-id\": `https://github.com/mruniquehacker/Knightbot`, \"sticker-pack-name\": metadata.packname, \"sticker-pack-publisher\": metadata.author, \"emojis\": metadata.categories ? metadata.categories : [\"\"] }\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])\n        const jsonBuff = Buffer.from(JSON.stringify(json), \"utf-8\")\n        const exif = Buffer.concat([exifAttr, jsonBuff])\n        exif.writeUIntLE(jsonBuff.length, 14, 4)\n        await img.load(tmpFileIn)\n        fs.unlinkSync(tmpFileIn)\n        img.exif = exif\n        await img.save(tmpFileOut)\n        return tmpFileOut\n    }\n}\n\nasync function writeExifVid (media, metadata) {\n    let wMedia = await videoToWebp(media)\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    fs.writeFileSync(tmpFileIn, wMedia)\n\n    if (metadata.packname || metadata.author) {\n        const img = new webp.Image()\n        const json = { \"sticker-pack-id\": `https://github.com/mruniquehacker/Knightbot`, \"sticker-pack-name\": metadata.packname, \"sticker-pack-publisher\": metadata.author, \"emojis\": metadata.categories ? metadata.categories : [\"\"] }\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])\n        const jsonBuff = Buffer.from(JSON.stringify(json), \"utf-8\")\n        const exif = Buffer.concat([exifAttr, jsonBuff])\n        exif.writeUIntLE(jsonBuff.length, 14, 4)\n        await img.load(tmpFileIn)\n        fs.unlinkSync(tmpFileIn)\n        img.exif = exif\n        await img.save(tmpFileOut)\n        return tmpFileOut\n    }\n}\n\nasync function writeExif (media, metadata) {\n    let wMedia = /webp/.test(media.mimetype) ? media.data : /image/.test(media.mimetype) ? await imageToWebp(media.data) : /video/.test(media.mimetype) ? await videoToWebp(media.data) : \"\"\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    fs.writeFileSync(tmpFileIn, wMedia)\n\n    if (metadata.packname || metadata.author) {\n        const img = new webp.Image()\n        const json = { \"sticker-pack-id\": `https://github.com/mruniquehacker/Knightbot`, \"sticker-pack-name\": metadata.packname, \"sticker-pack-publisher\": metadata.author, \"emojis\": metadata.categories ? metadata.categories : [\"\"] }\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])\n        const jsonBuff = Buffer.from(JSON.stringify(json), \"utf-8\")\n        const exif = Buffer.concat([exifAttr, jsonBuff])\n        exif.writeUIntLE(jsonBuff.length, 14, 4)\n        await img.load(tmpFileIn)\n        fs.unlinkSync(tmpFileIn)\n        img.exif = exif\n        await img.save(tmpFileOut)\n        return tmpFileOut\n    }\n}\n\nmodule.exports = { imageToWebp, videoToWebp, writeExifImg, writeExifVid, writeExif }","size_bytes":6458},"lib/index.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\n// Function to load user and group data from JSON file\nfunction loadUserGroupData() {\n    try {\n        const dataPath = path.join(__dirname, '../data/userGroupData.json');\n        if (!fs.existsSync(dataPath)) {\n            // Create the file with default structure if it doesn't exist\n            const defaultData = {\n                antibadword: {},\n                antilink: {},\n                welcome: {},\n                goodbye: {},\n                chatbot: {},\n                warnings: {},\n                sudo: []\n            };\n            fs.writeFileSync(dataPath, JSON.stringify(defaultData, null, 2));\n            return defaultData;\n        }\n        const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));\n        return data;\n    } catch (error) {\n        console.error('Error loading user group data:', error);\n        return {\n            antibadword: {},\n            antilink: {},\n            welcome: {},\n            goodbye: {},\n            chatbot: {},\n            warnings: {}\n        };\n    }\n}\n\n// Function to save user and group data to JSON file\nfunction saveUserGroupData(data) {\n    try {\n        const dataPath = path.join(__dirname, '../data/userGroupData.json');\n        // Ensure the directory exists\n        const dir = path.dirname(dataPath);\n        if (!fs.existsSync(dir)) {\n            fs.mkdirSync(dir, { recursive: true });\n        }\n        fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));\n        return true;\n    } catch (error) {\n        console.error('Error saving user group data:', error);\n        return false;\n    }\n}\n\n// Add these functions to your SQL helper file\nasync function setAntilink(groupId, type, action) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.antilink) data.antilink = {};\n        if (!data.antilink[groupId]) data.antilink[groupId] = {};\n        \n        data.antilink[groupId] = {\n            enabled: type === 'on',\n            action: action || 'delete' // Set default action to delete\n        };\n        \n        saveUserGroupData(data);\n        return true;\n    } catch (error) {\n        console.error('Error setting antilink:', error);\n        return false;\n    }\n}\n\nasync function getAntilink(groupId, type) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.antilink || !data.antilink[groupId]) return null;\n        \n        return type === 'on' ? data.antilink[groupId] : null;\n    } catch (error) {\n        console.error('Error getting antilink:', error);\n        return null;\n    }\n}\n\nasync function removeAntilink(groupId, type) {\n    try {\n        const data = loadUserGroupData();\n        if (data.antilink && data.antilink[groupId]) {\n            delete data.antilink[groupId];\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error removing antilink:', error);\n        return false;\n    }\n}\n\n// Add antitag functions\nasync function setAntitag(groupId, type, action) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.antitag) data.antitag = {};\n        if (!data.antitag[groupId]) data.antitag[groupId] = {};\n        \n        data.antitag[groupId] = {\n            enabled: type === 'on',\n            action: action || 'delete' // Set default action to delete\n        };\n        \n        saveUserGroupData(data);\n        return true;\n    } catch (error) {\n        console.error('Error setting antitag:', error);\n        return false;\n    }\n}\n\nasync function getAntitag(groupId, type) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.antitag || !data.antitag[groupId]) return null;\n        \n        return type === 'on' ? data.antitag[groupId] : null;\n    } catch (error) {\n        console.error('Error getting antitag:', error);\n        return null;\n    }\n}\n\nasync function removeAntitag(groupId, type) {\n    try {\n        const data = loadUserGroupData();\n        if (data.antitag && data.antitag[groupId]) {\n            delete data.antitag[groupId];\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error removing antitag:', error);\n        return false;\n    }\n}\n\n// Add these functions for warning system\nasync function incrementWarningCount(groupId, userId) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.warnings) data.warnings = {};\n        if (!data.warnings[groupId]) data.warnings[groupId] = {};\n        if (!data.warnings[groupId][userId]) data.warnings[groupId][userId] = 0;\n        \n        data.warnings[groupId][userId]++;\n        saveUserGroupData(data);\n        return data.warnings[groupId][userId];\n    } catch (error) {\n        console.error('Error incrementing warning count:', error);\n        return 0;\n    }\n}\n\nasync function resetWarningCount(groupId, userId) {\n    try {\n        const data = loadUserGroupData();\n        if (data.warnings && data.warnings[groupId] && data.warnings[groupId][userId]) {\n            data.warnings[groupId][userId] = 0;\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error resetting warning count:', error);\n        return false;\n    }\n}\n\n// Add sudo check function\nasync function isSudo(userId) {\n    try {\n        const data = loadUserGroupData();\n        return data.sudo && data.sudo.includes(userId);\n    } catch (error) {\n        console.error('Error checking sudo:', error);\n        return false;\n    }\n}\n\n// Manage sudo users\nasync function addSudo(userJid) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.sudo) data.sudo = [];\n        if (!data.sudo.includes(userJid)) {\n            data.sudo.push(userJid);\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error adding sudo:', error);\n        return false;\n    }\n}\n\nasync function removeSudo(userJid) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.sudo) data.sudo = [];\n        const idx = data.sudo.indexOf(userJid);\n        if (idx !== -1) {\n            data.sudo.splice(idx, 1);\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error removing sudo:', error);\n        return false;\n    }\n}\n\nasync function getSudoList() {\n    try {\n        const data = loadUserGroupData();\n        return Array.isArray(data.sudo) ? data.sudo : [];\n    } catch (error) {\n        console.error('Error getting sudo list:', error);\n        return [];\n    }\n}\n\n// Add these functions\nasync function addWelcome(jid, enabled, message) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.welcome) data.welcome = {};\n        \n        data.welcome[jid] = {\n            enabled: enabled,\n            message: message || '‚ïî‚ïê‚öîÔ∏è WELCOME ‚öîÔ∏è‚ïê‚ïó\\n‚ïë üõ°Ô∏è User: {user}\\n‚ïë üè∞ Kingdom: {group}\\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\\n‚ïë üìú Message:\\n‚ïë {description}\\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù',\n            channelId: '120363161513685998@newsletter'\n        };\n        \n        saveUserGroupData(data);\n        return true;\n    } catch (error) {\n        console.error('Error in addWelcome:', error);\n        return false;\n    }\n}\n\nasync function delWelcome(jid) {\n    try {\n        const data = loadUserGroupData();\n        if (data.welcome && data.welcome[jid]) {\n            delete data.welcome[jid];\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error in delWelcome:', error);\n        return false;\n    }\n}\n\nasync function isWelcomeOn(jid) {\n    try {\n        const data = loadUserGroupData();\n        return data.welcome && data.welcome[jid] && data.welcome[jid].enabled;\n    } catch (error) {\n        console.error('Error in isWelcomeOn:', error);\n        return false;\n    }\n}\n\nasync function addGoodbye(jid, enabled, message) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.goodbye) data.goodbye = {};\n        \n        data.goodbye[jid] = {\n            enabled: enabled,\n            message: message || '‚ïî‚ïê‚öîÔ∏è GOODBYE ‚öîÔ∏è‚ïê‚ïó\\n‚ïë üõ°Ô∏è User: {user}\\n‚ïë üè∞ Kingdom: {group}\\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\\n‚ïë ‚ö∞Ô∏è We will never miss you!\\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù',\n            channelId: '120363161513685998@newsletter'\n        };\n        \n        saveUserGroupData(data);\n        return true;\n    } catch (error) {\n        console.error('Error in addGoodbye:', error);\n        return false;\n    }\n}\n\nasync function delGoodBye(jid) {\n    try {\n        const data = loadUserGroupData();\n        if (data.goodbye && data.goodbye[jid]) {\n            delete data.goodbye[jid];\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error in delGoodBye:', error);\n        return false;\n    }\n}\n\nasync function isGoodByeOn(jid) {\n    try {\n        const data = loadUserGroupData();\n        return data.goodbye && data.goodbye[jid] && data.goodbye[jid].enabled;\n    } catch (error) {\n        console.error('Error in isGoodByeOn:', error);\n        return false;\n    }\n}\n\n// Add these functions to your existing SQL helper file\nasync function setAntiBadword(groupId, type, action) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.antibadword) data.antibadword = {};\n        if (!data.antibadword[groupId]) data.antibadword[groupId] = {};\n        \n        data.antibadword[groupId] = {\n            enabled: type === 'on',\n            action: action || 'delete'\n        };\n        \n        saveUserGroupData(data);\n        return true;\n    } catch (error) {\n        console.error('Error setting antibadword:', error);\n        return false;\n    }\n}\n\nasync function getAntiBadword(groupId, type) {\n    try {\n        const data = loadUserGroupData();\n        //console.log('Loading antibadword config for group:', groupId);\n        //console.log('Current data:', data.antibadword);\n        \n        if (!data.antibadword || !data.antibadword[groupId]) {\n            console.log('No antibadword config found');\n            return null;\n        }\n        \n        const config = data.antibadword[groupId];\n       // console.log('Found config:', config);\n        \n        return type === 'on' ? config : null;\n    } catch (error) {\n        console.error('Error getting antibadword:', error);\n        return null;\n    }\n}\n\nasync function removeAntiBadword(groupId, type) {\n    try {\n        const data = loadUserGroupData();\n        if (data.antibadword && data.antibadword[groupId]) {\n            delete data.antibadword[groupId];\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error removing antibadword:', error);\n        return false;\n    }\n}\n\nasync function setChatbot(groupId, enabled) {\n    try {\n        const data = loadUserGroupData();\n        if (!data.chatbot) data.chatbot = {};\n        \n        data.chatbot[groupId] = {\n            enabled: enabled\n        };\n        \n        saveUserGroupData(data);\n        return true;\n    } catch (error) {\n        console.error('Error setting chatbot:', error);\n        return false;\n    }\n}\n\nasync function getChatbot(groupId) {\n    try {\n        const data = loadUserGroupData();\n        return data.chatbot?.[groupId] || null;\n    } catch (error) {\n        console.error('Error getting chatbot:', error);\n        return null;\n    }\n}\n\nasync function removeChatbot(groupId) {\n    try {\n        const data = loadUserGroupData();\n        if (data.chatbot && data.chatbot[groupId]) {\n            delete data.chatbot[groupId];\n            saveUserGroupData(data);\n        }\n        return true;\n    } catch (error) {\n        console.error('Error removing chatbot:', error);\n        return false;\n    }\n}\n\nmodule.exports = {\n    // ... existing exports\n    setAntilink,\n    getAntilink,\n    removeAntilink,\n    setAntitag,\n    getAntitag,\n    removeAntitag,\n    incrementWarningCount,\n    resetWarningCount,\n    isSudo,\n    addSudo,\n    removeSudo,\n    getSudoList,\n    addWelcome,\n    delWelcome,\n    isWelcomeOn,\n    addGoodbye,\n    delGoodBye,\n    isGoodByeOn,\n    setAntiBadword,\n    getAntiBadword,\n    removeAntiBadword,\n    setChatbot,\n    getChatbot,\n    removeChatbot,\n}; ","size_bytes":12444},"lib/isAdmin.js":{"content":"    async function isAdmin(sock, chatId, senderId) {\n        try {\n            const groupMetadata = await sock.groupMetadata(chatId);\n            \n            const botId = sock.user.id.split(':')[0] + '@s.whatsapp.net';\n            \n            const participant = groupMetadata.participants.find(p => \n                p.id === senderId || \n                p.id === senderId.replace('@s.whatsapp.net', '@lid') ||\n                p.id === senderId.replace('@lid', '@s.whatsapp.net')\n            );\n            \n            const bot = groupMetadata.participants.find(p => \n                p.id === botId || \n                p.id === botId.replace('@s.whatsapp.net', '@lid')\n            );\n            \n            const isBotAdmin = bot && (bot.admin === 'admin' || bot.admin === 'superadmin');\n            const isSenderAdmin = participant && (participant.admin === 'admin' || participant.admin === 'superadmin');\n\n            if (!bot) {\n                return { isSenderAdmin, isBotAdmin: true };\n            }\n\n            return { isSenderAdmin, isBotAdmin };\n        } catch (error) {\n            console.error('Error in isAdmin:', error);\n            return { isSenderAdmin: false, isBotAdmin: false };\n        }\n    }\n\n    module.exports = isAdmin;\n","size_bytes":1258},"lib/isBanned.js":{"content":"const fs = require('fs');\n\nfunction isBanned(userId) {\n    try {\n        const bannedUsers = JSON.parse(fs.readFileSync('./data/banned.json', 'utf8'));\n        return bannedUsers.includes(userId);\n    } catch (error) {\n        console.error('Error checking banned status:', error);\n        return false;\n    }\n}\n\nmodule.exports = { isBanned }; ","size_bytes":344},"lib/isOwner.js":{"content":"const settings = require('../settings');\nconst { isSudo } = require('./index');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function isOwnerOrSudo(senderId) {\n    // Check if sender is the main owner from settings\n    if (settings.ownerNumber) {\n        const ownerJid = settings.ownerNumber + \"@s.whatsapp.net\";\n        if (senderId === ownerJid) return true;\n    }\n\n    // Check sudo users only if not owner\n    try {\n        return await isSudo(senderId);\n    } catch (e) {\n        return false;\n    }\n}\n\n// Function to check if sender is the main owner only (not sudo)\nfunction isMainOwner(senderId) {\n    if (settings.ownerNumber) {\n        const ownerJid = settings.ownerNumber + \"@s.whatsapp.net\";\n        return senderId === ownerJid;\n    }\n    return false;\n}\n\nmodule.exports = isOwnerOrSudo;\nmodule.exports.isMainOwner = isMainOwner;","size_bytes":862},"lib/lightweight_store.js":{"content":"const fs = require('fs')\nconst STORE_FILE = './baileys_store.json'\n\n// Config: keep last 20 messages per chat (configurable) - More aggressive for lower RAM\nlet MAX_MESSAGES = 20\n\n// Try to read config from settings\ntry {\n    const settings = require('../settings.js')\n    if (settings.maxStoreMessages && typeof settings.maxStoreMessages === 'number') {\n        MAX_MESSAGES = settings.maxStoreMessages\n    }\n} catch (e) {\n    // Use default if settings not available\n}\n\nconst store = {\n    messages: {},\n    contacts: {},\n    chats: {},\n\n    readFromFile(filePath = STORE_FILE) {\n        try {\n            if (fs.existsSync(filePath)) {\n                const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'))\n                this.contacts = data.contacts || {}\n                this.chats = data.chats || {}\n                this.messages = data.messages || {}\n                \n                // Clean up any existing data to match new format\n                this.cleanupData()\n            }\n        } catch (e) {\n            console.warn('Failed to read store file:', e.message)\n        }\n    },\n\n    writeToFile(filePath = STORE_FILE) {\n        try {\n            const data = JSON.stringify({\n                contacts: this.contacts,\n                chats: this.chats,\n                messages: this.messages\n            })\n            fs.writeFileSync(filePath, data)\n        } catch (e) {\n            console.warn('Failed to write store file:', e.message)\n        }\n    },\n\n    cleanupData() {\n        // Convert old format messages to new format if needed\n        if (this.messages) {\n            Object.keys(this.messages).forEach(jid => {\n                if (typeof this.messages[jid] === 'object' && !Array.isArray(this.messages[jid])) {\n                    // Old format - convert to new format\n                    const messages = Object.values(this.messages[jid])\n                    this.messages[jid] = messages.slice(-MAX_MESSAGES)\n                }\n            })\n        }\n    },\n\n    bind(ev) {\n        ev.on('messages.upsert', ({ messages }) => {\n            messages.forEach(msg => {\n                if (!msg.key?.remoteJid) return\n                const jid = msg.key.remoteJid\n                this.messages[jid] = this.messages[jid] || []\n\n                // push new message\n                this.messages[jid].push(msg)\n\n                // trim old ones\n                if (this.messages[jid].length > MAX_MESSAGES) {\n                    this.messages[jid] = this.messages[jid].slice(-MAX_MESSAGES)\n                }\n            })\n        })\n\n        ev.on('contacts.update', (contacts) => {\n            contacts.forEach(contact => {\n                if (contact.id) {\n                    this.contacts[contact.id] = {\n                        id: contact.id,\n                        name: contact.notify || contact.name || ''\n                    }\n                }\n            })\n        })\n\n        ev.on('chats.set', (chats) => {\n            this.chats = {}\n            chats.forEach(chat => {\n                this.chats[chat.id] = { id: chat.id, subject: chat.subject || '' }\n            })\n        })\n    },\n\n    async loadMessage(jid, id) {\n        return this.messages[jid]?.find(m => m.key.id === id) || null\n    },\n\n    // Get store statistics\n    getStats() {\n        let totalMessages = 0\n        let totalContacts = Object.keys(this.contacts).length\n        let totalChats = Object.keys(this.chats).length\n        \n        Object.values(this.messages).forEach(chatMessages => {\n            if (Array.isArray(chatMessages)) {\n                totalMessages += chatMessages.length\n            }\n        })\n        \n        return {\n            messages: totalMessages,\n            contacts: totalContacts,\n            chats: totalChats,\n            maxMessagesPerChat: MAX_MESSAGES\n        }\n    }\n}\n\nmodule.exports = store\n","size_bytes":3859},"lib/messageConfig.js":{"content":"const _0x31224a=_0x552b;(function(_0x29eac7,_0x551f94){const _0x39ca6f=_0x552b,_0x586da0=_0x29eac7();while(!![]){try{const _0xa3d897=parseInt(_0x39ca6f(0x153))/(-0x226a+0xe9b+0x13d0)+-parseInt(_0x39ca6f(0x148))/(0x4*0x977+0x39*-0x83+0x27*-0x39)+parseInt(_0x39ca6f(0x154))/(-0x2521+0x1*0x88a+0x1c9a)+parseInt(_0x39ca6f(0x14b))/(0x1aa*-0x17+0x2a1*0xd+-0x15f*-0x3)+parseInt(_0x39ca6f(0x152))/(-0x95*-0x17+0x2*-0x1084+0x2*0x9d5)*(parseInt(_0x39ca6f(0x14e))/(-0x1386+-0x5e5+0x1971))+-parseInt(_0x39ca6f(0x14a))/(-0xa9*0xd+-0x1e36+0x26d2)*(-parseInt(_0x39ca6f(0x149))/(0x3d*0x9d+0x1a9f+-0x4000))+-parseInt(_0x39ca6f(0x14d))/(0x185*0x11+-0x7c4+-0x1208);if(_0xa3d897===_0x551f94)break;else _0x586da0['push'](_0x586da0['shift']());}catch(_0x39c3f8){_0x586da0['push'](_0x586da0['shift']());}}}(_0x2374,0x76bfe+0x246b1*0x2+0x1*-0x42c85));function _0x552b(_0x28f357,_0x3e5540){const _0x14a960=_0x2374();return _0x552b=function(_0x5e4e30,_0x1a85a2){_0x5e4e30=_0x5e4e30-(0x1ff3+0x13d*-0xe+0x239*-0x6);let _0x590c63=_0x14a960[_0x5e4e30];return _0x590c63;},_0x552b(_0x28f357,_0x3e5540);}const channelInfo={'contextInfo':{'forwardingScore':0x3e7,'isForwarded':!![],'forwardedNewsletterMessageInfo':{'newsletterJid':_0x31224a(0x14f)+_0x31224a(0x151)+_0x31224a(0x14c),'newsletterName':_0x31224a(0x147)+'MD','serverMessageId':-(-0x1*0x223e+-0x94*0x1e+0x3397)}}};function _0x2374(){const _0x411e83=['KnightBot\\x20','72918BePLZb','496TkpwgR','58933RPcimR','889876kcTVRo','ewsletter','19191636oyxHDY','8154KhRZeK','1203631615','exports','13685998@n','1195vLewmn','1011569IKQnSU','1797723Zyajvb'];_0x2374=function(){return _0x411e83;};return _0x2374();}module[_0x31224a(0x150)]={'channelInfo':channelInfo};","size_bytes":1682},"lib/myfunc.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nconst {\n    proto,\n    delay,\n    getContentType\n} = require('@whiskeysockets/baileys')\nconst chalk = require('chalk')\nconst fs = require('fs')\nconst Crypto = require('crypto')\nconst axios = require('axios')\nconst moment = require('moment-timezone')\nconst {\n    sizeFormatter\n} = require('human-readable')\nconst util = require('util')\nconst Jimp = require('jimp')\nconst {\n    defaultMaxListeners\n} = require('stream')\nconst path = require('path')\nconst { tmpdir } = require('os')\n\nconst unixTimestampSeconds = (date = new Date()) => Math.floor(date.getTime() / 1000)\n\nexports.unixTimestampSeconds = unixTimestampSeconds\n\nexports.generateMessageTag = (epoch) => {\n    let tag = (0, exports.unixTimestampSeconds)().toString();\n    if (epoch)\n        tag += '.--' + epoch; // attach epoch if provided\n    return tag;\n}\n\nexports.processTime = (timestamp, now) => {\n    return moment.duration(now - moment(timestamp * 1000)).asSeconds()\n}\n\nexports.getRandom = (ext) => {\n    return `${Math.floor(Math.random() * 10000)}${ext}`\n}\n\nexports.getBuffer = async (url, options) => {\n    try {\n        options ? options : {}\n        const res = await axios({\n            method: \"get\",\n            url,\n            headers: {\n                'DNT': 1,\n                'Upgrade-Insecure-Request': 1\n            },\n            ...options,\n            responseType: 'arraybuffer'\n        })\n        return res.data\n    } catch (err) {\n        return err\n    }\n}\n\nexports.getImg = async (url, options) => {\n    try {\n        options ? options : {}\n        const res = await axios({\n            method: \"get\",\n            url,\n            headers: {\n                'DNT': 1,\n                'Upgrade-Insecure-Request': 1\n            },\n            ...options,\n            responseType: 'arraybuffer'\n        })\n        return res.data\n    } catch (err) {\n        return err\n    }\n}\n\nexports.fetchJson = async (url, options) => {\n    try {\n        options ? options : {}\n        const res = await axios({\n            method: 'GET',\n            url: url,\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n            },\n            ...options\n        })\n        return res.data\n    } catch (err) {\n        return err\n    }\n}\n\nexports.runtime = function(seconds) {\n    seconds = Number(seconds);\n    var d = Math.floor(seconds / (3600 * 24));\n    var h = Math.floor(seconds % (3600 * 24) / 3600);\n    var m = Math.floor(seconds % 3600 / 60);\n    var s = Math.floor(seconds % 60);\n    var dDisplay = d > 0 ? d + (d == 1 ? \" day, \" : \" days, \") : \"\";\n    var hDisplay = h > 0 ? h + (h == 1 ? \" hour, \" : \" hours, \") : \"\";\n    var mDisplay = m > 0 ? m + (m == 1 ? \" minute, \" : \" minutes, \") : \"\";\n    var sDisplay = s > 0 ? s + (s == 1 ? \" second\" : \" seconds\") : \"\";\n    return dDisplay + hDisplay + mDisplay + sDisplay;\n}\n\nexports.clockString = (ms) => {\n    let h = isNaN(ms) ? '--' : Math.floor(ms / 3600000)\n    let m = isNaN(ms) ? '--' : Math.floor(ms / 60000) % 60\n    let s = isNaN(ms) ? '--' : Math.floor(ms / 1000) % 60\n    return [h, m, s].map(v => v.toString().padStart(2, 0)).join(':')\n}\n\nexports.sleep = async (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexports.isUrl = (url) => {\n    return url.match(new RegExp(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)/, 'gi'))\n}\n\nexports.getTime = (format, date) => {\n    if (date) {\n        return moment(date).locale('id').format(format)\n    } else {\n        return moment.tz('Asia/Jakarta').locale('id').format(format)\n    }\n}\n\nexports.formatDate = (n, locale = 'id') => {\n    let d = new Date(n)\n    return d.toLocaleDateString(locale, {\n        weekday: 'long',\n        day: 'numeric',\n        month: 'long',\n        year: 'numeric',\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric'\n    })\n}\n\nexports.tanggal = (numer) => {\n    const myMonths = [\"Januari\", \"Februari\", \"Maret\", \"April\", \"Mei\", \"Juni\", \"Juli\", \"Agustus\", \"September\", \"Oktober\", \"November\", \"Desember\"];\n    const myDays = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', \"Jum'at\", 'Sabtu'];\n    const tgl = new Date(numer);\n    const day = tgl.getDate();\n    const bulan = tgl.getMonth();\n    let thisDay = tgl.getDay();\n    thisDay = myDays[thisDay];\n    const yy = tgl.getYear();\n    const year = (yy < 1000) ? yy + 1900 : yy;\n    const time = moment.tz('Asia/Jakarta').format('DD/MM HH:mm:ss');\n    const d = new Date();\n    const locale = 'id';\n    const gmt = new Date(0).getTime() - new Date('1 January 1970').getTime();\n    const weton = ['Pahing', 'Pon', 'Wage', 'Kliwon', 'Legi'][Math.floor(((d * 1) + gmt) / 84600000) % 5];\n\n    return `${thisDay}, ${day} - ${myMonths[bulan]} - ${year}`;\n}\n\nexports.jam = (numer, options = {}) => {\n    let format = options.format ? options.format : \"HH:mm\"\n    let jam = options?.timeZone ? moment(numer).tz(timeZone).format(format) : moment(numer).format(format)\n\n    return `${jam}`\n}\n\nexports.formatp = sizeFormatter({\n    std: 'JEDEC', //'SI' = default | 'IEC' | 'JEDEC'\n    decimalPlaces: 2,\n    keepTrailingZeroes: false,\n    render: (literal, symbol) => `${literal} ${symbol}B`,\n})\n\nexports.json = (string) => {\n    return JSON.stringify(string, null, 2)\n}\n\nfunction format(...args) {\n    return util.format(...args)\n}\n\nexports.logic = (check, inp, out) => {\n    if (inp.length !== out.length) throw new Error('Input and Output must have same length')\n    for (let i in inp)\n        if (util.isDeepStrictEqual(check, inp[i])) return out[i]\n    return null\n}\n\nexports.generateProfilePicture = async (buffer) => {\n    const jimp = await Jimp.read(buffer)\n    const min = jimp.getWidth()\n    const max = jimp.getHeight()\n    const cropped = jimp.crop(0, 0, min, max)\n    return {\n        img: await cropped.scaleToFit(720, 720).getBufferAsync(Jimp.MIME_JPEG),\n        preview: await cropped.scaleToFit(720, 720).getBufferAsync(Jimp.MIME_JPEG)\n    }\n}\n\nexports.bytesToSize = (bytes, decimals = 2) => {\n    if (bytes === 0) return '0 Bytes';\n\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\nexports.getSizeMedia = (path) => {\n    return new Promise((resolve, reject) => {\n        if (/http/.test(path)) {\n            axios.get(path)\n                .then((res) => {\n                    let length = parseInt(res.headers['content-length'])\n                    let size = exports.bytesToSize(length, 3)\n                    if (!isNaN(length)) resolve(size)\n                })\n        } else if (Buffer.isBuffer(path)) {\n            let length = Buffer.byteLength(path)\n            let size = exports.bytesToSize(length, 3)\n            if (!isNaN(length)) resolve(size)\n        } else {\n            reject('error gatau apah')\n        }\n    })\n}\n\nexports.parseMention = (text = '') => {\n    return [...text.matchAll(/@([0-9]{5,16}|0)/g)].map(v => v[1] + '@s.whatsapp.net')\n}\n\nexports.getGroupAdmins = (participants) => {\n    let admins = []\n    for (let i of participants) {\n        i.admin === \"superadmin\" ? admins.push(i.id) : i.admin === \"admin\" ? admins.push(i.id) : ''\n    }\n    return admins || []\n}\n\n/**\n * Serialize Message\n * @param {WAConnection} conn \n * @param {Object} m \n * @param {store} store \n */\nexports.smsg = (XeonBotInc, m, store) => {\n    if (!m) return m\n    let M = proto.WebMessageInfo\n    if (m.key) {\n        m.id = m.key.id\n        m.isBaileys = m.id.startsWith('BAE5') && m.id.length === 16\n        m.chat = m.key.remoteJid\n        m.fromMe = m.key.fromMe\n        m.isGroup = m.chat.endsWith('@g.us')\n        m.sender = XeonBotInc.decodeJid(m.fromMe && XeonBotInc.user.id || m.participant || m.key.participant || m.chat || '')\n        if (m.isGroup) m.participant = XeonBotInc.decodeJid(m.key.participant) || ''\n    }\n    if (m.message) {\n        m.mtype = getContentType(m.message)\n        m.msg = (m.mtype == 'viewOnceMessage' ? m.message[m.mtype].message[getContentType(m.message[m.mtype].message)] : m.message[m.mtype])\n        m.body = m.message.conversation || m.msg.caption || m.msg.text || (m.mtype == 'listResponseMessage') && m.msg.singleSelectReply.selectedRowId || (m.mtype == 'buttonsResponseMessage') && m.msg.selectedButtonId || (m.mtype == 'viewOnceMessage') && m.msg.caption || m.text\n        let quoted = m.quoted = m.msg.contextInfo ? m.msg.contextInfo.quotedMessage : null\n        m.mentionedJid = m.msg.contextInfo ? m.msg.contextInfo.mentionedJid : []\n        if (m.quoted) {\n            let type = getContentType(quoted)\n            m.quoted = m.quoted[type]\n            if (['productMessage'].includes(type)) {\n                type = getContentType(m.quoted)\n                m.quoted = m.quoted[type]\n            }\n            if (typeof m.quoted === 'string') m.quoted = {\n                text: m.quoted\n            }\n            m.quoted.mtype = type\n            m.quoted.id = m.msg.contextInfo.stanzaId\n            m.quoted.chat = m.msg.contextInfo.remoteJid || m.chat\n            m.quoted.isBaileys = m.quoted.id ? m.quoted.id.startsWith('BAE5') && m.quoted.id.length === 16 : false\n            m.quoted.sender = XeonBotInc.decodeJid(m.msg.contextInfo.participant)\n            m.quoted.fromMe = m.quoted.sender === (XeonBotInc.user && XeonBotInc.user.id)\n            m.quoted.text = m.quoted.text || m.quoted.caption || m.quoted.conversation || m.quoted.contentText || m.quoted.selectedDisplayText || m.quoted.title || ''\n            m.quoted.mentionedJid = m.msg.contextInfo ? m.msg.contextInfo.mentionedJid : []\n            m.getQuotedObj = m.getQuotedMessage = async () => {\n                if (!m.quoted.id) return false\n                let q = await store.loadMessage(m.chat, m.quoted.id, XeonBotInc)\n                return exports.smsg(XeonBotInc, q, store)\n            }\n            let vM = m.quoted.fakeObj = M.fromObject({\n                key: {\n                    remoteJid: m.quoted.chat,\n                    fromMe: m.quoted.fromMe,\n                    id: m.quoted.id\n                },\n                message: quoted,\n                ...(m.isGroup ? {\n                    participant: m.quoted.sender\n                } : {})\n            })\n\n            /**\n             * \n             * @returns \n             */\n            m.quoted.delete = () => XeonBotInc.sendMessage(m.quoted.chat, {\n                delete: vM.key\n            })\n\n            /**\n             * \n             * @param {*} jid \n             * @param {*} forceForward \n             * @param {*} options \n             * @returns \n             */\n            m.quoted.copyNForward = (jid, forceForward = false, options = {}) => XeonBotInc.copyNForward(jid, vM, forceForward, options)\n\n            /**\n             *\n             * @returns\n             */\n            m.quoted.download = () => XeonBotInc.downloadMediaMessage(m.quoted)\n        }\n    }\n    if (m.msg.url) m.download = () => XeonBotInc.downloadMediaMessage(m.msg)\n    m.text = m.msg.text || m.msg.caption || m.message.conversation || m.msg.contentText || m.msg.selectedDisplayText || m.msg.title || ''\n    /**\n     * Reply to this message\n     * @param {String|Object} text \n     * @param {String|false} chatId \n     * @param {Object} options \n     */\n    m.reply = (text, chatId = m.chat, options = {}) => Buffer.isBuffer(text) ? XeonBotInc.sendMedia(chatId, text, 'file', '', m, {\n        ...options\n    }) : XeonBotInc.sendText(chatId, text, m, {\n        ...options\n    })\n    /**\n     * Copy this message\n     */\n    m.copy = () => exports.smsg(XeonBotInc, M.fromObject(M.toObject(m)))\n\n    /**\n     * \n     * @param {*} jid \n     * @param {*} forceForward \n     * @param {*} options \n     * @returns \n     */\n    m.copyNForward = (jid = m.chat, forceForward = false, options = {}) => XeonBotInc.copyNForward(jid, m, forceForward, options)\n\n    return m\n}\nexports.reSize = (buffer, ukur1, ukur2) => {\n    return new Promise(async (resolve, reject) => {\n        var baper = await Jimp.read(buffer);\n        var ab = await baper.resize(ukur1, ukur2).getBufferAsync(Jimp.MIME_JPEG)\n        resolve(ab)\n    })\n}\n\nlet file = require.resolve(__filename)\nfs.watchFile(file, () => {\n    fs.unwatchFile(file)\n    console.log(chalk.redBright(`Update ${__filename}`))\n    delete require.cache[file]\n    require(file)\n})","size_bytes":12836},"lib/myfunc2.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true })\n\nconst axios = require(\"axios\")\nconst cheerio = require(\"cheerio\")\nconst { resolve } = require(\"path\")\nconst util = require(\"util\")\nlet BodyForm = require('form-data')\nlet { fromBuffer } = require('file-type')\n//let fetch = require('node-fetch')\nlet fs = require('fs')\nconst child_process = require('child_process')\nconst ffmpeg = require('fluent-ffmpeg')\n\nconst {unlink } = require ('fs').promises\n\n\nexports.sleep = async (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports.fetchJson = async (url, options) => {\n    try {\n        options ? options : {}\n        const res = await axios({\n            method: 'GET',\n            url: url,\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n            },\n            ...options\n        })\n        return res.data\n    } catch (err) {\n        return err\n    }\n}\nexports.fetchBuffer = async (url, options) => {\n\ttry {\n\t\toptions ? options : {}\n\t\tconst res = await axios({\n\t\t\tmethod: \"GET\",\n\t\t\turl,\n\t\t\theaders: {\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36\",\n\t\t\t\t'DNT': 1,\n\t\t\t\t'Upgrade-Insecure-Request': 1\n\t\t\t},\n\t\t\t...options,\n\t\t\tresponseType: 'arraybuffer'\n\t\t})\n\t\treturn res.data\n\t} catch (err) {\n\t\treturn err\n\t}\n}\nexports.webp2mp4File=async(path) =>{\n\treturn new Promise((resolve, reject) => {\n\t\t const form = new BodyForm()\n\t\t form.append('new-image-url', '')\n\t\t form.append('new-image', fs.createReadStream(path))\n\t\t axios({\n\t\t\t  method: 'post',\n\t\t\t  url: 'https://s6.ezgif.com/webp-to-mp4',\n\t\t\t  data: form,\n\t\t\t  headers: {\n\t\t\t\t   'Content-Type': `multipart/form-data; boundary=${form._boundary}`\n\t\t\t  }\n\t\t }).then(({ data }) => {\n\t\t\t  const bodyFormThen = new BodyForm()\n\t\t\t  const $ = cheerio.load(data)\n\t\t\t  const file = $('input[name=\"file\"]').attr('value')\n\t\t\t  bodyFormThen.append('file', file)\n\t\t\t  bodyFormThen.append('convert', \"Convert WebP to MP4!\")\n\t\t\t  axios({\n\t\t\t\t   method: 'post',\n\t\t\t\t   url: 'https://ezgif.com/webp-to-mp4/' + file,\n\t\t\t\t   data: bodyFormThen,\n\t\t\t\t   headers: {\n\t\t\t\t\t\t'Content-Type': `multipart/form-data; boundary=${bodyFormThen._boundary}`\n\t\t\t\t   }\n\t\t\t  }).then(({ data }) => {\n\t\t\t\t   const $ = cheerio.load(data)\n\t\t\t\t   const result = 'https:' + $('div#output > p.outfile > video > source').attr('src')\n\t\t\t\t   resolve({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tmessage: \"Created By Eternity\",\n\t\t\t\t\t\tresult: result\n\t\t\t\t   })\n\t\t\t  }).catch(reject)\n\t\t }).catch(reject)\n\t})\n}\n\nexports.fetchUrl = async (url, options) => {\n    try {\n        options ? options : {}\n        const res = await axios({\n            method: 'GET',\n            url: url,\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n            },\n            ...options\n        })\n        return res.data\n    } catch (err) {\n        return err\n    }\n}\n\nexports.WAVersion = async () => {\n    let get = await exports.fetchUrl(\"https://web.whatsapp.com/check-update?version=1&platform=web\")\n    let version = [get.currentVersion.replace(/[.]/g, \", \")]\n    return version\n}\n\nexports.getRandom = (ext) => {\n    return `${Math.floor(Math.random() * 10000)}${ext}`\n}\n\nexports.isUrl = (url) => {\n    return url.match(new RegExp(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/, 'gi'))\n}\n\nexports.isNumber = (number) => {\n    const int = parseInt(number)\n    return typeof int === 'number' && !isNaN(int)\n}\nexports.TelegraPh= (Path) =>{\n\treturn new Promise (async (resolve, reject) => {\n\t\tif (!fs.existsSync(Path)) return reject(new Error(\"File not Found\"))\n\t\ttry {\n\t\t\tconst form = new BodyForm();\n\t\t\tform.append(\"file\", fs.createReadStream(Path))\n\t\t\tconst data = await  axios({\n\t\t\t\turl: \"https://telegra.ph/upload\",\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t...form.getHeaders()\n\t\t\t\t},\n\t\t\t\tdata: form\n\t\t\t})\n\t\t\treturn resolve(\"https://telegra.ph\" + data.data[0].src)\n\t\t} catch (err) {\n\t\t\treturn reject(new Error(String(err)))\n\t\t}\n\t})\n}\nconst sleepy = async (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports.buffergif = async (image) => {\n        \n\tconst filename = `${Math.random().toString(36)}`\n\t\t\tawait fs.writeFileSync(`./XeonMedia/trash/${filename}.gif`, image)\n\t\t\t\t\t child_process.exec(\n\t\t\t\t\t\t\t\t`ffmpeg -i ./XeonMedia/trash/${filename}.gif -movflags faststart -pix_fmt yuv420p -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" ./XeonMedia/trash/${filename}.mp4`\n\t\t\t\t\t\t\t\t\t\t) \n  await sleepy(4000)\n  \n\tvar buffer5  =  await  fs.readFileSync(`./XeonMedia/trash/${filename}.mp4`)\n\tPromise.all([unlink(`./XeonMedia/video/${filename}.mp4`), unlink(`./XeonMedia/gif/${filename}.gif`)])\n\treturn buffer5\n\t\t\t\t   }","size_bytes":5375},"lib/reactions.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\n// List of emojis for command reactions\nconst commandEmojis = ['‚è≥','üëæ','‚ù§Ô∏è‚Äçüî•','ü´∞','ü™ê'];\n\n// Path for storing auto-reaction state\nconst USER_GROUP_DATA = path.join(__dirname, '../data/userGroupData.json');\n\n// Load auto-reaction state from file\nfunction loadAutoReactionState() {\n    try {\n        if (fs.existsSync(USER_GROUP_DATA)) {\n            const data = JSON.parse(fs.readFileSync(USER_GROUP_DATA));\n            return data.autoReaction || false;\n        }\n    } catch (error) {\n        console.error('Error loading auto-reaction state:', error);\n    }\n    return false;\n}\n\n// Save auto-reaction state to file\nfunction saveAutoReactionState(state) {\n    try {\n        const data = fs.existsSync(USER_GROUP_DATA) \n            ? JSON.parse(fs.readFileSync(USER_GROUP_DATA))\n            : { groups: [], chatbot: {} };\n        \n        data.autoReaction = state;\n        fs.writeFileSync(USER_GROUP_DATA, JSON.stringify(data, null, 2));\n    } catch (error) {\n        console.error('Error saving auto-reaction state:', error);\n    }\n}\n\n// Store auto-reaction state\nlet isAutoReactionEnabled = loadAutoReactionState();\n\nfunction getRandomEmoji() {\n    const idx = Math.floor(Math.random() * commandEmojis.length);\n    return commandEmojis[idx];\n}\n\n// Function to add reaction to a command message\nasync function addCommandReaction(sock, message) {\n    try {\n        if (!isAutoReactionEnabled || !message?.key?.id) return;\n        \n        const emoji = getRandomEmoji();\n        await sock.sendMessage(message.key.remoteJid, {\n            react: {\n                text: emoji,\n                key: message.key\n            }\n        });\n    } catch (error) {\n        console.error('Error adding command reaction:', error);\n    }\n}\n\n// Function to handle areact command\nasync function handleAreactCommand(sock, chatId, message, isOwner) {\n    try {\n        if (!isOwner) {\n            await sock.sendMessage(chatId, { \n                text: '‚ùå This command is only available for the owner!',\n                quoted: message\n            });\n            return;\n        }\n\n        const args = message.message?.conversation?.split(' ') || [];\n        const action = args[1]?.toLowerCase();\n\n        if (action === 'on') {\n            isAutoReactionEnabled = true;\n            saveAutoReactionState(true);\n            await sock.sendMessage(chatId, { \n                text: '‚úÖ Auto-reactions have been enabled globally',\n                quoted: message\n            });\n        } else if (action === 'off') {\n            isAutoReactionEnabled = false;\n            saveAutoReactionState(false);\n            await sock.sendMessage(chatId, { \n                text: '‚úÖ Auto-reactions have been disabled globally',\n                quoted: message\n            });\n        } else {\n            const currentState = isAutoReactionEnabled ? 'enabled' : 'disabled';\n            await sock.sendMessage(chatId, { \n                text: `Auto-reactions are currently ${currentState} globally.\\n\\nUse:\\n.areact on - Enable auto-reactions\\n.areact off - Disable auto-reactions`,\n                quoted: message\n            });\n        }\n    } catch (error) {\n        console.error('Error handling areact command:', error);\n        await sock.sendMessage(chatId, { \n            text: '‚ùå Error controlling auto-reactions',\n            quoted: message\n        });\n    }\n}\n\nmodule.exports = {\n    addCommandReaction,\n    handleAreactCommand\n}; \n","size_bytes":3506},"lib/sticker.js":{"content":"const fs = require('fs')\nconst path = require('path')\nconst crypto = require('crypto')\nconst { spawn } = require('child_process')\nconst { fileTypeFromBuffer } = require('file-type')\nconst webp = require('node-webpmux')\nconst fetch = require('node-fetch')\nconst ffmpeg = require('fluent-ffmpeg')\nconst { exec } = require('child_process')\nconst { promisify } = require('util')\nconst execAsync = promisify(exec)\nconst { writeExifImg } = require('./exif')\n\nconst tmp = path.join(__dirname, '../tmp')\n\n/**\n * Image to Sticker\n * @param {Buffer} img Image Buffer\n * @param {String} url Image URL\n */\nfunction sticker2(img, url) {\n  return new Promise(async (resolve, reject) => {\n    try {\n      if (url) {\n        let res = await fetch(url)\n        if (res.status !== 200) throw await res.text()\n        img = await res.buffer()\n      }\n      let inp = path.join(tmp, +new Date + '.jpeg')\n      await fs.promises.writeFile(inp, img)\n      let ff = spawn('ffmpeg', [\n        '-y',\n        '-i', inp,\n        '-vf', 'scale=512:512:flags=lanczos:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000,setsar=1',\n        '-f', 'png',\n        '-'\n      ])\n      ff.on('error', reject)\n      ff.on('close', async () => {\n        await fs.promises.unlink(inp)\n      })\n      let bufs = []\n      const [_spawnprocess, ..._spawnargs] = [...(module.exports.support.gm ? ['gm'] : module.exports.magick ? ['magick'] : []), 'convert', 'png:-', 'webp:-']\n      let im = spawn(_spawnprocess, _spawnargs)\n      im.on('error', e => conn.reply(m.chat, util.format(e), m))\n      im.stdout.on('data', chunk => bufs.push(chunk))\n      ff.stdout.pipe(im.stdin)\n      im.on('exit', () => {\n        resolve(Buffer.concat(bufs))\n      })\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n\n/**\n * Image/Video to Sticker\n * @param {Buffer} img Image/Video Buffer\n * @param {String} url Image/Video URL\n * @param {String} packname EXIF Packname\n * @param {String} author EXIF Author\n */\nasync function sticker3(img, url, packname, author) {\n  url = url ? url : await uploadFile(img)\n  let res = await fetch('https://api.xteam.xyz/sticker/wm?' + new URLSearchParams(Object.entries({\n    url,\n    packname,\n    author\n  })))\n  return await res.buffer()\n}\n\n/**\n * Image to Sticker\n * @param {Buffer} img Image/Video Buffer\n * @param {String} url Image/Video URL\n */\nasync function sticker4(img, url) {\n  if (url) {\n    let res = await fetch(url)\n    if (res.status !== 200) throw await res.text()\n    img = await res.buffer()\n  }\n  return await ffmpeg(img, [\n    '-vf', 'scale=512:512:flags=lanczos:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=#00000000,setsar=1'\n  ], 'jpeg', 'webp')\n}\n\nasync function sticker5(img, url, packname, author, categories = [''], extra = {}) {\n  const { Sticker } = await import('wa-sticker-formatter')\n  const stickerMetadata = {\n    type: 'default',\n    pack: packname,\n    author,\n    categories,\n    ...extra\n  }\n  return (new Sticker(img ? img : url, stickerMetadata)).toBuffer()\n}\n\n/**\n * Convert using fluent-ffmpeg\n * @param {string} img \n * @param {string} url \n */\nfunction sticker6(img, url) {\n  return new Promise(async (resolve, reject) => {\n    if (url) {\n      let res = await fetch(url)\n      if (res.status !== 200) throw await res.text()\n      img = await res.buffer()\n    }\n    const type = await fileTypeFromBuffer(img) || {\n      mime: 'application/octet-stream',\n      ext: 'bin'\n    }\n    if (type.ext == 'bin') reject(img)\n    const tmp = path.join(__dirname, `../tmp/${+ new Date()}.${type.ext}`)\n    const out = path.join(tmp + '.webp')\n    await fs.promises.writeFile(tmp, img)\n    // https://github.com/MhankBarBar/termux-wabot/blob/main/index.js#L313#L368\n    let Fffmpeg = /video/i.test(type.mime) ? fluent_ffmpeg(tmp).inputFormat(type.ext) : fluent_ffmpeg(tmp).input(tmp)\n    Fffmpeg\n      .on('error', function (err) {\n        console.error(err)\n        fs.promises.unlink(tmp)\n        reject(img)\n      })\n      .on('end', async function () {\n        fs.promises.unlink(tmp)\n        resolve(await fs.promises.readFile(out))\n      })\n      .addOutputOptions([\n        `-vcodec`, `libwebp`, `-vf`,\n        `scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`\n      ])\n      .toFormat('webp')\n      .save(out)\n  })\n}\n/**\n * Add WhatsApp JSON Exif Metadata\n * Taken from https://github.com/pedroslopez/whatsapp-web.js/pull/527/files\n * @param {Buffer} webpSticker \n * @param {String} packname \n * @param {String} author \n * @param {String} categories \n * @param {Object} extra \n * @returns \n */\nasync function addExif(webpSticker, packname, author, categories = [''], extra = {}) {\n  const img = new webp.Image();\n  const stickerPackId = crypto.randomBytes(32).toString('hex');\n  const json = { 'sticker-pack-id': stickerPackId, 'sticker-pack-name': packname, 'sticker-pack-publisher': author, 'emojis': categories, ...extra };\n  let exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n  let jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');\n  let exif = Buffer.concat([exifAttr, jsonBuffer]);\n  exif.writeUIntLE(jsonBuffer.length, 14, 4);\n  await img.load(webpSticker)\n  img.exif = exif\n  return await img.save(null)\n}\n\n/**\n * Convert media to WebP and add metadata\n * @param {Buffer} inputBuffer Image Buffer\n * @param {String} url Image URL\n * @param {String} packname EXIF Packname\n * @param {String} author EXIF Author\n */\nasync function sticker(isImage, url, packname, author) {\n    try {\n        const response = await fetch(url);\n        const buffer = await response.buffer();\n        \n        // Create sticker with metadata\n        const stickerBuffer = await writeExifImg(buffer, {\n            packname: packname || 'WhatsApp Bot',\n            author: author || '@bot'\n        });\n        \n        return stickerBuffer;\n    } catch (error) {\n        console.error('Error in sticker creation:', error);\n        return null;\n    }\n}\n\nconst support = {\n  ffmpeg: true,\n  ffprobe: true,\n  ffmpegWebp: true,\n  convert: true,\n  magick: false,\n  gm: false,\n  find: false\n}\n\nmodule.exports = {\n  sticker,\n  sticker2,\n  sticker3,\n  sticker4,\n  sticker6,\n  addExif,\n  support\n}","size_bytes":6458},"lib/tictactoe.js":{"content":"class TicTacToe {\n    constructor(playerX = 'x', playerO = 'o') {\n        this.playerX = playerX;\n        this.playerO = playerO;\n        this._currentTurn = false;\n        this._x = 0;\n        this._o = 0;\n        this.turns = 0;\n    }\n\n    get board() {\n        return this._x | this._o;\n    }\n\n    get currentTurn() {\n        return this._currentTurn ? this.playerO : this.playerX;\n    }\n\n    get winner() {\n        // All possible winning combinations\n        const winningPatterns = [\n            0b111000000, // Top row\n            0b000111000, // Middle row\n            0b000000111, // Bottom row\n            0b100100100, // Left column\n            0b010010010, // Middle column\n            0b001001001, // Right column\n            0b100010001, // Diagonal from top-left\n            0b001010100  // Diagonal from top-right\n        ];\n\n        // Check X's moves\n        for (let pattern of winningPatterns) {\n            if ((this._x & pattern) === pattern) {\n                return this.playerX;\n            }\n        }\n\n        // Check O's moves\n        for (let pattern of winningPatterns) {\n            if ((this._o & pattern) === pattern) {\n                return this.playerO;\n            }\n        }\n\n        return null;\n    }\n\n    turn(player, pos) {\n        // If game is over or invalid position\n        if (this.winner || pos < 0 || pos > 8) return -1;\n        \n        // If position is already taken\n        if ((this._x | this._o) & (1 << pos)) return 0;\n        \n        // Make the move\n        const value = 1 << pos;\n        if (this._currentTurn) {\n            this._o |= value;\n        } else {\n            this._x |= value;\n        }\n        \n        this._currentTurn = !this._currentTurn;\n        this.turns++;\n        return 1;\n    }\n\n    render() {\n        return [...Array(9)].map((_, i) => {\n            const bit = 1 << i;\n            return this._x & bit ? 'X' : this._o & bit ? 'O' : i + 1;\n        });\n    }\n}\n\nmodule.exports = TicTacToe; ","size_bytes":1979},"lib/uploadImage.js":{"content":"const fetch = require('node-fetch');\nconst FormData = require('form-data');\nconst FileType = require('file-type');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Upload file to qu.ax\n * Supported mimetypes:\n * - `image/jpeg`\n * - `image/jpg`\n * - `image/png`\n * @param {Buffer} buffer File Buffer\n * @return {Promise<string>}\n */\nasync function uploadImage(buffer) {\n    try {\n        // Create temp directory if it doesn't exist\n        const tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(tmpDir)) {\n            fs.mkdirSync(tmpDir, { recursive: true });\n        }\n\n        // Get file type\n        const fileType = await FileType.fromBuffer(buffer);\n        const { ext, mime } = fileType || { ext: 'png', mime: 'image/png' };\n        const tempFile = path.join(tmpDir, `temp_${Date.now()}.${ext}`);\n\n        // Save buffer to temp file\n        fs.writeFileSync(tempFile, buffer);\n\n        // Create form data\n        const form = new FormData();\n        form.append('files[]', fs.createReadStream(tempFile));\n\n        // Upload to qu.ax\n        const response = await fetch('https://qu.ax/upload.php', {\n            method: 'POST',\n            body: form,\n            headers: form.getHeaders()\n        });\n\n        // Clean up temp file\n        fs.unlinkSync(tempFile);\n\n        const result = await response.json();\n        if (result && result.success) {\n            return result.files[0].url;\n        } else {\n            // Fallback to telegraph if qu.ax fails\n            const telegraphForm = new FormData();\n            telegraphForm.append('file', buffer, {\n                filename: `upload.${ext}`,\n                contentType: mime\n            });\n\n            const telegraphResponse = await fetch('https://telegra.ph/upload', {\n                method: 'POST',\n                body: telegraphForm\n            });\n\n            const img = await telegraphResponse.json();\n            if (img[0]?.src) {\n                return 'https://telegra.ph' + img[0].src;\n            }\n            \n            throw new Error('Failed to upload image to both services');\n        }\n    } catch (error) {\n        console.error('Upload error:', error);\n        throw error;\n    }\n}\n\nmodule.exports = { uploadImage };\n\n/**\n * Alternative upload to telegra.ph (backup)\n */\n/*\nasync function uploadImageTelegraph(buffer) {\n    try {\n        const { ext, mime } = await fileTypeFromBuffer(buffer);\n        const form = new FormData();\n        const blob = new Blob([buffer.toArrayBuffer()], { type: mime });\n        form.append('file', blob, 'tmp.' + ext);\n\n        const response = await fetch('https://telegra.ph/upload', {\n            method: 'POST',\n            body: form\n        });\n\n        const img = await response.json();\n        if (img.error) throw img.error;\n        return 'https://telegra.ph' + img[0].src;\n    } catch (error) {\n        throw error;\n    }\n}\n*/ ","size_bytes":2914},"lib/uploader.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nlet axios = require('axios')\nlet BodyForm = require('form-data')\nlet { fromBuffer } = require('file-type')\nlet fetch = require('node-fetch')\nlet fs = require('fs')\nlet cheerio = require('cheerio')\n\n\n\nfunction TelegraPh (Path) {\n\treturn new Promise (async (resolve, reject) => {\n\t\tif (!fs.existsSync(Path)) return reject(new Error(\"File not Found\"))\n\t\ttry {\n\t\t\tconst form = new BodyForm();\n\t\t\tform.append(\"file\", fs.createReadStream(Path))\n\t\t\tconst data = await  axios({\n\t\t\t\turl: \"https://telegra.ph/upload\",\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t...form.getHeaders()\n\t\t\t\t},\n\t\t\t\tdata: form\n\t\t\t})\n\t\t\treturn resolve(\"https://telegra.ph\" + data.data[0].src)\n\t\t} catch (err) {\n\t\t\treturn reject(new Error(String(err)))\n\t\t}\n\t})\n}\n\nasync function UploadFileUgu (input) {\n\treturn new Promise (async (resolve, reject) => {\n\t\t\tconst form = new BodyForm();\n\t\t\tform.append(\"files[]\", fs.createReadStream(input))\n\t\t\tawait axios({\n\t\t\t\turl: \"https://uguu.se/upload.php\",\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\",\n\t\t\t\t\t...form.getHeaders()\n\t\t\t\t},\n\t\t\t\tdata: form\n\t\t\t}).then((data) => {\n\t\t\t\tresolve(data.data.files[0])\n\t\t\t}).catch((err) => reject(err))\n\t})\n}\n\nfunction webp2mp4File(path) {\n\treturn new Promise((resolve, reject) => {\n\t\t const form = new BodyForm()\n\t\t form.append('new-image-url', '')\n\t\t form.append('new-image', fs.createReadStream(path))\n\t\t axios({\n\t\t\t  method: 'post',\n\t\t\t  url: 'https://s6.ezgif.com/webp-to-mp4',\n\t\t\t  data: form,\n\t\t\t  headers: {\n\t\t\t\t   'Content-Type': `multipart/form-data; boundary=${form._boundary}`\n\t\t\t  }\n\t\t }).then(({ data }) => {\n\t\t\t  const bodyFormThen = new BodyForm()\n\t\t\t  const $ = cheerio.load(data)\n\t\t\t  const file = $('input[name=\"file\"]').attr('value')\n\t\t\t  bodyFormThen.append('file', file)\n\t\t\t  bodyFormThen.append('convert', \"Convert WebP to MP4!\")\n\t\t\t  axios({\n\t\t\t\t   method: 'post',\n\t\t\t\t   url: 'https://ezgif.com/webp-to-mp4/' + file,\n\t\t\t\t   data: bodyFormThen,\n\t\t\t\t   headers: {\n\t\t\t\t\t\t'Content-Type': `multipart/form-data; boundary=${bodyFormThen._boundary}`\n\t\t\t\t   }\n\t\t\t  }).then(({ data }) => {\n\t\t\t\t   const $ = cheerio.load(data)\n\t\t\t\t   const result = 'https:' + $('div#output > p.outfile > video > source').attr('src')\n\t\t\t\t   resolve({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tmessage: \"Created By MRHRTZ\",\n\t\t\t\t\t\tresult: result\n\t\t\t\t   })\n\t\t\t  }).catch(reject)\n\t\t }).catch(reject)\n\t})\n}\n\nasync function floNime(medianya, options = {}) {\nconst { ext } = await fromBuffer(medianya) || options.ext\n        var form = new BodyForm()\n        form.append('file', medianya, 'tmp.'+ext)\n        let jsonnya = await fetch('https://flonime.my.id/upload', {\n                method: 'POST',\n                body: form\n        })\n        .then((response) => response.json())\n        return jsonnya\n}\n\nmodule.exports = { TelegraPh, UploadFileUgu, webp2mp4File, floNime }","size_bytes":3220},"lib/welcome.js":{"content":"const { addWelcome, delWelcome, isWelcomeOn, addGoodbye, delGoodBye, isGoodByeOn } = require('../lib/index');\nconst { delay } = require('@whiskeysockets/baileys');\n\nasync function handleWelcome(sock, chatId, message, match) {\n    if (!match) {\n        return sock.sendMessage(chatId, {\n            text: `üì• *Welcome Message Setup*\\n\\n‚úÖ *.welcome on* ‚Äî Enable welcome messages\\nüõ†Ô∏è *.welcome set Your custom message* ‚Äî Set a custom welcome message\\nüö´ *.welcome off* ‚Äî Disable welcome messages\\n\\n*Available Variables:*\\n‚Ä¢ {user} - Mentions the new member\\n‚Ä¢ {group} - Shows group name\\n‚Ä¢ {description} - Shows group description`,\n            quoted: message\n        });\n    }\n\n    const [command, ...args] = match.split(' ');\n    const lowerCommand = command.toLowerCase();\n    const customMessage = args.join(' ');\n\n    if (lowerCommand === 'on') {\n        if (await isWelcomeOn(chatId)) {\n            return sock.sendMessage(chatId, { text: '‚ö†Ô∏è Welcome messages are *already enabled*.', quoted: message });\n        }\n        await addWelcome(chatId, true, 'Welcome {user} to {group}! üéâ');\n        return sock.sendMessage(chatId, { text: '‚úÖ Welcome messages *enabled* with simple message. Use *.welcome set [your message]* to customize.', quoted: message });\n    }\n\n    if (lowerCommand === 'off') {\n        if (!(await isWelcomeOn(chatId))) {\n            return sock.sendMessage(chatId, { text: '‚ö†Ô∏è Welcome messages are *already disabled*.', quoted: message });\n        }\n        await delWelcome(chatId);\n        return sock.sendMessage(chatId, { text: '‚úÖ Welcome messages *disabled* for this group.', quoted: message });\n    }\n\n    if (lowerCommand === 'set') {\n        if (!customMessage) {\n            return sock.sendMessage(chatId, { text: '‚ö†Ô∏è Please provide a custom welcome message. Example: *.welcome set Welcome to the group!*', quoted: message });\n        }\n        await addWelcome(chatId, true, customMessage);\n        return sock.sendMessage(chatId, { text: '‚úÖ Custom welcome message *set successfully*.', quoted: message });\n    }\n\n    // If no valid command is provided\n    return sock.sendMessage(chatId, {\n        text: `‚ùå Invalid command. Use:\\n*.welcome on* - Enable\\n*.welcome set [message]* - Set custom message\\n*.welcome off* - Disable`,\n        quoted: message\n    });\n}\n\nasync function handleGoodbye(sock, chatId, message, match) {\n    const lower = match?.toLowerCase();\n\n    if (!match) {\n        return sock.sendMessage(chatId, {\n            text: `üì§ *Goodbye Message Setup*\\n\\n‚úÖ *.goodbye on* ‚Äî Enable goodbye messages\\nüõ†Ô∏è *.goodbye set Your custom message* ‚Äî Set a custom goodbye message\\nüö´ *.goodbye off* ‚Äî Disable goodbye messages\\n\\n*Available Variables:*\\n‚Ä¢ {user} - Mentions the leaving member\\n‚Ä¢ {group} - Shows group name`,\n            quoted: message\n        });\n    }\n\n    if (lower === 'on') {\n        if (await isGoodByeOn(chatId)) {\n            return sock.sendMessage(chatId, { text: '‚ö†Ô∏è Goodbye messages are *already enabled*.', quoted: message });\n        }\n        await addGoodbye(chatId, true, 'Goodbye {user} üëã');\n        return sock.sendMessage(chatId, { text: '‚úÖ Goodbye messages *enabled* with simple message. Use *.goodbye set [your message]* to customize.', quoted: message });\n    }\n\n    if (lower === 'off') {\n        if (!(await isGoodByeOn(chatId))) {\n            return sock.sendMessage(chatId, { text: '‚ö†Ô∏è Goodbye messages are *already disabled*.', quoted: message });\n        }\n        await delGoodBye(chatId);\n        return sock.sendMessage(chatId, { text: '‚úÖ Goodbye messages *disabled* for this group.', quoted: message });\n    }\n\n    if (lower.startsWith('set ')) {\n        const customMessage = match.substring(4);\n        if (!customMessage) {\n            return sock.sendMessage(chatId, { text: '‚ö†Ô∏è Please provide a custom goodbye message. Example: *.goodbye set Goodbye!*', quoted: message });\n        }\n        await addGoodbye(chatId, true, customMessage);\n        return sock.sendMessage(chatId, { text: '‚úÖ Custom goodbye message *set successfully*.', quoted: message });\n    }\n\n    // If no valid command is provided\n    return sock.sendMessage(chatId, {\n        text: `‚ùå Invalid command. Use:\\n*.goodbye on* - Enable\\n*.goodbye set [message]* - Set custom message\\n*.goodbye off* - Disable`,\n        quoted: message\n    });\n}\n\nmodule.exports = { handleWelcome, handleGoodbye };\n// This code handles welcome and goodbye messages in a WhatsApp group using the Baileys library.","size_bytes":4545},"lib/ytdl2.js":{"content":"/**\n * Knight Bot - A WhatsApp Bot\n * Copyright (c) 2024 Professor\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n * \n * Credits:\n * - Baileys Library by @adiwajshing\n * - Pair Code implementation inspired by TechGod143 & DGXEON\n */\nconst ytdl = require('@distube/ytdl-core');\nconst yts = require('youtube-yts');\nconst readline = require('readline');\nconst ffmpeg = require('fluent-ffmpeg')\nconst NodeID3 = require('node-id3')\nconst fs = require('fs');\nconst { fetchBuffer } = require(\"./myfunc2\")\nconst ytM = require('node-youtube-music')\nconst { randomBytes } = require('crypto')\nconst ytIdRegex = /(?:youtube\\.com\\/\\S*(?:(?:\\/e(?:mbed))?\\/|watch\\?(?:\\S*?&?v\\=))|youtu\\.be\\/)([a-zA-Z0-9_-]{6,11})/\nconst path = require('path');\n\nclass YTDownloader {\n    constructor() {\n        this.tmpDir = path.join(process.cwd(), 'tmp');\n        if (!fs.existsSync(this.tmpDir)) {\n            fs.mkdirSync(this.tmpDir, { recursive: true });\n        }\n    }\n\n    /**\n     * Checks if it is yt link\n     * @param {string|URL} url youtube url\n     * @returns Returns true if the given YouTube URL.\n     */\n    static isYTUrl = (url) => {\n        return ytIdRegex.test(url)\n    }\n\n    /**\n     * VideoID from url\n     * @param {string|URL} url to get videoID\n     * @returns \n     */\n    static getVideoID = (url) => {\n        if (!this.isYTUrl(url)) throw new Error('is not YouTube URL')\n        return ytIdRegex.exec(url)[1]\n    }\n\n    /**\n     * @typedef {Object} IMetadata\n     * @property {string} Title track title\n     * @property {string} Artist track Artist\n     * @property {string} Image track thumbnail url\n     * @property {string} Album track album\n     * @property {string} Year track release date\n     */\n\n    /**\n     * Write Track Tag Metadata\n     * @param {string} filePath \n     * @param {IMetadata} Metadata \n     */\n    static WriteTags = async (filePath, Metadata) => {\n        NodeID3.write(\n            {\n                title: Metadata.Title,\n                artist: Metadata.Artist,\n                originalArtist: Metadata.Artist,\n                image: {\n                    mime: 'jpeg',\n                    type: {\n                        id: 3,\n                        name: 'front cover',\n                    },\n                    imageBuffer: (await fetchBuffer(Metadata.Image)).buffer,\n                    description: `Cover of ${Metadata.Title}`,\n                },\n                album: Metadata.Album,\n                year: Metadata.Year || ''\n            },\n            filePath\n        );\n    }\n\n    /**\n     * \n     * @param {string} query \n     * @returns \n     */\n    static search = async (query, options = {}) => {\n        const search = await yts.search({ query, hl: 'id', gl: 'ID', ...options })\n        return search.videos\n    }\n\n    /**\n     * @typedef {Object} TrackSearchResult\n     * @property {boolean} isYtMusic is from YT Music search?\n     * @property {string} title music title\n     * @property {string} artist music artist\n     * @property {string} id YouTube ID\n     * @property {string} url YouTube URL\n     * @property {string} album music album\n     * @property {Object} duration music duration {seconds, label}\n     * @property {string} image Cover Art\n     */\n\n    /**\n     * search track with details\n     * @param {string} query \n     * @returns {Promise<TrackSearchResult[]>}\n     */\n    static searchTrack = (query) => {\n        return new Promise(async (resolve, reject) => {\n            try {\n                let ytMusic = await ytM.searchMusics(query);\n                let result = []\n                for (let i = 0; i < ytMusic.length; i++) {\n                    result.push({\n                        isYtMusic: true,\n                        title: `${ytMusic[i].title} - ${ytMusic[i].artists.map(x => x.name).join(' ')}`,\n                        artist: ytMusic[i].artists.map(x => x.name).join(' '),\n                        id: ytMusic[i].youtubeId,\n                        url: 'https://youtu.be/' + ytMusic[i].youtubeId,\n                        album: ytMusic[i].album,\n                        duration: {\n                            seconds: ytMusic[i].duration.totalSeconds,\n                            label: ytMusic[i].duration.label\n                        },\n                        image: ytMusic[i].thumbnailUrl.replace('w120-h120', 'w600-h600')\n                    })\n                 \n                }\n                resolve(result)\n            } catch (error) {\n                reject(error)\n            }\n        })\n    }\n\n    /**\n     * @typedef {Object} MusicResult\n     * @property {TrackSearchResult} meta music meta\n     * @property {string} path file path\n     */\n\n    /**\n     * Download music with full tag metadata\n     * @param {string|TrackSearchResult[]} query title of track want to download\n     * @returns {Promise<MusicResult>} filepath of the result\n     */\n    static downloadMusic = async (query) => {\n        try {\n            const getTrack = Array.isArray(query) ? query : await this.searchTrack(query);\n            const search = getTrack[0]//await this.searchTrack(query)\n            const videoInfo = await ytdl.getInfo('https://www.youtube.com/watch?v=' + search.id, { lang: 'id' });\n            let stream = ytdl(search.id, { filter: 'audioonly', quality: 140 });\n            let songPath = `./XeonMedia/audio/${randomBytes(3).toString('hex')}.mp3`\n            stream.on('error', (err) => console.log(err))\n\n            const file = await new Promise((resolve) => {\n                ffmpeg(stream)\n                    .audioFrequency(44100)\n                    .audioChannels(2)\n                    .audioBitrate(128)\n                    .audioCodec('libmp3lame')\n                    .audioQuality(5)\n                    .toFormat('mp3')\n                    .save(songPath)\n                    .on('end', () => resolve(songPath))\n            });\n            await this.WriteTags(file, { Title: search.title, Artist: search.artist, Image: search.image, Album: search.album, Year: videoInfo.videoDetails.publishDate.split('-')[0] });\n            return {\n                meta: search,\n                path: file,\n                size: fs.statSync(songPath).size\n            }\n        } catch (error) {\n            throw new Error(error)\n        }\n    }\n\n    /**\n     * get downloadable video urls\n     * @param {string|URL} query videoID or YouTube URL\n     * @param {string} quality \n     * @returns\n     */\n    static mp4 = async (query, quality = 134) => {\n        try {\n            if (!query) throw new Error('Video ID or YouTube Url is required')\n            const videoId = this.isYTUrl(query) ? this.getVideoID(query) : query\n            const videoInfo = await ytdl.getInfo('https://www.youtube.com/watch?v=' + videoId, { lang: 'id' });\n            const format = ytdl.chooseFormat(videoInfo.formats, { format: quality, filter: 'videoandaudio' })\n            return {\n                title: videoInfo.videoDetails.title,\n                thumb: videoInfo.videoDetails.thumbnails.slice(-1)[0],\n                date: videoInfo.videoDetails.publishDate,\n                duration: videoInfo.videoDetails.lengthSeconds,\n                channel: videoInfo.videoDetails.ownerChannelName,\n                quality: format.qualityLabel,\n                contentLength: format.contentLength,\n                description:videoInfo.videoDetails.description,\n                videoUrl: format.url\n            }\n        } catch (error) {\n            throw error\n        }\n    }\n\n    /**\n     * Download YouTube to mp3\n     * @param {string|URL} url YouTube link want to download to mp3\n     * @param {IMetadata} metadata track metadata\n     * @param {boolean} autoWriteTags if set true, it will auto write tags meta following the YouTube info\n     * @returns \n     */\n    static mp3 = async (url, metadata = {}, autoWriteTags = false) => {\n        try {\n            if (!url) throw new Error('Video ID or YouTube Url is required')\n            url = this.isYTUrl(url) ? 'https://www.youtube.com/watch?v=' + this.getVideoID(url) : url\n            const { videoDetails } = await ytdl.getInfo(url, { lang: 'id' });\n            let stream = ytdl(url, { filter: 'audioonly', quality: 140 });\n            let songPath = `./XeonMedia/audio/${randomBytes(3).toString('hex')}.mp3`\n\n            let starttime;\n            stream.once('response', () => {\n                starttime = Date.now();\n            });\n            stream.on('progress', (chunkLength, downloaded, total) => {\n                const percent = downloaded / total;\n                const downloadedMinutes = (Date.now() - starttime) / 1000 / 60;\n                const estimatedDownloadTime = (downloadedMinutes / percent) - downloadedMinutes;\n                readline.cursorTo(process.stdout, 0);\n                process.stdout.write(`${(percent * 100).toFixed(2)}% downloaded `);\n                process.stdout.write(`(${(downloaded / 1024 / 1024).toFixed(2)}MB of ${(total / 1024 / 1024).toFixed(2)}MB)\\n`);\n                process.stdout.write(`running for: ${downloadedMinutes.toFixed(2)}minutes`);\n                process.stdout.write(`, estimated time left: ${estimatedDownloadTime.toFixed(2)}minutes `);\n                readline.moveCursor(process.stdout, 0, -1);\n                //let txt = `${bgColor(color('[FFMPEG]]', 'black'), '#38ef7d')} ${color(moment().format('DD/MM/YY HH:mm:ss'), '#A1FFCE')} ${gradient.summer('[Converting..]')} ${gradient.cristal(p.targetSize)} kb`\n            });\n            stream.on('end', () => process.stdout.write('\\n\\n'));\n            stream.on('error', (err) => console.log(err))\n\n            const file = await new Promise((resolve) => {\n                ffmpeg(stream)\n                    .audioFrequency(44100)\n                    .audioChannels(2)\n                    .audioBitrate(128)\n                    .audioCodec('libmp3lame')\n                    .audioQuality(5)\n                    .toFormat('mp3')\n                    .save(songPath)\n                    .on('end', () => {\n                        resolve(songPath)\n                    })\n            });\n            if (Object.keys(metadata).length !== 0) {\n                await this.WriteTags(file, metadata)\n            }\n            if (autoWriteTags) {\n                await this.WriteTags(file, { Title: videoDetails.title, Album: videoDetails.author.name, Year: videoDetails.publishDate.split('-')[0], Image: videoDetails.thumbnails.slice(-1)[0].url })\n            }\n            return {\n                meta: {\n                    title: videoDetails.title,\n                    channel: videoDetails.author.name,\n                    seconds: videoDetails.lengthSeconds,\n                    image: videoDetails.thumbnails.slice(-1)[0].url\n                },\n                path: file,\n                size: fs.statSync(songPath).size\n            }\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async mp3(url) {\n        try {\n            const info = await ytdl.getInfo(url);\n            const audioFormat = ytdl.chooseFormat(info.formats, { quality: 'highestaudio' });\n            \n            const fileName = `${Date.now()}.mp3`;\n            const filePath = path.join(this.tmpDir, fileName);\n\n            return new Promise((resolve, reject) => {\n                const stream = ytdl(url, {\n                    quality: 'highestaudio',\n                    filter: 'audioonly'\n                });\n\n                ffmpeg(stream)\n                    .audioBitrate(128)\n                    .toFormat('mp3')\n                    .save(filePath)\n                    .on('end', () => {\n                        resolve({\n                            path: filePath,\n                            meta: {\n                                title: info.videoDetails.title,\n                                thumbnail: info.videoDetails.thumbnails[0].url\n                            }\n                        });\n                    })\n                    .on('error', (err) => reject(err));\n            });\n        } catch (error) {\n            console.error('Error downloading audio:', error);\n            throw error;\n        }\n    }\n}\n\nmodule.exports = new YTDownloader();","size_bytes":12221},"commands/autoreact.js":{"content":"\nconst fs = require('fs');\nconst path = require('path');\n\nasync function autoreactCommand(sock, chatId, message) {\n    try {\n        // Check if sender is the owner or sudo\n        const senderJid = message.key.participant || message.key.remoteJid;\n        const isOwnerOrSudo = require('../lib/isOwner');\n        const hasPermission = await isOwnerOrSudo(senderJid);\n\n        if (!hasPermission) {\n            await sock.sendMessage(chatId, {\n                text: '‚ùå This command is only available for the owner or sudo users!',\n            });\n            return;\n        }\n\n        // Get command arguments\n        const text = message.message?.conversation || message.message?.extendedTextMessage?.text || '';\n        const args = text.trim().split(' ').slice(1);\n        const action = args[0]?.toLowerCase();\n\n        // Path to user group data\n        const dataPath = path.join(__dirname, '../data/userGroupData.json');\n        \n        // Load current data\n        let data = {};\n        if (fs.existsSync(dataPath)) {\n            try {\n                data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));\n            } catch (err) {\n                console.error('Error reading userGroupData:', err);\n            }\n        }\n\n        if (!action || (action !== 'on' && action !== 'off')) {\n            const currentStatus = data.autoReaction ? 'ON' : 'OFF';\n            await sock.sendMessage(chatId, {\n                text: `üîÑ *Auto Reaction Settings*\\n\\nCurrent Status: ${currentStatus}\\n\\n*Commands:*\\n.autoreact on - Enable auto reactions\\n.autoreact off - Disable auto reactions`,\n            });\n            return;\n        }\n\n        // Update setting\n        data.autoReaction = action === 'on';\n\n        // Save data\n        try {\n            fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));\n            await sock.sendMessage(chatId, {\n                text: `‚úÖ Auto reactions have been ${action === 'on' ? 'enabled' : 'disabled'}!`,\n            });\n        } catch (err) {\n            console.error('Error saving autoreact config:', err);\n            await sock.sendMessage(chatId, {\n                text: '‚ùå Failed to update auto reaction settings!',\n            });\n        }\n\n    } catch (error) {\n        console.error('Error in autoreact command:', error);\n        await sock.sendMessage(chatId, {\n            text: '‚ùå Error processing autoreact command!',\n        });\n    }\n}\n\nmodule.exports = autoreactCommand;\n","size_bytes":2461},"commands/mode.js":{"content":"// Check if the user is the owner\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudoFunc = require('../lib/isOwner');\n    const isOwner = await isOwnerOrSudoFunc(senderJid);\n\n    if (!isOwner) {\n        await sock.sendMessage(chatId, { \n            text: '‚ùå This command is only available for the owner or sudo users!' \n        }, { quoted: message });\n        return;\n    }\n// Check if the user is the owner\n    const senderJid = message.key.participant || message.key.remoteJid;\n    const isOwnerOrSudoFunc = require('../lib/isOwner');\n    const isOwner = await isOwnerOrSudoFunc(senderJid);\n\n    if (!isOwner) {\n        await sock.sendMessage(chatId, { \n            text: '‚ùå This command is only available for the owner or sudo users!' \n        }, { quoted: message });\n        return;\n    }","size_bytes":843}},"version":1}